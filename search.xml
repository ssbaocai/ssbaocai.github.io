<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql基础笔记</title>
      <link href="2020/11/14/MySQL%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/14/MySQL%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据库的基本概念"><a class="anchor" href="#数据库的基本概念">#</a> 数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？* 用于存储和管理数据的仓库。3. 数据库的特点：1. 持久化存储数据的。其实数据库就是一个文件系统2. 方便存储和管理数据3. 使用了统一的方式操作数据库 -- SQL</code></pre><h2 id="mysql数据库软件"><a class="anchor" href="#mysql数据库软件">#</a> MySQL 数据库软件</h2><pre><code>1. 安装2. 卸载1. 去mysql的安装目录找到my.ini文件* 复制 datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"2. 卸载MySQL3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置* MySQL服务启动1. 手动。2. cmd--&gt; services.msc 打开服务的窗口3. 使用管理员打开cmd* net start mysql : 启动mysql的服务* net stop mysql:关闭mysql服务* MySQL登录1. mysql -uroot -p密码2. mysql -hip -uroot -p连接目标的密码3. mysql --host=ip --user=root --password=连接目标的密码* MySQL退出1. exit2. quit* MySQL目录结构1. MySQL安装目录：basedir="D:/develop/MySQL/"* 配置文件 my.ini2. MySQL数据目录：datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"* 几个概念* 数据库：文件夹* 表：文件* 数据：数据</code></pre><h2 id="sql"><a class="anchor" href="#sql">#</a> SQL</h2><pre><code>1.什么是SQL？Structured Query Language：结构化查询语言其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法1. SQL 语句可以单行或多行书写，以分号结尾。2. 可使用空格和缩进来增强语句的可读性。3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。4. 3 种注释* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */3. SQL分类1) DDL(Data Definition Language)数据定义语言用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等2) DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等3) DQL(Data Query Language)数据查询语言用来查询数据库中表的记录(数据)。关键字：select, where 等4) DCL(Data Control Language)数据控制语言(了解)用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="ddl操作数据库-表"><a class="anchor" href="#ddl操作数据库-表">#</a> DDL: 操作数据库、表</h2><pre><code>1. 操作数据库：CRUD1. C(Create):创建* 创建数据库：* create database 数据库名称;* 创建数据库，判断不存在，再创建：* create database if not exists 数据库名称;* 创建数据库，并指定字符集* create database 数据库名称 character set 字符集名;* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk* create database if not exists db4 character set gbk;2. R(Retrieve)：查询* 查询所有数据库的名称:* show databases;* 查询某个数据库的字符集:查询某个数据库的创建语句* show create database 数据库名称;3. U(Update):修改* 修改数据库的字符集* alter database 数据库名称 character set 字符集名称;4. D(Delete):删除* 删除数据库* drop database 数据库名称;* 判断数据库存在，存在再删除* drop database if exists 数据库名称;5. 使用数据库* 查询当前正在使用的数据库名称* select database();* 使用数据库* use 数据库名称;2. 操作表1. C(Create):创建1. 语法：create table 表名(列名1 数据类型1,列名2 数据类型2,....列名n 数据类型n);* 注意：最后一列，不需要加逗号（,）* 数据库类型：1. int：整数类型* age int,2. double:小数类型* score double(5,2)3. date:日期，只包含年月日，yyyy-MM-dd4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss5. timestamp:时间错类型包含年月日时分秒 yyyy-MM-dd HH:mm:ss* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值6. varchar：字符串* name varchar(20):姓名最大20个字符* zhangsan 8个字符  张三 2个字符* 创建表create table student(id int,name varchar(32),age int ,score double(4,1),birthday date,insert_time timestamp);* 复制表：* create table 表名 like 被复制的表名;  2. R(Retrieve)：查询* 查询某个数据库中所有的表名称* show tables;* 查询表结构* desc 表名;3. U(Update):修改1. 修改表名alter table 表名 rename to 新的表名;2. 修改表的字符集alter table 表名 character set 字符集名称;3. 添加一列alter table 表名 add 列名 数据类型;4. 修改列名称 类型alter table 表名 change 列名 新列别 新数据类型;alter table 表名 modify 列名 新数据类型;5. 删除列alter table 表名 drop 列名;4. D(Delete):删除* drop table 表名;* drop table  if exists 表名 ;</code></pre><h2 id="dml增删改表中数据"><a class="anchor" href="#dml增删改表中数据">#</a> DML：增删改表中数据</h2><pre><code>1. 添加数据：* 语法：* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);* 注意：1. 列名和值要一一对应。2. 如果表名后，不定义列名，则默认给所有列添加值insert into 表名 values(值1,值2,...值n);3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：* 语法：* delete from 表名 [where 条件]* 注意：1. 如果不加条件，则删除表中所有记录。2. 如果要删除所有记录1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：* 语法：* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];* 注意：1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="dql查询表中的记录"><a class="anchor" href="#dql查询表中的记录">#</a> DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：select字段列表from表名列表where条件列表group by分组字段having分组之后的条件order by排序limit分页限定2. 基础查询1. 多个字段的查询select 字段名1，字段名2... from 表名；* 注意：* 如果查询所有字段，则可以使用*来替代字段列表。2. 去除重复：* distinct3. 起别名：* as：as也可以省略3. 条件查询1. where子句后跟条件2. 运算符* &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;* BETWEEN...AND  * IN( 集合) * LIKE：模糊查询* 占位符：* _:单个任意字符* %：多个任意字符* IS NULL  * and  或 &amp;&amp;* or  或 || * not  或 !-- 查询年龄大于20岁SELECT * FROM student WHERE age &gt; 20;SELECT * FROM student WHERE age &gt;= 20;-- 查询年龄等于20岁SELECT * FROM student WHERE age = 20;-- 查询年龄不等于20岁SELECT * FROM student WHERE age != 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄大于等于20 小于等于30SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄22岁，18岁，25岁的信息SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25SELECT * FROM student WHERE age IN (22,18,25);-- 查询英语成绩为nullSELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为nullSELECT * FROM student WHERE english  IS NOT NULL;-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE '马%';-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE "_化%";-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE '%德%';</code></pre><p>​</p><p>​</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的常用算法</title>
      <link href="2020/11/08/Java%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>2020/11/08/Java%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java中的常用算法"><a class="anchor" href="#java中的常用算法">#</a> Java 中的常用算法</h1><h2 id="冒泡排序"><a class="anchor" href="#冒泡排序">#</a> 冒泡排序</h2><p>冒泡排序算法是把较小的元素往前调或者把较大的元素往后调。这种方法主要是通过对相邻两个元素进行大小的比较，根据比较结果和算法规则对该二元素的位置进行交换，这样逐个依次进行比较和交换，就能达到排序目的。<br>&lt;img src="<span class="exturl" data-url="aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTAzMTg0MS8yMDE5MDUvMTAzMTg0MS0yMDE5MDUzMTE2MzcwODE4Ni0xNzAzNjAxNDQ4LmdpZg==">https://img2018.cnblogs.com/blog/1031841/201905/1031841-20190531163708186-1703601448.gif</span>" alt="alt" style="zoom:80%;" /&gt;</p><ol><li><p>通过每一次遍历获取最大 / 最小值</p></li><li><p>将最大值 / 最小值放在尾部 / 头部</p></li><li><p>然后除开最大值 / 最小值，剩下的数据在进行遍历获取最大 / 最小值</p></li><li><p>代码实现</p><pre><code>public static void main(String[] args) {   int arr[] = {8, 5, 3, 2, 4};    //冒泡    for (int i = 0; i &lt; arr.length; i++) {        //外层循环，遍历次数        for (int j = 0; j &lt; arr.length - i - 1; j++) {            //内层循环，升序（如果前一个值比后一个值大，则交换）            //内层循环一次，获取一个最大值            if (arr[j] &gt; arr[j + 1]) {                int temp = arr[j + 1];                arr[j + 1] = arr[j];                arr[j] = temp;            }        }    }}</code></pre></li><li><p>排序过程（红色：移动的数据）</p><p>&lt;img src="D:\Program Files\blog\hexo\source\images\maopao.jpg" alt="alt" style="zoom: 80%;" /&gt;</p></li></ol><h2 id="选择排序"><a class="anchor" href="#选择排序">#</a> 选择排序</h2><p>选择排序算法的基本思路是为每一个位置选择当前最小的元素。选择排序的基本思想是，基于直接选择排序和堆排序这两种基本的简单排序方法。首先从第 1 个位置开始对全部元素进行选择，选出全部元素中最小的给该位置，再对第 2 个位置进行选择，在剩余元素中选择最小的给该位置即可；<br>&lt;img src="<span class="exturl" data-url="aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTAzMTg0MS8yMDE5MDUvMTAzMTg0MS0yMDE5MDUzMTE3MDIwNTgyMS0xOTgzNjc4NjQzLmdpZg==">https://img2018.cnblogs.com/blog/1031841/201905/1031841-20190531170205821-1983678643.gif</span>" alt="alt" style="zoom:80%;" /&gt;</p><ol><li><p>将第一个值看成最小值</p></li><li><p>然后和后续的比较找出最小值和下标</p></li><li><p>交换本次遍历的起始值和最小值</p></li><li><p>说明：每次遍历的时候，将前面找出的最小值，看成一个有序的列表，后面的看成无序的列表，然后每次遍历无序列表找出最小值。</p></li><li><p>代码实现</p><pre><code>public static void main(String[] args) {   int arr[] = {6, 5, 3, 2, 4};    //选择    for (int i = 0; i &lt; arr.length; i++) {        //默认第一个是最小的。        int min = arr[i];        //记录最小的下标        int index = i;        //通过与后面的数据进行比较得出，最小值和下标        for (int j = i + 1; j &lt; arr.length; j++) {            if (min &gt; arr[j]) {                min = arr[j];                index = j;            }        }        //然后将最小值与本次循环的，开始值交换        int temp = arr[i];        arr[i] = min;        arr[index] = temp;        //说明：将i前面的数据看成一个排好的队列，i后面的看成一个无序队列。        //每次只需要找无需的最小值，做替换    }}</code></pre></li><li><p>排序过程（红色：移动的数据）</p><p>&lt;img src="D:\Program Files\blog\hexo\source\images\xuanze.jpg" alt="alt" style="zoom:80%;" /&gt;</p></li></ol><h2 id="插入排序"><a class="anchor" href="#插入排序">#</a> 插入排序</h2><p>插入排序算法是基于某序列已经有序排列的情况下，通过一次插入一个元素的方式按照原有排序方式增加元素。<br>&lt;img src="<span class="exturl" data-url="aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTAzMTg0MS8yMDE5MDUvMTAzMTg0MS0yMDE5MDUzMTE3MDk1MzI4My0xODA2MTUzMzMxLmdpZg==">https://img2018.cnblogs.com/blog/1031841/201905/1031841-20190531170953283-1806153331.gif</span>" alt="alt" style="zoom:80%;" /&gt;</p><ol><li><p>默认从第二个数据开始比较。</p></li><li><p>如果第二个数据比第一个小，则交换。然后在用第三个数据比较，如果比前面小，则插入（狡猾）。否则，退出循环</p></li><li><p>说明：默认将第一数据看成有序列表，后面无序的列表循环每一个数据，如果比前面的数据小则插入（交换）。否则退出。</p></li><li><p>代码实现</p><pre><code>public static void main(String[] args) { int arr[] = {7, 5, 3, 2, 4};//插入排序for (int i = 1; i &lt; arr.length; i++) {    //外层循环，从第二个开始比较    for (int j = i; j &gt; 0; j--) {        //内存循环，与前面排好序的数据比较，        //如果后面的数据小于前面的则交换        if (arr[j] &lt; arr[j - 1]) {            int temp = arr[j - 1];            arr[j - 1] = arr[j];            arr[j] = temp;        } else {            //如果不小于，说明插入完毕，退出内层循环            break;        }    }}}</code></pre></li><li><p>排序过程（红色：有序，黑色：无序）</p><p>&lt;img src="D:\Program Files\blog\hexo\source\images\charu.jpg" alt="alt" style="zoom:80%;" /&gt;</p></li></ol><h2 id="快速排序"><a class="anchor" href="#快速排序">#</a> 快速排序</h2><p>快速排序的基本思想是：通过一趟排序算法把所需要排序的序列的元素分割成两大块，其中，一部分的元素都要小于或等于另外一部分的序列元素，然后仍根据该种方法对划分后的这两块序列的元素分别再次实行快速排序算法，排序实现的整个过程可以是递归的来进行调用，最终能够实现将所需排序的无序序列元素变为一个有序的序列。<br>&lt;img src="<span class="exturl" data-url="aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTAzMTg0MS8yMDE5MDUvMTAzMTg0MS0yMDE5MDUzMTE3NTcwOTUxNS0xNjk2MDI2MjkuZ2lm">https://img2018.cnblogs.com/blog/1031841/201905/1031841-20190531175709515-169602629.gif</span>" alt="alt" style="zoom:80%;" /&gt;</p><ol><li><p>确认列表第一个数据为中间值，第一个值看成空缺（低指针空缺）。</p></li><li><p>然后在剩下的队列中，看成有左右两个指针（高低）。</p></li><li><p>开始高指针向左移动，如果遇到小于中间值的数据，则将这个数据赋值到低指针空缺，并且将高指针的数据看成空缺值（高指针空缺）。然后先向右移动一下低指针，并且切换低指针移动。</p></li><li><p>当低指针移动到大于中间值的时候，赋值到高指针空缺的地方。然后先高指针向左移动，并且切换高指针移动。重复 c、d 操作。</p></li><li><p>直到高指针和低指针相等时退出，并且将中间值赋值给对应指针位置。</p></li><li><p>然后将中间值的左右两边看成行的列表，进行快速排序操作。</p></li><li><p>代码实现</p><pre><code>public static void main(String[] args) {    int arr[] = {7, 5, 3, 2, 4, 1, 8, 9, 6};    //快速排序    int low = 0;    int high = arr.length - 1;    quickSort(arr, low, high);  }public static void quickSort(int[] arr, int low, int high) {    //如果指针在同一位置(只有一个数据时)，退出    if (high - low &lt; 1) {        return;    }    //标记，从高指针开始，还是低指针（默认高指针）    boolean flag = true;    //记录指针的其实位置    int start = low;    int end = high;    //默认中间值为低指针的第一个值    int midValue = arr[low];    while (true) {        //高指针移动        if (flag) {            //如果列表右方的数据大于中间值，则向左移动            if (arr[high] &gt; midValue) {                high--;            } else if (arr[high] &lt; midValue) {                //如果小于，则覆盖最开始的低指针值，并且移动低指针，                //标志位改成从低指针开始移动                arr[low] = arr[high];                low++;                flag = false;            }        } else {            //如果低指针数据小于中间值，则低指针向右移动            if (arr[low] &lt; midValue) {                low++;            } else if (arr[low] &gt; midValue) {            //如果低指针的值大于中间值，则覆盖高指针停留时的数据，            //并向左移动高指针。切换为高指针移动                arr[high] = arr[low];                high--;                flag = true;            }        }        //当两个指针的位置相同时，则找到了中间值的位置，并退出循环        if (low == high) {            arr[low] = midValue;            break;        }    }    //然后出现有，中间值左边的小于中间值。右边的大于中间值。    //然后在对左右两边的列表在进行快速排序    quickSort(arr, start, low -1);    quickSort(arr, low + 1, end);}</code></pre></li><li><p>排序过程 (橙色：中间值，蓝色：确认位置的数据，红色：移动的数据)</p><p>&lt;img src="D:\Program Files\blog\hexo\source\images\kuaisu.jpg" alt="alt" style="zoom:80%;" /&gt;</p></li></ol><p>转载出处：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGw0MDk1NDYyOTcvcC8xMDk1Njk2MC5odG1s">https://www.cnblogs.com/ll409546297/p/10956960.html</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html标签</title>
      <link href="2020/10/30/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
      <url>2020/10/30/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="html常用标签"><a class="anchor" href="#html常用标签">#</a> html 常用标签</h1><h2 id="格式化标签"><a class="anchor" href="#格式化标签">#</a> 格式化标签</h2><p>格式标签：</p><pre><code>&lt;br /&gt;  换行&lt;p&gt;   &lt;/p&gt;  换段&lt;hr /&gt;   水平线分割列表：&lt;ul&gt;   &lt;/ul&gt;  无序列表&lt;ol&gt;   &lt;/ol&gt;  有序列表，type类型值：A a I i 1 start属性表示起始值&lt;li&gt;   &lt;/li&gt;  列表项      &lt;dl&gt;   &lt;/dl&gt;   自定义列表  &lt;dt&gt;   &lt;/dt&gt;   自定义列表头  &lt;dd&gt;   &lt;/dd&gt;   自定义列表内容    &lt;div&gt;   &lt;/div&gt;  常用于组合块级元素 </code></pre><h2 id="图像标签"><a class="anchor" href="#图像标签">#</a> 图像标签</h2><p>图像标签：</p><pre><code>&lt;img src="#" alt="加载失败" title="这是一张图片" width="200"height="200" border="0"/&gt;src: 图片路径alt: 加载失败信息title: 文字提示属性width: 宽度height: 高度border: 边框线粗细</code></pre><h2 id="超链接标签"><a class="anchor" href="#超链接标签">#</a> 超链接标签</h2><p>超链接标签:</p><pre><code>&lt;a href="#" target="_blank"&gt;&lt;/a&gt;href: 链接跳转地址target: 链接打开方式_blank 新窗口_parent 父窗口_self 本窗口（默认）_top 顶级窗口framename 窗口名title: 文字提示属性锚点链接：定义：&lt;a id="ab"&gt;&lt;/a&gt; 旧方法: &lt;a name="ab"&gt;&lt;/a&gt;使用:&lt;a href="#ab"&gt;&lt;/a&gt;</code></pre><h2 id="表格标签"><a class="anchor" href="#表格标签">#</a> 表格标签</h2><p>表格标签：</p><pre><code>&lt;table cellpadding="单元格边距" cellspacing="单元格间距"&gt;&lt;caption&gt;标题&lt;/caption&gt;&lt;th colspan="2"&gt;表头,占据两列单元格&lt;/th&gt;&lt;th rowspan="2"&gt;表头,据两行单元格&lt;/th&gt;&lt;td&gt;表格内容&lt;/td&gt;&lt;/table&gt;</code></pre><h2 id="表单标签"><a class="anchor" href="#表单标签">#</a> 表单标签</h2><p>表单标签：</p><pre><code>&lt;form action="#" method="get/post"&gt;action:提交的目标地址method: 提交方式get: URL地址可见，长度限制，不安全post: URL地址不可见，安全&lt;input type="text" name="" /&gt;input定义输入字段。type属性:text: 文本password: 密码checkbox: 多选radio: 单选file: 文件上传button: 普通按钮submit: 提交按钮image: 提交图片...&lt;select name="" size="3" disabled="false" multiple="multiple"&gt;&lt;option value="1" selected="selected"&gt; &lt;/option&gt;value: 下拉属性的值sekected: 默认下拉指定项&lt;textarea&gt;多行文本输入&lt;/textarea&gt;name: 定义名称，存储文本域中的值cols: 可见列数rows: 可见行数diabled: 是否禁用readonly: 只读&lt;/select&gt;name: 定义名称，存储下拉值size: 菜单项目的数目 disabled: 禁用菜单multiple: 多选&lt;/form&gt;</code></pre><h2 id="框架标签"><a class="anchor" href="#框架标签">#</a> 框架标签</h2><p>框架标签：</p><pre><code>&lt;iframe src="" name="" width="" height=""&gt;&lt;/iframe&gt;</code></pre><h2 id="多媒体标签"><a class="anchor" href="#多媒体标签">#</a> 多媒体标签</h2><p>音频标签：</p><pre><code>&lt;audio src="" &gt;当前浏览器不支持audio&lt;/audio&gt;</code></pre><p>视频标签：</p><pre><code>&lt;video width="800" height=""&gt;&lt;source src="myvideo.mp4" type="video/mp4"&gt;&lt;/source&gt;&lt;source src="myvideo.ogv" type="video/ogg"&gt;&lt;/source&gt;&lt;source src="myvideo.webm" type="video/webm"&gt;&lt;/source&gt;&lt;object width="" height="" type="application/x-shockwave-flash" data="myvideo.swf"&gt;&lt;param name="movie" value="myvideo.swf" /&gt;&lt;param name="flashvars" value="autostart=true&amp;amp;file=myvideo.swf" /&gt;&lt;/object&gt;当前浏览器不支持 video直接播放，点击这里下载视频： &lt;a href="myvideo.webm"&gt;下载视频&lt;/a&gt;&lt;/video&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML和JSON</title>
      <link href="2020/10/27/XML%E5%92%8CJSON/"/>
      <url>2020/10/27/XML%E5%92%8CJSON/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="xml和json"><a class="anchor" href="#xml和json">#</a> XML 和 JSON</h1><h2 id="xml"><a class="anchor" href="#xml">#</a> XML</h2><h3 id="声明"><a class="anchor" href="#声明">#</a> 声明</h3><p>&lt;?xml version="1.0"encoding="UTF-8"?&gt;</p><h3 id="概念和作用"><a class="anchor" href="#概念和作用">#</a> 概念和作用</h3><p>可扩展标记语言（eXtensible Markup Language）。<br>特性:</p><ol><li><p>xml 具有平台无关性，是一门独立的标记语言.</p></li><li><p>xml 具有自我描述性</p><p>.XML 文件是保存 XML 数据的一种方式</p></li></ol><h3 id="标记"><a class="anchor" href="#标记">#</a> 标记</h3><p>标记名称: &nbsp;<br>自定义名称，必须遵循以下命名规则：</p><ol><li><p>名称可以含字母、数字以及其他的字符</p></li><li><p>名称不能以数字或者标点符号开始</p></li><li><p>名称不能以字符 “xml”（或者 XML、Xml）开始</p></li><li><p>名称不能包含空格，不能包含冒（:）</p></li><li><p>名称区分大小写<br>例如:</p><pre><code></code></pre></li></ol><p>&lt;persons&gt;<br>&lt;person&gt;</p><pre><code>      &lt;name&gt;李四&lt;/name&gt;      &lt;length&gt;180cm&lt;/length&gt; &nbsp; &nbsp; &nbsp; &lt;/person&gt;    &lt;person&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;           、       &lt;name&gt;李四&lt;/name&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;        &lt;length&gt;200cm&lt;/length&gt; &nbsp; &nbsp; &nbsp;      &lt;/person&gt; &nbsp; &nbsp; &nbsp; &nbsp;  </code></pre><p>&lt;/persons&gt;</p><pre><code>### 标记中添加属性标记中的属性, 在标记开始时 描述, 由属性名和属性值 组成. &nbsp; &nbsp; &nbsp;  格式: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1. 在开始标记中, 描述属性. &nbsp; &nbsp; &nbsp; &nbsp; 2. 可以包含0-n个属性, 每一个属性是一个键值对! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3. 属性名不允许重复 , 键与值之间使用等号连接, 多个属性之间使用空格分割. 4. 属性值 必须被引号引住. 案例: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    ```   &lt;persons&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;             &lt;person id="10001" groupid="1"&gt; &nbsp; &nbsp;      ​                 &lt;name&gt;李四&lt;/name&gt;      ​                 &lt;age&gt;18&lt;/age&gt;       ​         &lt;/person&gt;    ​         &lt;person id="10002" groupid="1"&gt; &nbsp; &nbsp;       ​                &lt;name&gt;李四&lt;/name&gt; &nbsp; &nbsp;      ​                &lt;age&gt;20&lt;/age&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;        ​         &lt;/person&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;        &lt;/persons&gt;  ```   ### 注释格式: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     注释开始: &nbsp; &lt;!- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     注释结束: &nbsp; --&gt;## XML解析### SAX解析解析方式是事件驱动机制! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  SAX解析器, 逐行读取XML文件解析 , 每当解析到一个标签的开始/结束/内容/属性时,触发事件.优点: 1. 分析能够立即开始，而不是等待所有的数据被处理2. 逐行加载,节省内存.有助于解析大于系统内存的文档3. 有时不必解析整个文档,它可以在某个条件得到满足时停止解析.缺点: 1. 单向解析，无法定位文档层次，无法同时访问同一文档的不同部分数据(因为逐 行解析, 当解析第n行是, 第n-1行已经被释放了, 无法在进行操作了). &nbsp; &nbsp; &nbsp; &nbsp; 2. 无法得知事件发生时元素的层次, 只能自己维护节点的父/子关系. &nbsp; &nbsp; &nbsp; &nbsp; 3. 只读解析方式, 无法修改XML文档的内容.### DOM解析是用与平台和语言无关的方式表示XML文档的官方W3C标准，分析该结构通常需要加载整个文档和内存中建立文档树模型.程序员可以通过操作文档树, 来完成数据的获取 修改 删除等.优点: 1. 文档在内存中加载, 允许对数据和结构做出更改.2. 访问是双向的，可以在任何时候在树中双向解析数据。缺点:   文档全部加载在内存中 , 消耗资源大.### JDOM解析目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一 个Java特定模型，JDOM一直得到大力推广和促进。JDOM文档声明其目的是“使用20%（或更少）的精力解决80%（或更多）Java/XML问题” （根据学习曲线假定为20%）     优点: 1. 使用具体类而不是接口，简化了DOM的API。2. 大量使用了Java集合类，方便了Java开发人员。缺点:1. 没有较好的灵活性。                2. 性能不是那么优异### DOM4J解析它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath 支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项， DOM4J是一个非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一 个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML。目前许多开源项目中大量采用DOM4J , 例如:Hibernate步骤:1.  引入jar文件 dom4j.jar &nbsp;  2.  创建一个指向XML文件的输入流 &nbsp; &nbsp; &nbsp; &nbsp; FileInputStream fis = new FileInputStream("xml文件的地址"); 3.  创建一个XML读取工具对象 &nbsp; &nbsp; &nbsp; &nbsp; SAXReader sr = new SAXReader(); &nbsp; 4.  使用读取工具对象, 读取XML文档的输入流 , 并得到文档对象 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Document doc = sr.read(fis); &nbsp; &nbsp; 5.   通过文档对象, 获取XML文档中的根元素对象   &nbsp;Element root = doc.getRootElement();## JSON### 概念JSON: JavaScript Object Notation JS对象简谱 , 是一种轻量级的数据交换格式.### 对象格式</code></pre><p>js:</p><p>​var b = new Object();</p><p>​<span class="exturl" data-url="aHR0cDovL2IubmFtZQ==">b.name</span> = "金苹果";</p><p>​<span class="exturl" data-url="aHR0cDovL2IuaW5mbw==">b.info</span> = "种苹果";</p><p>XML:</p><p>​&lt;book&gt;</p><p>​ &lt;name&gt; 金苹果 &lt;/name&gt;</p><p>​&lt;info&gt; 种苹果 &lt;/info&gt;</p><p>​&lt;/book&gt;</p><p  ="" name:金苹果, info:种苹果 ="">JSON: &nbsp;     </p><pre><code> 一个对象, 由一个大括号表示. &nbsp; &nbsp; &nbsp;  括号中 描述对象的属性 .  通过键值对来描述对象的属性(可以理解为, 大括号中, 包含的是一个个的键值对.) &nbsp; &nbsp; &nbsp;  格式:             1. 键与值之间使用冒号连接, 多个键值对之间使用逗号分隔.             2. 键值对的键 应使用引号引住 (通常Java解析时, 键不使用引号会报错. 而JS能正确解 析.)             3. 键值对的值, 可以是JS中的任意类型的数据### GSON- 将对象转换为JSON字符串转换JSON字符串的步骤: &nbsp; 1. 引入JAR包 &nbsp; &nbsp;2. 在需要转换JSON字符串的位置编写如下代码即可: &nbsp; &nbsp; &nbsp; &nbsp;String json = new Gson().toJSON(要转换的对象);      案例: &nbsp;         Book b = BookDao.find();          String json = new Gson().toJson(b); &nbsp;       &nbsp;System.out.println(json);- 将JSON字符串转换为对象1. &nbsp;引入JAR包 &nbsp; &nbsp;2. &nbsp;在需要转换Java对象的位置, 编写如下代码: &nbsp; &nbsp; &nbsp; 对象 = new Gson().fromJson(JSON字符串,对象类型.class);案例: &nbsp; &nbsp;​      String json = "{\"id\":1,\"name\":\"金苹果\",\"author\":\"李伟杰 \",\"info\":\"嘿嘿嘿嘿嘿嘿\",\"price\":198.0}"; &nbsp; &nbsp;​      Book book = new Gson().fromJson(json, Book.class); &nbsp; &nbsp;​      System.out.println(book);### FastJson- 将对象转换为JSON字符串转换JSON字符串的步骤: &nbsp; &nbsp;1. 引入JAR包 &nbsp; &nbsp;2. &nbsp;在需要转换JSON字符串的位置编写如下代码即可: &nbsp; &nbsp; &nbsp; &nbsp;String json=JSON.toJSONString(要转换的对象); &nbsp; &nbsp; &nbsp; &nbsp;    案例: &nbsp;         Book b = BookDao.find(); &nbsp; &nbsp;​        String json=JSON.toJSONString(b); &nbsp; &nbsp;​        System.out.println(json);- 将JSON字符串转换为对象1. &nbsp;引入JAR包 &nbsp; 2. &nbsp;在需要转换Java对象的位置, 编写如下代码: &nbsp; &nbsp; &nbsp;     类型 对象名=JSON.parseObject(JSON字符串, 类型.class);                或 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List&lt;类型&gt; list=JSON.parseArray(JSON字符串,类型.class);    案例: &nbsp; &nbsp;​         String json = "{\"id\":1,\"name\":\"金苹果\",\"author\":\"李伟杰 \",\"info\":\"嘿嘿嘿嘿嘿嘿\",\"price\":198.0}"; &nbsp; &nbsp;​         Book book = JSON.parseObject(json, Book.class); &nbsp; &nbsp;System.out.println(book);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java核心类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML，JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="2020/10/13/SpringBoot/"/>
      <url>2020/10/13/SpringBoot/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="springboot"><a class="anchor" href="#springboot">#</a> SpringBoot</h1><h2 id="概念"><a class="anchor" href="#概念">#</a> 概念</h2><h3 id="什么是springboot"><a class="anchor" href="#什么是springboot">#</a> 什么是 SpringBoot</h3><p>spring boot 为 spring 服务，用来简化新 spring 应用的初始搭建以及开发过程</p><h3 id="优点"><a class="anchor" href="#优点">#</a> 优点</h3><ol><li><p>减少开发，测试时间和努力。</p></li><li><p>使用 JavaConfig 有助于避免使用 XML。</p></li><li><p>避免大量的 Maven 导入和各种版本冲突。</p></li><li><p>提供意见发展方法。</p></li><li><p>通过提供默认值快速开始开发。</p></li><li><p>没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish 或其他任何东西。</p></li><li><p>需要更少的配置 因为没有 web.xml 文件。只需添加用 @ Configuration 注释的类，然后添加用 @Bean 注释的方法，Spring 将自动加载对象并像以前一样对其进行管理。您甚至可以将 @Autowired 添加到 bean 方法中，以使 Spring 自动装入需要的依赖关系中。</p></li><li><p>基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active = {enviornment}。在加载主应用程序属性文件后，Spring 将在（application {environment} .properties）中加载后续的应用程序属性文件。</p></li></ol><h2 id="常见问题"><a class="anchor" href="#常见问题">#</a> 常见问题</h2><h3 id="springboot核心配置文件"><a class="anchor" href="#springboot核心配置文件">#</a> SpringBoot 核心配置文件</h3><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="2020/10/13/JavaWeb/"/>
      <url>2020/10/13/JavaWeb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="javaweb"><a class="anchor" href="#javaweb">#</a> JavaWeb</h1><h3 id="说下原生jdbc操作数据库流程"><a class="anchor" href="#说下原生jdbc操作数据库流程">#</a> 说下原生 jdbc 操作数据库流程？</h3><ul><li>第一步：Class.forName () 加载数据库连接驱动；</li><li>第二步：DriverManager.getConnection () 获取数据连接对象；</li><li>第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;</li><li>第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX ();</li><li>第五步：关闭结果集、关闭会话、关闭连接。<br>详细代码请看（封装）：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjk1NDI2MTEvYXJ0aWNsZS9kZXRhaWxzLzUyNDI2MDA2">http://blog.csdn.net/qq_29542611/article/details/52426006</span></li></ul><h3 id="session-和-cookie-有什么区别"><a class="anchor" href="#session-和-cookie-有什么区别">#</a> session 和 cookie 有什么区别？</h3><ul><li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li><li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li><li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li><li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li></ul><h3 id="简述-tcp-和-udp的区别"><a class="anchor" href="#简述-tcp-和-udp的区别">#</a> 简述 tcp 和 udp 的区别？</h3><p><strong>tcp</strong> 和 <strong>udp</strong> 是 OSI 模型中的运输层中的协议。</p><p><strong>tcp</strong> 提供可靠的通信传输    <strong>udp</strong> 则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><ul><li>tcp <strong>面向连接</strong>，udp <strong>面向非连接</strong>即发送数据前不需要建立链接；</li><li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li><li>tcp 面向字节流，udp 面向报文；</li><li>tcp 数据传输慢，udp 数据传输快；</li></ul><h3 id="tcp三次握手"><a class="anchor" href="#tcp三次握手">#</a> tcp 三次握手</h3><p>第一次</p><p>第一次握手：建立连接时，客户端  发送<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4="> syn</span> 包（seq=j）到  服务器，并进入 SYN_SENT 状态，等待  服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 [3]</p><p>第二次</p><p>第二次握手：服务器  收到<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4="> syn</span> 包，必须确认  客户端  的 SYN（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=">ack</span>=j+1），同时自己也发送一个 SYN 包（seq=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。 [3]</p><p>第三次</p><p>第三次握手：客户端  收到  服务器  的 SYN+ACK 包，向  服务器  发送确认包 ACK (<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=">ack</span>=k+1），此包发送完毕，客户端和服务器进入<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9FU1RBQkxJU0hFRA=="> ESTABLISHED</span>（TCP 连接成功）状态，完成三次握手。</p><h3 id="为什么要三次握手两次不行吗为什么"><a class="anchor" href="#为什么要三次握手两次不行吗为什么">#</a> 为什么要三次握手，两次不行吗？为什么？</h3><p>如果采用两次握手，那么只要<strong>服务器</strong>发出确认数据包就会建立连接，但由于<strong>客户端</strong>此时并未响应服务器端的请求，那此时<strong>服务器端</strong>就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。</p><p>若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="2020/10/13/MySQL/"/>
      <url>2020/10/13/MySQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql"><a class="anchor" href="#mysql">#</a> MySQL</h1><h2 id="基础"><a class="anchor" href="#基础">#</a> 基础</h2><h3 id="数据库的三范式是什么"><a class="anchor" href="#数据库的三范式是什么">#</a> 数据库的三范式是什么？</h3><ul><li>第一范式：强调的是原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h3 id="mysql-的内连接-左连接-右连接有什么区别"><a class="anchor" href="#mysql-的内连接-左连接-右连接有什么区别">#</a> MySQL 的内连接、左连接、右连接有什么区别？</h3><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数 据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h3 id="数据库基本操作语句"><a class="anchor" href="#数据库基本操作语句">#</a> 数据库基本操作语句</h3><p>主键约束 (primary key)  唯一约束 (unique) 非空约束 (not null) 外键约束 (foreign key)</p><p><strong>select</strong> ... from 表名  where 条件  group by  分组字段  having 条件  order by  排序字段 ase|desc</p><p>去重操作<strong> distinct</strong>             select distinct 字段名，字段名 2 from 表名</p><p><strong>insert  into  &lt;表名&gt;  [列名]  values  &lt; 列值 &gt;                delete  from  &lt; 表名 &gt;  where  &lt; 删除条件 &gt;</strong>**</p><p><strong>update 表名 set  字段名 = 字段值，字段名 = 字段值   [where 修改条件];</strong></p><h2 id="数据库特性"><a class="anchor" href="#数据库特性">#</a> 数据库特性</h2><h3 id="数据库4个特性"><a class="anchor" href="#数据库4个特性">#</a> 数据库 4 个特性：</h3><ul><li>Atomicity（<strong>原子性</strong>）：事务不可分割、不可约简。</li><li>Consistency（<strong>一致性</strong>）：在事务开始前和事务结束后，<strong>数据库的完整性</strong>没有被破坏。</li><li>Isolation（<strong>隔离性</strong>）：数据库允许多个事务同时对数据处理，隔离性可以<strong>防止</strong>多个事务并发执行时由于交叉执行而<strong>导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（<strong>持久性</strong>）：事务处理结束后，对数据的修改就是永久，不会丢失。</li></ul><h2 id="事务隔离"><a class="anchor" href="#事务隔离">#</a> 事务隔离</h2><h3 id="数据库的事务隔离"><a class="anchor" href="#数据库的事务隔离">#</a> 数据库的事务隔离：</h3><ul><li><p>READ-UNCOMMITTED：<strong>未提交读</strong>，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p></li><li><p>READ-COMMITTED：<strong>提交读</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p></li><li><p>REPEATABLE-READ：<strong>可重复读</strong>，<strong>默认</strong>级别，保证多次读取同一个数据，值和内容一致。禁止读取到别的事务未提交的数据（会造成幻读）。</p></li><li><p>SERIALIZABLE：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。<strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p></li></ul><h2 id="分页查询"><a class="anchor" href="#分页查询">#</a> 分页查询</h2><h3 id="oracle页查询"><a class="anchor" href="#oracle页查询">#</a> <strong>Oracle 页查询</strong></h3><p>Oracle 中使用 rownum 来进行分页，</p><p>select * from    ( select rownum r,a from tabName where rownum &lt;= 20 )  where r &gt; 10</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="2020/10/13/MyBatis/"/>
      <url>2020/10/13/MyBatis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mybatis"><a class="anchor" href="#mybatis">#</a> MyBatis</h1><h2 id="概念"><a class="anchor" href="#概念">#</a> 概念</h2><h3 id="什么是mybatis"><a class="anchor" href="#什么是mybatis">#</a> 什么是 MyBatis</h3><p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</p><h3 id="mybatis优点"><a class="anchor" href="#mybatis优点">#</a> MyBatis 优点</h3><ol><li>基于 SQL 语句，灵活</li><li>降低代码量</li><li>与数据库兼容</li><li>与 Spring 集成</li></ol><h2 id="基础"><a class="anchor" href="#基础">#</a> 基础</h2><h3 id="mybatis缓存"><a class="anchor" href="#mybatis缓存">#</a> MyBatis 缓存</h3><p>MyBatis 的缓存分为一级缓存和二级存，一级缓存放在 session 里面，默认就有，二级缓 存放在它的命名空间里，默认是不打开的，使用二级缓存属性类需要实现 Serializable 序列化 接口 (可用来保存对象的状态), 可在它的映射文件中配置 &lt; cache/&gt;</p><h3 id="mybatis分页"><a class="anchor" href="#mybatis分页">#</a> MyBatis 分页</h3><ul><li><p>分页方式：Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。</p></li><li><p>分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦 截待执行的 sql，然后重写 sql</p></li></ul><h3 id="和的区别是什么"><a class="anchor" href="#和的区别是什么">#</a> #{} 和 ${} 的区别是什么？</h3><ol><li><p>#{} 是预编译处理，${} 是字符串替换。</p></li><li><p>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为？号，调用 PreparedStatement 的 set 方法 来赋值；</p></li><li><p>Mybatis 在处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow></mrow><mtext>时，就是把</mtext></mrow><annotation encoding="application/x-tex">{}时，就是把</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">把</span></span></span></span> {} 替换成变量的值。</p></li><li><p>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性</p></li></ol><h3 id="mybatis编程步骤"><a class="anchor" href="#mybatis编程步骤">#</a> Mybatis 编程步骤</h3><ol><li>创建 SqlSessionFactory</li><li>通过 SqlSessionFactory 创建 SqlSession</li><li>通过 sqlsession 执行数据库操作</li><li>调用 session.commit () 提交事务</li><li>调用 session.close () 关闭会话</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2020/10/13/Spring/"/>
      <url>2020/10/13/Spring/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="spring"><a class="anchor" href="#spring">#</a> Spring</h1><h2 id="概念"><a class="anchor" href="#概念">#</a> 概念</h2><h3 id="什么是spring"><a class="anchor" href="#什么是spring">#</a> 什么是 Spring</h3><p>Spring 是个 java 企业级应用的开源开发框架。Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</p><h2 id="aop"><a class="anchor" href="#aop">#</a> AOP</h2><h3 id="什么是aop"><a class="anchor" href="#什么是aop">#</a> 什么是 AOP</h3><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><h2 id="ioc"><a class="anchor" href="#ioc">#</a> IOC</h2><h3 id="什么是ioc"><a class="anchor" href="#什么是ioc">#</a> 什么是 IOC</h3><ul><li>IOC 容器负责实例化、配置程序中的对象及建立对象间的依赖。"控制反转" 是指 new 实例工作交给 Spring 容器来做。</li><li>所谓 IoC (控制反转)，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</li></ul><h3 id="ioc优点"><a class="anchor" href="#ioc优点">#</a> IOC 优点</h3><ol><li>降低代码量</li><li>易于测试</li><li>轻松实现耦合</li><li>支持饿汉式初始化和懒加载</li></ol><h2 id="依赖"><a class="anchor" href="#依赖">#</a> 依赖</h2><h3 id="什么是依赖注入"><a class="anchor" href="#什么是依赖注入">#</a> 什么是依赖注入</h3><p>spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。</p><h3 id="依赖注入方式"><a class="anchor" href="#依赖注入方式">#</a> 依赖注入方式</h3><ul><li>setter 属性注入</li><li>构造方法注入</li><li>接口注入</li></ul><h2 id="特性"><a class="anchor" href="#特性">#</a> 特性</h2><h3 id="spring优点"><a class="anchor" href="#spring优点">#</a> Spring 优点</h3><ol><li><p>方便解耦 ——Spring 提供的 IoC 容器实现了对象依赖关系的管理，避免了硬编码导致的耦合。</p></li><li><p>支持 AOP——Spring 提供的 AOP 功能，方便进行面向切面编程。</p></li><li><p>集成了多种优秀框架 ——Spring 提供了对各种优秀框架（如 Struts、Hibernate、Hessian、Quartz 等）的直接支持。</p></li><li><p>降低对 API 依赖</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="2020/10/13/SpringMVC/"/>
      <url>2020/10/13/SpringMVC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="springmvc"><a class="anchor" href="#springmvc">#</a> SpringMVC</h1><h2 id="概念"><a class="anchor" href="#概念">#</a> 概念</h2><h3 id="什么是springmvc"><a class="anchor" href="#什么是springmvc">#</a> 什么是 SpringMVC</h3><p>SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。 简化开发，减少出错。</p><h2 id="特性"><a class="anchor" href="#特性">#</a> 特性</h2><h3 id="springmvc的优点"><a class="anchor" href="#springmvc的优点">#</a> SpringMVC 的优点</h3><ol><li><p>它是基于组件技术的。全部的应用对象，无论控制器和视图，还是业务对象之类的都是 java 组件。并且和 Spring 提供的其他基础结构紧密集成.</p></li><li><p>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的)</p></li><li><p>可以任意使用各种视图技术，而不仅仅局限于 JSP</p></li><li><p>支持各种请求资源的映射策略</p></li><li><p>它应是易于扩展的</p></li></ol><h2 id="工作原理"><a class="anchor" href="#工作原理">#</a> 工作原理</h2><h3 id="springmvc的工作原理"><a class="anchor" href="#springmvc的工作原理">#</a> SpringMVC 的工作原理</h3><ol><li><p>客户端发送请求 DispatcherServlet</p></li><li><p>DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller</p></li><li><p>Controller 调用业务逻辑后，返回 ModelAndView</p></li><li><p>DispatcherServlet 查询 ModelAndView，找到指定视图</p></li><li><p>视图将结果返回到客户端</p></li></ol><h3 id="springmvc常用注解"><a class="anchor" href="#springmvc常用注解">#</a> SpringMVC 常用注解</h3><ol><li><p>@requestMapping 用于请求 url 映射。</p></li><li><p>@RequestBody 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。</p></li><li><p>@ResponseBody 注解实现将 controller 方法返回对象转化为 json 响应给客户。</p></li></ol><h2 id="常见问题"><a class="anchor" href="#常见问题">#</a> 常见问题</h2><h3 id="如何解决getpost乱码"><a class="anchor" href="#如何解决getpost乱码">#</a> 如何解决 get/post 乱码</h3><ul><li>解决 post 请求乱码：我们可以在 web.xml 里边配置一个 CharacterEncodingFilter 过滤器。 设置为 utf-8，解决 get 请求的乱码：有两种方法。</li><li>get 请求中文参数出现乱码解决方法有两个:</li></ul><ol><li><p>修改 tomcat 配置文件添加编码与工程编码一致。</p></li><li><p>另 外 一 种 方 法 对 参 数 进 行 重 新 编 码 String userName = New String (Request.getParameter (“userName”).getBytes (“ISO8859-1”), “utf-8”);</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java基础语法"><a class="anchor" href="#java基础语法">#</a> JAVA 基础语法</h1><h2 id="基础语法"><a class="anchor" href="#基础语法">#</a> 基础语法</h2><h3 id="运算符"><a class="anchor" href="#运算符">#</a> 运算符</h3><p>算数运算符、关系运算符、赋值运算符、逻辑运算符、三目运算符</p><h3 id="数据类型"><a class="anchor" href="#数据类型">#</a> 数据类型</h3><h4 id="基本数据类型"><a class="anchor" href="#基本数据类型">#</a> 基本数据类型</h4><ul><li>byte、short、int、long</li><li>float、double、char</li><li>boolean</li></ul><h4 id="引用数据类型"><a class="anchor" href="#引用数据类型">#</a> 引用数据类型</h4><ul><li>class</li><li>interface</li><li>数组</li></ul><h2 id="流程控制"><a class="anchor" href="#流程控制">#</a> 流程控制</h2><h3 id="if"><a class="anchor" href="#if">#</a> if</h3><p>if 条件结构是根据条件判断之后再做处理</p><h3 id="switch"><a class="anchor" href="#switch">#</a> switch</h3><ul><li><p>switch (表达式){</p><p>case 取值 1: 语句块 1;break;<br>case 取值 n: 语句块 n;break; <br>default: 语句块 n+1;break;<br>}</p></li><li><p>switch 语句有关规则 表达式的返回值必须是下述几种类型之一：int,byte,char,short,String；</p></li><li><p>case 子句中的取值必须是常量，且所有 case 子句中的取值应是不同的；</p></li></ul><h3 id="while"><a class="anchor" href="#while">#</a> while</h3><ul><li>while 循环<br>符合条件，循环继续执行；否则，循环退出<br>特点：先判断，再执行</li><li>do-while 循环<br>先执行一遍循环操作，符合条件，循环继续执行；否则，循环退出<br>特点：先执行，再判断</li></ul><h3 id="for"><a class="anchor" href="#for">#</a> for</h3><p>语法：<br>for (初始化参数；判断条件；更新循环变量){<br>循环体；<br>}</p><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><h3 id="冒泡排序"><a class="anchor" href="#冒泡排序">#</a> 冒泡排序</h3><p>原理：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的</li></ul><h3 id="二分查找"><a class="anchor" href="#二分查找">#</a> 二分查找</h3><p>二分查找也叫折半查找，是一种基本的查找算法，需要待查的表满足两个条件：</p><ol><li><p>查找表必须使用顺序的存储结构</p></li><li><p>查找表必须按关键字大小有序排列</p></li></ol><p>算法的基本思想是：</p><ul><li><p>将查找表中间位置数据元素的关键字与给定关键字比较，如果相等则查找成功；</p></li><li><p>否则利用中间元素将表一分为二，如果中间关键字大于给定关键字，则在前一子表中进行折半查找，否则在后一子表中进行折半查找。</p></li><li><p>重复以上过程直到找到满足条件的元素，则查找成功；或直到子表为空为止，此时查找不成功。</p></li></ul><p>二分查找递归写法：</p><pre><code>public int firstOccurrence (int [] nums,int target){    int low = 0,high = nums.length - 1;    while(low &lt;=  high){           int mid = low + (high-low)/2;        if(nums[mid] == target){            return mid;        }        if(nums[mid] &lt; target){            low = mid+1;        }else {            high = mid-1;        }    }    return -1;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面向对象"><a class="anchor" href="#面向对象">#</a> 面向对象</h1><h2 id="基础"><a class="anchor" href="#基础">#</a> 基础</h2><h3 id="类与对象"><a class="anchor" href="#类与对象">#</a> 类与对象</h3><ul><li>对象：对象是类的实例</li><li>类：类是一个模板，描述一类对象的行为和状态</li></ul><h3 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h3><ul><li>用于对象初始化。</li><li>构造方法的名称必须与类同名，一个类可以有多个构造方法。</li></ul><h3 id="方法重载方法重写"><a class="anchor" href="#方法重载方法重写">#</a> 方法重载 / 方法重写</h3><ul><li>重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。子类可以根据需要，定义特定于自己的行为。</li><li>重载：重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li></ul><h2 id="高级"><a class="anchor" href="#高级">#</a> 高级</h2><h3 id="final关键字"><a class="anchor" href="#final关键字">#</a> final 关键字</h3><ol><li><p>final 修饰的类叫最终类，该类不能被继承。</p></li><li><p>final 修饰的方法不能被重写。</p></li><li><p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改</p></li></ol><h3 id="抽象类"><a class="anchor" href="#抽象类">#</a> 抽象类</h3><ol><li><p>抽象类不能被实例化</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h3 id="接口"><a class="anchor" href="#接口">#</a> 接口</h3><p>接口是抽象方法的集合<br>定义格式：<br>interface 接口名称 { &nbsp; &nbsp; &nbsp;<br>全局常量；&nbsp; &nbsp; &nbsp;<br>抽象方法；&nbsp;<br>}<br> 接口和抽象类的区别：</p><ol><li><p>抽象类要被子类继承，接口要被类实现。</p></li><li><p>接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。</p></li><li><p>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p></li><li><p>抽象类使用继承来使用，无法多继承。接口使用实现来使用，可以多实现</p></li><li><p>抽象类中可以包含 static 方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明 静态方法）</p></li><li><p>接口不能有构造方法，但是抽象类可以有</p></li></ol><h3 id="equals"><a class="anchor" href="#equals">#</a> equals</h3><h3 id="内部类"><a class="anchor" href="#内部类">#</a> 内部类</h3><h4 id="成员内部类"><a class="anchor" href="#成员内部类">#</a> 成员内部类</h4><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><pre><code>class Outer { &nbsp; &nbsp;private double x = 0; &nbsp; &nbsp;public Outer(double x) { this.x = x;     } &nbsp; &nbsp;  &nbsp; &nbsp;class Inner { &nbsp; //内部类 &nbsp; &nbsp; &nbsp;public void say() {    System.out.println("x="+x);&nbsp;      } &nbsp;} }</code></pre><p>特点： 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。</p><h4 id="局部内部类"><a class="anchor" href="#局部内部类">#</a> 局部内部类</h4><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限 于方法内或者该作用域内。<br>例如：</p><pre><code>class Person{ &nbsp;  public Person() {}      }&nbsp;      class Man{ &nbsp; &nbsp; &nbsp;      public Man(){ &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;public People getPerson(){                 class Student extends People{                  //局部内部类          int age =0; &nbsp;         } &nbsp;              return new Student(); &nbsp;           }       }</code></pre><h4 id="匿名内部类"><a class="anchor" href="#匿名内部类">#</a> 匿名内部类</h4><p>new 父类构造器（参数列表）| 实现接口（） { &nbsp; &nbsp; &nbsp;<br>// 匿名内部类的类体部分<br>}</p><h4 id="静态内部类"><a class="anchor" href="#静态内部类">#</a> 静态内部类</h4><p>静态内部类是不需要依赖于外部类对象的，并且它不能使用外部类的非 static 成员变量或者方法.<br> 格式：</p><pre><code>public class Test { &nbsp; public static void main(String[] args)  { &nbsp; &nbsp; &nbsp; Outter.Inner inner = new Outter.Inner(); &nbsp; } } class Outter { &nbsp; &nbsp;public Outter() { &nbsp;  } &nbsp; &nbsp;  &nbsp; &nbsp;static class Inner { &nbsp; &nbsp; &nbsp; &nbsp;public Inner() { &nbsp; &nbsp; &nbsp;     } &nbsp; } }</code></pre><h2 id="进阶"><a class="anchor" href="#进阶">#</a> 进阶</h2><h3 id="封装"><a class="anchor" href="#封装">#</a> 封装</h3><p>private 修饰变量<br> Getter/Setter</p><h3 id="this"><a class="anchor" href="#this">#</a> this</h3><p>使用 this 关键字可以完成以下的操作：</p><ul><li>调用类中的属性</li><li>调用类中的方法或构造方法</li><li>表示当前对象</li></ul><h3 id="static"><a class="anchor" href="#static">#</a> static</h3><p>static 表示 “静态” 的意思，可以用来修饰成员变量和成员方法<br>重点：</p><ol><li><p>静态成员 在类加载时加载并初始化。</p></li><li><p>无论一个类存在多少个对象，静态的属性，永远在内存中只有一份</p></li><li><p>在访问时： 静态不能访问非静态，非静态可以访问静态！</p></li></ol><h2 id="异常处理"><a class="anchor" href="#异常处理">#</a> 异常处理</h2><h3 id="try-catch"><a class="anchor" href="#try-catch">#</a> try&nbsp; catch</h3><ul><li>异常指的是 Exception，Exception 类，在 Java 中存在一个父 Throwable（可能的抛出）</li><li>Throwable 存在两个子类：<ol><li>Error：表示的是错误，是 JVM 发出的错误操作，只能尽量避免，无法用代码处理。</li><li>Exception：一般表示所有程序中的错误，所以一般在程序中将进行 try…catch 的处理。</li></ol></li></ul><h3 id="throwthrows"><a class="anchor" href="#throwthrows">#</a> throw/throws</h3><ul><li>throws 关键字：<br>此关键字主要在方法的声明上使 用，表示方法中不处理异常，而交给调用处处理。<br>格式：<br>返回值 方法名称 () throws Exception {<br>}</li><li>throw 关键字<br> throw 关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出 的就是一个异常类的实例化对象，那么此对象也可以由 throw 直接抛出。<br>代码： throw new Exception ("抛着玩的。") ;</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
