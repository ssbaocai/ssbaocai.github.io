<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL基础</title>
      <link href="2020/09/30/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>2020/09/30/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目录"><a class="markdownIt-Anchor" href="#目录">#</a> 目录</h1><ol><li><p>数据库的基本概念</p></li><li><p>MySQL 数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a class="markdownIt-Anchor" href="#数据库的基本概念">#</a> 数据库的基本概念</h2><ol><li><p>数据库的英文单词： DataBase 简称 ： DB</p></li><li><p>什么数据库？</p><ul><li>用于存储和管理数据的仓库。</li></ul></li><li><p>数据库的特点：</p><ol><li>持久化存储数据的。其实数据库就是一个文件系统</li><li>方便存储和管理数据</li><li>使用了统一的方式操作数据库 – SQL</li></ol></li></ol><p>​<br>4. 常见的数据库软件<br> * 参见《MySQL 基础.pdf》</p><h2 id="mysql数据库软件"><a class="markdownIt-Anchor" href="#mysql数据库软件">#</a> MySQL 数据库软件</h2><ol><li><p>安装</p><ul><li>参见《MySQL 基础.pdf》</li></ul></li><li><p>卸载</p><ol><li>去 mysql 的安装目录找到 my.ini 文件<ul><li>复制 datadir=“C:/ProgramData/MySQL/MySQL Server 5.5/Data/”</li></ul></li><li>卸载 MySQL</li><li>删除 C:/ProgramData 目录下的 MySQL 文件夹。</li></ol></li><li><p>配置</p><ul><li><p>MySQL 服务启动</p><ol><li>手动。</li><li>cmd–&gt; services.msc 打开服务的窗口</li><li>使用管理员打开 cmd<ul><li>net start mysql : 启动 mysql 的服务</li><li>net stop mysql: 关闭 mysql 服务</li></ul></li></ol></li><li><p>MySQL 登录</p><ol><li>mysql -uroot -p 密码</li><li>mysql -hip -uroot -p 连接目标的密码</li><li>mysql --host=ip --user=root --password = 连接目标的密码</li></ol></li><li><p>MySQL 退出</p><ol><li>exit</li><li>quit</li></ol></li><li><p>MySQL 目录结构</p><ol><li>MySQL 安装目录：basedir=“D:/develop/MySQL/”<ul><li>配置文件 my.ini</li></ul></li><li>MySQL 数据目录：datadir=“C:/ProgramData/MySQL/MySQL Server 5.5/Data/”<ul><li>几个概念<ul><li>数据库：文件夹</li><li>表：文件</li><li>数据：数据</li></ul></li></ul></li></ol></li></ul></li></ol><h2 id="sql"><a class="markdownIt-Anchor" href="#sql">#</a> SQL</h2><p>1. 什么是 SQL？<br>Structured Query Language：结构化查询语言<br>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为 “方言”。</p><p>2.SQL 通用语法</p><ol><li><p>SQL 语句可以单行或多行书写，以分号结尾。</p></li><li><p>可使用空格和缩进来增强语句的可读性。</p></li><li><p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p></li><li><p>3 种注释</p><ul><li>单行注释: – 注释内容 或 # 注释内容 (mysql 特有)</li><li>多行注释: /* 注释 */</li></ul></li><li><p>SQL 分类</p><ol><li>DDL (Data Definition Language) 数据定义语言<br>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等</li><li>DML (Data Manipulation Language) 数据操作语言<br>用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</li><li>DQL (Data Query Language) 数据查询语言<br>用来查询数据库中表的记录 (数据)。关键字：select, where 等</li><li>DCL (Data Control Language) 数据控制语言 (了解)<br> 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</li></ol></li></ol><h2 id="ddl操作数据库-表"><a class="markdownIt-Anchor" href="#ddl操作数据库-表">#</a> DDL: 操作数据库、表</h2><ol><li><p>操作数据库：CRUD</p><ol><li>C (Create): 创建<ul><li><p>创建数据库：</p><ul><li>create database 数据库名称；</li></ul></li><li><p>创建数据库，判断不存在，再创建：</p><ul><li>create database if not exists 数据库名称；</li></ul></li><li><p>创建数据库，并指定字符集</p><ul><li>create database 数据库名称 character set 字符集名；</li></ul></li><li><p>练习： 创建 db4 数据库，判断是否存在，并制定字符集为 gbk</p><ul><li>create database if not exists db4 character set gbk;</li></ul></li></ul></li><li>R (Retrieve)：查询<ul><li>查询所有数据库的名称:<ul><li>show databases;</li></ul></li><li>查询某个数据库的字符集：查询某个数据库的创建语句<ul><li>show create database 数据库名称；</li></ul></li></ul></li><li>U (Update): 修改<ul><li>修改数据库的字符集<ul><li>alter database 数据库名称 character set 字符集名称；</li></ul></li></ul></li><li>D (Delete): 删除<ul><li>删除数据库<ul><li>drop database 数据库名称；</li></ul></li><li>判断数据库存在，存在再删除<ul><li>drop database if exists 数据库名称；</li></ul></li></ul></li><li>使用数据库<ul><li>查询当前正在使用的数据库名称<ul><li>select database();</li></ul></li><li>使用数据库<ul><li>use 数据库名称；</li></ul></li></ul></li></ol></li><li><p>操作表</p><ol><li><p>C (Create): 创建</p><ol><li>语法：<br>create table 表名 (<br>列名 1 数据类型 1,<br> 列名 2 数据类型 2,<br>…<br> 列名 n 数据类型 n<br>);<ul><li>注意：最后一列，不需要加逗号（,）</li><li>数据库类型：<ol><li><p>int：整数类型</p><ul><li>age int,</li></ul></li><li><p>double: 小数类型</p><ul><li>score double(5,2)</li></ul></li><li><p>date: 日期，只包含年月日，yyyy-MM-dd</p></li><li><p>datetime: 日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss</p></li><li><p>timestamp: 时间错类型包含年月日时分秒 yyyy-MM-dd HH:mm:ss</p><ul><li>如果将来不给这个字段赋值，或赋值为 null，则默认使用当前的系统时间，来自动赋值</li></ul></li><li><p>varchar：字符串</p><ul><li>name varchar (20): 姓名最大 20 个字符</li><li>zhangsan 8 个字符  张三 2 个字符</li></ul></li></ol></li></ul></li></ol><ul><li>创建表<br> create table student (<br>id int,<br>name varchar(32),<br>age int ,<br>score double(4,1),<br>birthday date,<br>insert_time timestamp<br>);</li><li>复制表：<ul><li>create table 表名 like 被复制的表名；</li></ul></li></ul></li><li><p>R (Retrieve)：查询</p><ul><li>查询某个数据库中所有的表名称<ul><li>show tables;</li></ul></li><li>查询表结构<ul><li>desc 表名；</li></ul></li></ul></li><li><p>U (Update): 修改</p><ol><li>修改表名<br> alter table 表名 rename to 新的表名；</li><li>修改表的字符集<br> alter table 表名 character set 字符集名称；</li><li>添加一列<br> alter table 表名 add 列名 数据类型；</li><li>修改列名称 类型<br> alter table 表名 change 列名 新列别 新数据类型；<br>alter table 表名 modify 列名 新数据类型；</li><li>删除列<br> alter table 表名 drop 列名；</li></ol></li><li><p>D (Delete): 删除</p><ul><li>drop table 表名；</li><li>drop table  if exists 表名；</li></ul></li></ol></li></ol><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="dml增删改表中数据"><a class="markdownIt-Anchor" href="#dml增删改表中数据">#</a> DML：增删改表中数据</h2><ol><li>添加数据：<ul><li>语法：<ul><li>insert into 表名 (列名 1, 列名 2,… 列名 n) values (值 1, 值 2,… 值 n);</li></ul></li><li>注意：<ol><li>列名和值要一一对应。</li><li>如果表名后，不定义列名，则默认给所有列添加值<br> insert into 表名 values (值 1, 值 2,… 值 n);</li><li>除了数字类型，其他类型需要使用引号 (单双都可以) 引起来</li></ol></li></ul></li><li>删除数据：<ul><li>语法：<ul><li>delete from 表名 [where 条件]</li></ul></li><li>注意：<ol><li>如果不加条件，则删除表中所有记录。</li><li>如果要删除所有记录<ol><li>delete from 表名；– 不推荐使用。有多少条记录就会执行多少次删除操作</li><li>TRUNCATE TABLE 表名；– 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</li></ol></li></ol></li></ul></li><li>修改数据：<ul><li><p>语法：</p><ul><li>update 表名 set 列名 1 = 值 1, 列名 2 = 值 2,… [where 条件];</li></ul></li><li><p>注意：</p><ol><li>如果不加任何条件，则会将表中所有记录全部修改。</li></ol></li></ul></li></ol><h2 id="dql查询表中的记录"><a class="markdownIt-Anchor" href="#dql查询表中的记录">#</a> DQL：查询表中的记录</h2><ul><li>select * from 表名；</li></ul><ol><li><p>语法：<br>select<br> 字段列表<br> from<br> 表名列表<br> where<br> 条件列表<br> group by<br> 分组字段<br> having<br> 分组之后的条件<br> order by<br> 排序<br> limit<br> 分页限定</p></li><li><p>基础查询</p><ol><li>多个字段的查询<br> select 字段名 1，字段名 2… from 表名；<ul><li>注意：<ul><li>如果查询所有字段，则可以使用 * 来替代字段列表。</li></ul></li></ul></li><li>去除重复：<ul><li>distinct</li></ul></li><li>计算列<ul><li>一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</li><li>ifnull (表达式 1, 表达式 2)：null 参与的运算，计算结果都为 null<ul><li>表达式 1：哪个字段需要判断是否为 null</li><li>如果该字段为 null 后的替换值。</li></ul></li></ul></li><li>起别名：<ul><li>as：as 也可以省略</li></ul></li></ol></li><li><p>条件查询</p><ol><li>where 子句后跟条件</li><li>运算符<ul><li><blockquote><p>、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;</p></blockquote></li><li><p>BETWEEN…AND</p></li><li><p>IN (集合)</p></li><li><p>LIKE：模糊查询</p><ul><li>占位符：<ul><li>_: 单个任意字符</li><li>%：多个任意字符</li></ul></li></ul></li><li><p>IS NULL</p></li><li><p>and  或 &amp;&amp;</p></li><li><p>or  或 ||</p></li><li><p>not  或！</p><p>– 查询年龄大于 20 岁</p><p>SELECT * FROM student WHERE age &gt; 20;</p><p>SELECT * FROM student WHERE age &gt;= 20;</p><p>– 查询年龄等于 20 岁<br> SELECT * FROM student WHERE age = 20;</p><p>– 查询年龄不等于 20 岁<br> SELECT * FROM student WHERE age != 20;<br>SELECT * FROM student WHERE age &lt;&gt; 20;</p><p>– 查询年龄大于等于 20 小于等于 30</p><p>SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;<br>SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;<br>SELECT * FROM student WHERE age BETWEEN 20 AND 30;</p><p>– 查询年龄 22 岁，18 岁，25 岁的信息<br> SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25<br>SELECT * FROM student WHERE age IN (22,18,25);</p><p>– 查询英语成绩为 null<br>SELECT * FROM student WHERE english = NULL; – 不对的。null 值不能使用 = （!=） 判断</p><p>SELECT * FROM student WHERE english IS NULL;</p><p>– 查询英语成绩不为 null<br>SELECT * FROM student WHERE english  IS NOT NULL;</p></li></ul></li></ol></li></ol><p>​– 查询姓马的有哪些？ like<br>​SELECT * FROM student WHERE NAME LIKE ‘马 %’;<br>​– 查询姓名第二个字是化的人<br>​<br>​SELECT * FROM student WHERE NAME LIKE "<em>化 %";<br>​<br>​– 查询姓名是 3 个字的人<br>​SELECT * FROM student WHERE NAME LIKE '</em>__’;</p><p>​</p><p>​– 查询姓名中包含德的人<br>​SELECT * FROM student WHERE NAME LIKE ‘% 德 %’;</p><p>​</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL约束</title>
      <link href="2020/09/30/MySQL%E7%BA%A6%E6%9D%9F/"/>
      <url>2020/09/30/MySQL%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目录"><a class="markdownIt-Anchor" href="#目录">#</a> 目录</h1><ol><li><p>DQL: 查询语句</p><ol><li>排序查询</li><li>聚合函数</li><li>分组查询</li><li>分页查询</li></ol></li><li><p>约束</p></li><li><p>多表之间的关系</p></li><li><p>范式</p></li><li><p>数据库的备份和还原</p></li></ol><h2 id="dql查询语句"><a class="markdownIt-Anchor" href="#dql查询语句">#</a> DQL: 查询语句</h2><ol><li><p>排序查询</p><ul><li><p>语法：order by 子句</p><ul><li>order by 排序字段 1 排序方式 1 ，  排序字段 2 排序方式 2…</li></ul></li><li><p>排序方式：</p><ul><li>ASC：升序，默认的。</li><li>DESC：降序。</li></ul></li><li><p>注意：</p><ul><li>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</li></ul></li></ul></li><li><p>聚合函数：将一列数据作为一个整体，进行纵向的计算。</p><ol><li>count：计算个数<ol><li>一般选择非空的列：主键</li><li>count(*)</li></ol></li><li>max：计算最大值</li><li>min：计算最小值</li><li>sum：计算和</li><li>avg：计算平均值</li></ol><ul><li>注意：聚合函数的计算，排除 null 值。<br>解决方案：<br>1. 选择不包含非空的列进行计算<br> 2. IFNULL 函数</li></ul></li><li><p>分组查询:</p><ol><li><p>语法：group by 分组字段；</p></li><li><p>注意：</p><ol><li>分组之后查询的字段：分组字段、聚合函数</li><li>where 和 having 的区别？<ol><li>where 在分组之前进行限定，如果不满足条件，则不参与分组。having 在分组之后进行限定，如果不满足结果，则不会被查询出来</li><li>where 后不可以跟聚合函数，having 可以进行聚合函数的判断。</li></ol></li></ol><p>– 按照性别分组。分别查询男、女同学的平均分</p><p>SELECT sex , AVG(math) FROM student GROUP BY sex;</p><p>– 按照性别分组。分别查询男、女同学的平均分，人数</p><p>SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;</p><p>–  按照性别分组。分别查询男、女同学的平均分，人数 要求：分数低于 70 分的人，不参与分组<br> SELECT sex , AVG (math),COUNT (id) FROM student WHERE math &gt; 70 GROUP BY sex;</p><p>–  按照性别分组。分别查询男、女同学的平均分，人数 要求：分数低于 70 分的人，不参与分组，分组之后。人数要大于 2 个人<br> SELECT sex , AVG (math),COUNT (id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT (id) &gt; 2;</p><p>SELECT sex , AVG (math),COUNT (id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</p></li></ol></li></ol><p>​<br>4. 分页查询<br> 1. 语法：limit 开始的索引，每页查询的条数；<br>2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数<br>– 每页显示 3 条记录</p><pre><code>SELECT * FROM student LIMIT 0,3; -- 第1页SELECT * FROM student LIMIT 3,3; -- 第2页SELECT * FROM student LIMIT 6,3; -- 第3页3. limit 是一个MySQL"方言"</code></pre><h2 id="约束"><a class="markdownIt-Anchor" href="#约束">#</a> 约束</h2><ul><li><p>概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p></li><li><p>分类：</p><ol><li>主键约束：primary key</li><li>非空约束：not null</li><li>唯一约束：unique</li><li>外键约束：foreign key</li></ol></li><li><p>非空约束：not null，某一列的值不能为 null</p><ol><li><p>创建表时添加约束<br> CREATE TABLE stu (<br>id INT,<br>NAME VARCHAR (20) NOT NULL – name 为非空<br>);</p></li><li><p>创建表完后，添加非空约束<br> ALTER TABLE stu MODIFY NAME VARCHAR (20) NOT NULL;</p></li><li><p>删除 name 的非空约束<br> ALTER TABLE stu MODIFY NAME VARCHAR (20);</p></li></ol></li><li><p>唯一约束：unique，某一列的值不能重复</p><ol><li>注意：<ul><li>唯一约束可以有 NULL 值，但是只能有一条记录为 null</li></ul></li><li>在创建表时，添加唯一约束<br> CREATE TABLE stu (<br>id INT,<br>phone_number VARCHAR (20) UNIQUE – 手机号<br>);</li><li>删除唯一约束<br> ALTER TABLE stu DROP INDEX phone_number;</li><li>在表创建完后，添加唯一约束<br> ALTER TABLE stu MODIFY phone_number VARCHAR (20) UNIQUE;</li></ol></li><li><p>主键约束：primary key。</p><ol><li><p>注意：</p><ol><li>含义：非空且唯一</li><li>一张表只能有一个字段为主键</li><li>主键就是表中记录的唯一标识</li></ol></li><li><p>在创建表时，添加主键约束<br> create table stu (<br>id int primary key,-- 给 id 添加主键约束<br> name varchar (20)<br>);</p></li><li><p>删除主键<br>– 错误 alter table stu modify id int ;<br>ALTER TABLE stu DROP PRIMARY KEY;</p></li><li><p>创建完表后，添加主键<br> ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p></li><li><p>自动增长：</p><ol><li><p>概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</p></li><li><p>在创建表时，添加主键约束，并且完成主键自增长<br> create table stu (<br>id int primary key auto_increment,-- 给 id 添加主键约束<br> name varchar (20)<br>);</p></li></ol></li></ol></li></ul><p>​<br>​3. 删除自动增长<br>​ALTER TABLE stu MODIFY id INT;<br>​4. 添加自动增长<br>​ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</p><ul><li>外键约束：foreign key, 让表于表产生关系，从而保证数据的正确性。<ol><li><p>在创建表时，可以添加外键</p><ul><li>语法：<br>create table 表名 (<br>…<br> 外键列<br> constraint 外键名称 foreign key (外键列名称) references 主表名称 (主表列名称)<br>);</li></ul></li><li><p>删除外键<br> ALTER TABLE 表名 DROP FOREIGN KEY 外键名称；</p></li><li><p>创建表之后，添加外键<br> ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称);</p></li></ol></li></ul><p>​<br>​4. 级联操作<br>​1. 添加级联操作<br>​语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称<br>​FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;<br>​2. 分类：<br>​1. 级联更新：ON UPDATE CASCADE<br>​2. 级联删除：ON DELETE CASCADE</p><h2 id="数据库的设计"><a class="markdownIt-Anchor" href="#数据库的设计">#</a> 数据库的设计</h2><ol><li>多表之间的关系<ol><li><p>分类：</p><ol><li>一对一 (了解)：<ul><li>如：人和身份证</li><li>分析：一个人只有一个身份证，一个身份证只能对应一个人</li></ul></li><li>一对多 (多对一)：<ul><li>如：部门和员工</li><li>分析：一个部门有多个员工，一个员工只能对应一个部门</li></ul></li><li>多对多：<ul><li>如：学生和课程</li><li>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</li></ul></li></ol></li><li><p>实现关系：</p><ol><li>一对多 (多对一)：<ul><li>如：部门和员工</li><li>实现方式：在多的一方建立外键，指向一的一方的主键。</li></ul></li><li>多对多：<ul><li>如：学生和课程</li><li>实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</li></ul></li><li>一对一 (了解)：<ul><li>如：人和身份证</li><li>实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</li></ul></li></ol></li><li><p>案例<br>– 创建旅游线路分类表 tab_category<br>– cid 旅游线路分类主键，自动增长<br>– cname 旅游线路分类名称非空，唯一，字符串 100<br>CREATE TABLE tab_category (<br>cid INT PRIMARY KEY AUTO_INCREMENT,<br>cname VARCHAR(100) NOT NULL UNIQUE<br>);</p><p>– 创建旅游线路表 tab_route<br>/*<br>rid 旅游线路主键，自动增长<br> rname 旅游线路名称非空，唯一，字符串 100<br>price 价格<br> rdate 上架时间，日期类型<br> cid 外键，所属分类<br> */<br>CREATE TABLE tab_route(<br>rid INT PRIMARY KEY AUTO_INCREMENT,<br>rname VARCHAR(100) NOT NULL UNIQUE,<br>price DOUBLE,<br>rdate DATE,<br>cid INT,<br>FOREIGN KEY (cid) REFERENCES tab_category(cid)<br>);</p><p>/* 创建用户表 tab_user<br>uid 用户主键，自增长<br> username 用户名长度 100，唯一，非空<br> password 密码长度 30，非空<br> name 真实姓名长度 100<br>birthday 生日<br> sex 性别，定长字符串 1<br>telephone 手机号，字符串 11<br>email 邮箱，字符串长度 100<br>*/<br>CREATE TABLE tab_user (<br>uid INT PRIMARY KEY AUTO_INCREMENT,<br>username VARCHAR(100) UNIQUE NOT NULL,<br>PASSWORD VARCHAR(30) NOT NULL,<br>NAME VARCHAR(100),<br>birthday DATE,<br>sex CHAR (1) DEFAULT ‘男’,<br>telephone VARCHAR(11),<br>email VARCHAR(100)<br>);</p><p>/*<br> 创建收藏表 tab_favorite<br>rid 旅游线路 id，外键<br> date 收藏时间<br> uid 用户 id，外键<br> rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次<br> */<br>CREATE TABLE tab_favorite (<br>rid INT, – 线路 id<br>DATE DATETIME,<br>uid INT, – 用户 id<br>– 创建复合主键<br> PRIMARY KEY (rid,uid), – 联合主键<br> FOREIGN KEY (rid) REFERENCES tab_route (rid),<br>FOREIGN KEY(uid) REFERENCES tab_user(uid)<br>);</p></li></ol></li></ol><p>​</p><h2 id="数据库设计的范式"><a class="markdownIt-Anchor" href="#数据库设计的范式">#</a> 数据库设计的范式</h2><ul><li><p>概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。<br>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯 - 科德范式（BCNF）、第四范式 (4NF）和第五范式（5NF，又称完美范式）。</p></li><li><p>分类：</p><ol><li><p>第一范式（1NF）：每一列都是不可分割的原子数据项</p></li><li><p>第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于码（在 1NF 基础上消除非主属性对主码的部分函数依赖）</p><ul><li>几个概念：<ol><li>函数依赖：A–&gt;B, 如果通过 A 属性 (属性组) 的值，可以确定唯一 B 属性的值。则称 B 依赖于 A<br> 例如：学号–&gt; 姓名。  （学号，课程名称） --&gt; 分数</li><li>完全函数依赖：A–&gt;B， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。<br>例如：（学号，课程名称） --&gt; 分数</li><li>部分函数依赖：A–&gt;B， 如果 A 是一个属性组，则 B 属性值得确定只需要依赖于 A 属性组中某一些值即可。<br>例如：（学号，课程名称） – &gt; 姓名</li><li>传递函数依赖：A–&gt;B, B – &gt;C . 如果通过 A 属性 (属性组) 的值，可以确定唯一 B 属性的值，在通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A<br> 例如：学号–&gt; 系名，系名–&gt; 系主任</li><li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性 (属性组) 为该表的码<br>例如：该表中码为：（学号，课程名称）<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除过码属性组的属性</li></ul></li></ol></li></ul></li><li><p>第三范式（3NF）：在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖）</p></li></ol></li></ul><h2 id="数据库的备份和还原"><a class="markdownIt-Anchor" href="#数据库的备份和还原">#</a> 数据库的备份和还原</h2><ol><li>命令行：<ul><li>语法：<ul><li>备份： mysqldump -u 用户名 -p 密码 数据库名称 &gt; 保存的路径</li><li>还原：<ol><li>登录数据库</li><li>创建数据库</li><li>使用数据库</li><li>执行文件。source 文件路径</li></ol></li></ul></li></ul></li><li>图形化工具：</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL多表和事务</title>
      <link href="2020/09/30/MySQL%E5%A4%9A%E8%A1%A8-%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/09/30/MySQL%E5%A4%9A%E8%A1%A8-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="目录"><a class="markdownIt-Anchor" href="#目录">#</a> 目录</h1><ol><li><p>多表查询</p></li><li><p>事务</p></li><li><p>DCL</p></li></ol><h2 id="多表查询"><a class="markdownIt-Anchor" href="#多表查询">#</a> 多表查询：</h2><ul><li><p>查询语法：<br>select<br> 列名列表<br> from<br> 表名列表<br> where…</p></li><li><p>准备 sql</p><h3 id="创建部门表"><a class="markdownIt-Anchor" href="#创建部门表">#</a> 创建部门表</h3><p>CREATE TABLE dept(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>NAME VARCHAR(20)<br>);<br>INSERT INTO dept (NAME) VALUES (‘开发部’),(‘市场部’),(‘财务部’);</p><h3 id="创建员工表"><a class="markdownIt-Anchor" href="#创建员工表">#</a> 创建员工表</h3><p>CREATE TABLE emp (<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>NAME VARCHAR(10),<br>gender CHAR (1), – 性别<br> salary DOUBLE, – 工资<br> join_date DATE, – 入职日期<br> dept_id INT,<br>FOREIGN KEY (dept_id) REFERENCES dept (id) – 外键，关联部门表 (部门表的主键)<br>);<br>INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (‘孙悟空’,‘男’,7200,‘2013-02-24’,1);<br>INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (‘猪八戒’,‘男’,3600,‘2010-12-02’,2);<br>INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (‘唐僧’,‘男’,9000,‘2008-08-08’,2);<br>INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (‘白骨精’,‘女’,5000,‘2015-10-07’,3);<br>INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (‘蜘蛛精’,‘女’,4500,‘2011-03-14’,1);</p></li><li><p>笛卡尔积：</p><ul><li>有两个集合 A,B . 取这两个集合的所有组成情况。</li><li>要完成多表查询，需要消除无用的数据</li></ul></li><li><p>多表查询的分类：</p><ol><li>内连接查询：<ol><li><p>隐式内连接：使用 where 条件消除无用数据</p><ul><li>例子：<br>– 查询所有员工信息和对应的部门信息</li></ul><p>SELECT * FROM emp,dept WHERE emp. <code>dept_id</code>  = dept. <code>id</code> ;</p><p>– 查询员工表的名称，性别。部门表的名称<br> SELECT <a href="http://emp.name">emp.name</a>,emp.gender,<a href="http://dept.name">dept.name</a> FROM emp,dept WHERE emp. <code>dept_id</code>  = dept. <code>id</code> ;</p><p>SELECT<br><a href="http://t1.name">t1.name</a>, – 员工表的姓名<br> t1.gender,-- 员工表的性别<br><a href="http://t2.name"> t2.name</a> – 部门表的名称<br> FROM<br>emp t1,<br>dept t2<br>WHERE<br>t1. <code>dept_id</code>  = t2. <code>id</code> ;</p></li></ol></li></ol></li></ul><p>​<br>​2. 显式内连接：<br>​* 语法： select 字段列表 from 表名 1 [inner] join 表名 2 on 条件<br>​* 例如：<br>​* SELECT * FROM emp INNER JOIN dept ON emp. <code>dept_id</code>  = dept. <code>id</code> ;<br>​* SELECT * FROM emp JOIN dept ON emp. <code>dept_id</code>  = dept. <code>id</code> ;</p><pre><code>3. 内连接查询：1. 从哪些表中查询数据2. 条件是什么3. 查询哪些字段</code></pre><ol start="2"><li>外链接查询：<ol><li>左外连接：<ul><li>语法：select 字段列表 from 表 1 left [outer] join 表 2 on 条件；</li><li>查询的是左表所有数据以及其交集部分。</li><li>例子：<br>– 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称<br> SELECT t1.*,t2. <code>name</code>  FROM emp t1 LEFT JOIN dept t2 ON t1. <code>dept_id</code>  = t2. <code>id</code> ;</li></ul></li><li>右外连接：<ul><li>语法：select 字段列表 from 表 1 right [outer] join 表 2 on 条件；</li><li>查询的是右表所有数据以及其交集部分。</li><li>例子：<br>SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1. <code>dept_id</code>  = t2. <code>id</code> ;</li></ul></li></ol></li><li>子查询：<ul><li><p>概念：查询中嵌套查询，称嵌套查询为子查询。<br>– 查询工资最高的员工信息<br>– 1 查询最高的工资是多少 9000<br>SELECT MAX(salary) FROM emp;</p><p>– 2 查询员工信息，并且工资等于 9000 的<br> SELECT * FROM emp WHERE emp. <code>salary</code>  = 9000;</p><p>– 一条 sql 就完成这个操作。子查询<br> SELECT * FROM emp WHERE emp. <code>salary</code>  = (SELECT MAX(salary) FROM emp);</p></li><li><p>子查询不同情况</p><ol><li><p>子查询的结果是单行单列的：</p><ul><li>子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</li><li></li></ul><p>– 查询员工工资小于平均工资的人<br> SELECT * FROM emp WHERE emp.salary &lt;(SELECT AVG (salary) FROM emp);</p></li><li><p>子查询的结果是多行单列的：</p><ul><li>子查询可以作为条件，使用运算符 in 来判断<br>– 查询’财务部’和’市场部’所有的员工信息<br> SELECT id FROM dept WHERE NAME = ‘财务部’ OR NAME = ‘市场部’;<br>SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;<br>– 子查询<br> SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = ‘财务部’ OR NAME = ‘市场部’);</li></ul></li><li><p>子查询的结果是多行多列的：</p><ul><li>子查询可以作为一张虚拟表参与查询<br>– 查询员工入职日期是 2011-11-11 日之后的员工信息和部门信息<br>– 子查询<br> SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp. <code>join_date</code>  &gt; ‘2011-11-11’) t2<br>WHERE <a href="http://t1.id">t1.id</a> = t2.dept_id;</li></ul><p>– 普通内连接<br> SELECT * FROM emp t1,dept t2 WHERE t1. <code>dept_id</code>  = t2. <code>id</code>  AND t1. <code>join_date</code>  &gt;  ‘2011-11-11’</p></li></ol></li></ul></li></ol><ul><li><p>多表查询练习</p><pre><code>  -- 部门表  CREATE TABLE dept (    id INT PRIMARY KEY PRIMARY KEY, -- 部门id    dname VARCHAR(50), -- 部门名称    loc VARCHAR(50) -- 部门所在地  );    -- 添加4个部门  INSERT INTO dept(id,dname,loc) VALUES   (10,'教研部','北京'),  (20,'学工部','上海'),  (30,'销售部','广州'),  (40,'财务部','深圳');</code></pre></li></ul><p>​<br>​</p><p>​– 职务表，职务名称，职务描述<br>​CREATE TABLE job (<br>​  id INT PRIMARY KEY,<br>​  jname VARCHAR(20),<br>​  description VARCHAR(50)<br>​);<br>​<br>​– 添加 4 个职务<br>​INSERT INTO job (id, jname, description) VALUES<br>​(1, ‘董事长’, ‘管理整个公司，接单’),<br>​(2, ‘经理’, ‘管理部门员工’),<br>​(3, ‘销售员’, ‘向客人推销产品’),<br>​(4, ‘文员’, ‘使用办公软件’);</p><p>​<br>​</p><p>​– 员工表<br>​CREATE TABLE emp (<br>​  id INT PRIMARY KEY, – 员工 id<br>​  ename VARCHAR (50), – 员工姓名<br>​  job_id INT, – 职务 id<br>​  mgr INT , – 上级领导<br>​  joindate DATE, – 入职日期<br>​  salary DECIMAL (7,2), – 工资<br>​  bonus DECIMAL (7,2), – 奖金<br>​  dept_id INT, – 所在部门编号<br>​  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),<br>​  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)<br>​);<br>​<br>​– 添加员工<br>​INSERT INTO emp (id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES<br>​(1001,‘孙悟空’,4,1004,‘2000-12-17’,‘8000.00’,NULL,20),<br>​(1002,‘卢俊义’,3,1006,‘2001-02-20’,‘16000.00’,‘3000.00’,30),<br>​(1003,‘林冲’,3,1006,‘2001-02-22’,‘12500.00’,‘5000.00’,30),<br>​(1004,‘唐僧’,2,1009,‘2001-04-02’,‘29750.00’,NULL,20),<br>​(1005,‘李逵’,4,1006,‘2001-09-28’,‘12500.00’,‘14000.00’,30),<br>​(1006,‘宋江’,2,1009,‘2001-05-01’,‘28500.00’,NULL,30),<br>​(1007,‘刘备’,2,1009,‘2001-09-01’,‘24500.00’,NULL,10),<br>​(1008,‘猪八戒’,4,1004,‘2007-04-19’,‘30000.00’,NULL,20),<br>​(1009,‘罗贯中’,1,NULL,‘2001-11-17’,‘50000.00’,NULL,10),<br>​(1010,‘吴用’,3,1006,‘2001-09-08’,‘15000.00’,‘0.00’,30),<br>​(1011,‘沙僧’,4,1004,‘2007-05-23’,‘11000.00’,NULL,20),<br>​(1012,‘李逵’,4,1006,‘2001-12-03’,‘9500.00’,NULL,30),<br>​(1013,‘小白龙’,4,1004,‘2001-12-03’,‘30000.00’,NULL,20),<br>​(1014,‘关羽’,4,1007,‘2002-01-23’,‘13000.00’,NULL,10);</p><p>​<br>​</p><p>​– 工资等级表<br>​CREATE TABLE salarygrade (<br>​  grade INT PRIMARY KEY,   – 级别<br>​  losalary INT,  – 最低工资<br>​  hisalary INT – 最高工资<br>​);<br>​<br>​– 添加 5 个工资等级<br>​INSERT INTO salarygrade (grade,losalary,hisalary) VALUES<br>​(1,7000,12000),<br>​(2,12010,14000),<br>​(3,14010,20000),<br>​(4,20010,30000),<br>​(5,30010,99990);<br>​<br>​– 需求：<br>​<br>​– 1. 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述<br>​/*<br>​分析：<br>​1. 员工编号，员工姓名，工资，需要查询 emp 表  职务名称，职务描述 需要查询 job 表<br>​2. 查询条件 emp.job_id = <a href="http://job.id">job.id</a><br>​<br>​*/<br>​SELECT<br>​t1. <code>id</code> , – 员工编号<br>​t1. <code>ename</code> , – 员工姓名<br>​t1. <code>salary</code> ,-- 工资<br>​t2. <code>jname</code> , – 职务名称<br>​t2. <code>description</code>  – 职务描述<br>​FROM<br>​emp t1, job t2<br>​WHERE<br>​t1. <code>job_id</code>  = t2. <code>id</code> ;</p><p>​<br>​</p><p>​– 2. 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置<br>​/*<br>​分析：</p><pre><code>1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept2. 条件： emp.job_id = job.id and emp.dept_id = dept.id*/SELECT t1.`id`, -- 员工编号t1.`ename`, -- 员工姓名t1.`salary`,-- 工资t2.`jname`, -- 职务名称t2.`description`, -- 职务描述t3.`dname`, -- 部门名称t3.`loc` -- 部门位置FROM emp t1, job t2,dept t3WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;-- 3.查询员工姓名，工资，工资等级/*分析：1.员工姓名，工资 emp  工资等级 salarygrade2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalaryemp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary*/SELECT t1.ename ,t1.`salary`,t2.*FROM emp t1, salarygrade t2WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;</code></pre><p>​<br>​</p><p>​– 4. 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级<br>​/*<br>​分析：</p><pre><code>1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary*/SELECT t1.`ename`,t1.`salary`,t2.`jname`,t2.`description`,t3.`dname`,t3.`loc`,t4.`grade`FROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;</code></pre><p>​<br>​</p><p>​– 5. 查询出部门编号、部门名称、部门位置、部门人数<br>​<br>​/*<br>​分析：<br>​1. 部门编号、部门名称、部门位置 dept 表。 部门人数 emp 表<br>​2. 使用分组查询。按照 emp.dept_id 完成分组，查询 count (id)<br>​3. 使用子查询将第 2 步的查询结果和 dept 表进行关联查询<br>​<br>​*/<br>​SELECT<br>​t1. <code>id</code> ,t1. <code>dname</code> ,t1. <code>loc</code>  , t2.total<br>​FROM<br>​dept t1,<br>​(SELECT<br>​dept_id,COUNT(id) total<br>​FROM<br>​emp<br>​GROUP BY dept_id) t2<br>​WHERE t1. <code>id</code>  = t2.dept_id;</p><p>​</p><p>​– 6. 查询所有员工的姓名及其直接上级的姓名，没有领导的员工也需要查询<br>​<br>​/*<br>​分析：<br>​1. 姓名 emp， 直接上级的姓名 emp</p><h2 id="事务"><a class="markdownIt-Anchor" href="#事务">#</a> 事务</h2><ol><li>事务的基本介绍<ol><li><p>概念：</p><ul><li>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</li></ul></li><li><p>操作：</p><ol><li>开启事务： start transaction;</li><li>回滚：rollback;</li><li>提交：commit;</li></ol></li><li><p>例子：<br>CREATE TABLE account (<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>NAME VARCHAR(10),<br>balance DOUBLE<br>);<br>– 添加数据<br> INSERT INTO account (NAME, balance) VALUES (‘zhangsan’, 1000), (‘lisi’, 1000);</p></li></ol></li></ol><p>​</p><p>​SELECT * FROM account;<br>​UPDATE account SET balance = 1000;<br>​– 张三给李四转账 500 元<br>​<br>​– 0. 开启事务<br>​START TRANSACTION;<br>​– 1. 张三账户 -500<br>​<br>​UPDATE account SET balance = balance - 500 WHERE NAME = ‘zhangsan’;<br>​– 2. 李四账户 +500<br>​– 出错了…<br>​UPDATE account SET balance = balance + 500 WHERE NAME = ‘lisi’;<br>​<br>​– 发现执行没有问题，提交事务<br>​COMMIT;<br>​<br>​– 发现出问题了，回滚事务<br>​ROLLBACK;</p><ol start="4"><li><p>MySQL 数据库中事务默认自动提交</p><ul><li>事务提交的两种方式：<ul><li>自动提交：<ul><li>mysql 就是自动提交的</li><li>一条 DML (增删改) 语句会自动提交一次事务。</li></ul></li><li>手动提交：<ul><li>Oracle 数据库默认是手动提交事务</li><li>需要先开启事务，再提交</li></ul></li></ul></li><li>修改事务的默认提交方式：<ul><li>查看事务的默认提交方式：SELECT @@autocommit; – 1 代表自动提交  0 代表手动提交</li><li>修改默认提交方式： set @@autocommit = 0;</li></ul></li></ul></li><li><p>事务的四大特征：</p><ol><li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</li><li>持久性：当事务提交或回滚后，数据库会持久化的保存数据。</li><li>隔离性：多个事务之间。相互独立。</li><li>一致性：事务操作前后，数据总量不变</li></ol></li><li><p>事务的隔离级别（了解）</p><ul><li><p>概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p></li><li><p>存在问题：</p><ol><li>脏读：一个事务，读取到另一个事务中没有提交的数据</li><li>不可重复读 (虚读)：在同一个事务中，两次读取到的数据不一样。</li><li>幻读：一个事务操作 (DML) 数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li></ol></li><li><p>隔离级别：</p><ol><li>read uncommitted：读未提交<ul><li>产生的问题：脏读、不可重复读、幻读</li></ul></li><li>read committed：读已提交 （Oracle）<ul><li>产生的问题：不可重复读、幻读</li></ul></li><li>repeatable read：可重复读 （MySQL 默认）<ul><li>产生的问题：幻读</li></ul></li><li>serializable：串行化<ul><li>可以解决所有的问题</li></ul></li></ol><ul><li>注意：隔离级别从小到大安全性越来越高，但是效率越来越低</li><li>数据库查询隔离级别：<ul><li>select @@tx_isolation;</li></ul></li><li>数据库设置隔离级别：<ul><li>set global transaction isolation level  级别字符串；</li></ul></li></ul></li><li><p>演示：<br>set global transaction isolation level read uncommitted;<br>start transaction;<br>– 转账操作<br> update account set balance = balance - 500 where id = 1;<br>update account set balance = balance + 500 where id = 2;</p></li></ul></li></ol><h2 id="dcl"><a class="markdownIt-Anchor" href="#dcl">#</a> DCL：</h2><ul><li><p>SQL 分类：</p><ol><li>DDL：操作数据库和表</li><li>DML：增删改表中数据</li><li>DQL：查询表中数据</li><li>DCL：管理用户，授权</li></ol></li><li><p>DBA：数据库管理员</p></li><li><p>DCL：管理用户，授权</p><ol><li>管理用户<ol><li><p>添加用户：</p><ul><li>语法：CREATE USER ‘用户名’@‘主机名’ IDENTIFIED BY ‘密码’;</li></ul></li><li><p>删除用户：</p><ul><li>语法：DROP USER ‘用户名’@‘主机名’;</li></ul></li><li><p>修改用户密码：</p><p>UPDATE USER SET PASSWORD = PASSWORD (‘新密码’) WHERE USER = ‘用户名’;<br>UPDATE USER SET PASSWORD = PASSWORD(‘abc’) WHERE USER = ‘lisi’;</p></li></ol></li></ol><p>SET PASSWORD FOR ‘用户名’@‘主机名’ = PASSWORD (‘新密码’);<br>SET PASSWORD FOR ‘root’@‘localhost’ = PASSWORD(‘123’);</p><ul><li>mysql 中忘记了 root 用户的密码？</li></ul><ol><li><p>cmd – &gt; net stop mysql 停止 mysql 服务<br> * 需要管理员运行该 cmd</p><pre><code> 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password('你的新密码') where user = 'root'; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。</code></pre></li><li><p>查询用户：<br>– 1. 切换到 mysql 数据库<br> USE myql;<br>– 2. 查询 user 表<br> SELECT * FROM USER;</p><ul><li>通配符： % 表示可以在任意主机使用用户登录数据库</li></ul></li><li><p>权限管理：</p><ol><li><p>查询权限：<br>– 查询权限<br> SHOW GRANTS FOR ‘用户名’@‘主机名’;<br>SHOW GRANTS FOR ‘lisi’@’%’;</p></li><li><p>授予权限：<br>– 授予权限<br> grant 权限列表 on 数据库名。表名 to ‘用户名’@‘主机名’;<br>– 给张三用户授予所有权限，在任意数据库任意表上</p><p>GRANT ALL ON <em>.</em> TO ‘zhangsan’@‘localhost’;</p></li><li><p>撤销权限：<br>– 撤销权限：<br>revoke 权限列表 on 数据库名。表名 from ‘用户名’@‘主机名’;<br>REVOKE UPDATE ON db3. <code>account</code>  FROM ‘lisi’@’%’;</p></li></ol></li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet-HTTP-Request</title>
      <link href="2020/09/30/Servlet-HTTP-Request/"/>
      <url>2020/09/30/Servlet-HTTP-Request/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目录"><a class="markdownIt-Anchor" href="#目录">#</a> 目录：</h1><ol><li>Servlet</li><li>HTTP 协议</li><li>Request</li></ol><h2 id="servlet"><a class="markdownIt-Anchor" href="#servlet">#</a> Servlet：</h2><ol><li><p>概念</p></li><li><p>步骤</p></li><li><p>执行原理</p></li><li><p>生命周期</p></li><li><p>Servlet3.0 注解配置</p></li><li><p>Servlet 的体系结构<br>Servlet – 接口<br> |<br>GenericServlet – 抽象类<br> |<br>HttpServlet  – 抽象类</p><ul><li><p>GenericServlet：将 Servlet 接口中其他的方法做了默认空实现，只将 service () 方法作为抽象</p><ul><li>将来定义 Servlet 类时，可以继承 GenericServlet，实现 service () 方法即可</li></ul></li><li><p>HttpServlet：对 http 协议的一种封装，简化操作</p><ol><li>定义类继承 HttpServlet</li><li>复写 doGet/doPost 方法</li></ol></li></ul></li><li><p>Servlet 相关配置</p><ol><li>urlpartten:Servlet 访问路径<ol><li>一个 Servlet 可以定义多个访问路径 ： @WebServlet ({"/d4","/dd4","/ddd4"})</li><li>路径定义规则：<ol><li>/xxx：路径匹配</li><li>/xxx/xxx: 多层路径，目录结构</li><li>*.do：扩展名匹配</li></ol></li></ol></li></ol></li></ol><h2 id="http"><a class="markdownIt-Anchor" href="#http">#</a> HTTP：</h2><ul><li><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p><ul><li><p>传输协议：定义了，客户端和服务器端通信时，发送数据的格式</p></li><li><p>特点：</p><ol><li>基于 TCP/IP 的高级协议</li><li>默认端口号：80</li><li>基于请求 / 响应模型的：一次请求对应一次响应</li><li>无状态的：每次请求之间相互独立，不能交互数据</li></ol></li><li><p>历史版本：</p><ul><li>1.0：每一次请求响应都会建立新的连接</li><li>1.1：复用连接</li></ul></li></ul></li><li><p>请求消息数据格式</p><ol><li><p>请求行<br>请求方式 请求 url 请求协议 / 版本<br> GET /login.htmlHTTP/1.1</p><ul><li>请求方式：<ul><li>HTTP 协议有 7 中请求方式，常用的有 2 种<ul><li>GET：<ol><li>请求参数在请求行中，在 url 后。</li><li>请求的 url 长度有限制的</li><li>不太安全</li></ol></li><li>POST：<ol><li>请求参数在请求体中</li><li>请求的 url 长度没有限制的</li><li>相对安全</li></ol></li></ul></li></ul></li></ul></li><li><p>请求头：客户端浏览器告诉服务器一些信息<br>请求头名称：请求头值</p><ul><li>常见的请求头：<ol><li><p>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息</p><ul><li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li></ul></li><li><p>Referer：<a href="http://localhost/login.html">http://localhost/login.html</a></p><ul><li>告诉服务器，我 (当前请求) 从哪里来？<ul><li>作用：<ol><li>防盗链：</li><li>统计工作：</li></ol></li></ul></li></ul></li></ol></li></ul></li><li><p>请求空行<br>空行，就是用于分割 POST 请求的请求头，和请求体的。</p></li><li><p>请求体 (正文)：</p><ul><li>封装 POST 请求消息的请求参数的</li></ul></li></ol><ul><li><p>字符串格式：<br>POST /login.htmlHTTP/1.1<br>Host: localhost<br>User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br>Accept-Encoding: gzip, deflate<br>Referer: <a href="http://localhost/login.html">http://localhost/login.html</a><br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1</p><p>username=zhangsan</p></li></ul></li><li><p>响应消息数据格式</p></li></ul><h2 id="request"><a class="markdownIt-Anchor" href="#request">#</a> Request：</h2><ol><li><p>request 对象和 response 对象的原理</p><ol><li>request 和 response 对象是由服务器创建的。我们来使用它们</li><li>request 对象是来获取请求消息，response 对象是来设置响应消息</li></ol></li><li><p>request 对象继承体系结构：<br>ServletRequest–接口<br> |继承<br> HttpServletRequest– 接口<br> |实现<br> org.apache.catalina.connector.RequestFacade 类 (tomcat)</p></li><li><p>request 功能：</p><ol><li>获取请求消息数据<ol><li><p>获取请求行数据</p><ul><li>GET /day14/demo1?name=zhangsan HTTP/1.1</li><li>方法：<ol><li><p>获取请求方式 ：GET</p><ul><li>String getMethod()</li></ul></li><li><p>(*) 获取虚拟目录：/day14</p><ul><li>String getContextPath()</li></ul></li><li><p>获取 Servlet 路径: /demo1</p><ul><li>String getServletPath()</li></ul></li><li><p>获取 get 方式请求参数：name=zhangsan</p><ul><li>String getQueryString()</li></ul></li><li><p>(*) 获取请求 URI：/day14/demo1</p><ul><li><p>String getRequestURI():/day14/demo1</p></li><li><p>StringBuffer getRequestURL()  :<a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a></p></li><li><p>URL: 统一资源定位符 ： <a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a>中华人民共和国</p></li><li><p>URI：统一资源标识符 : /day14/demo1共和国</p></li></ul></li><li><p>获取协议及版本：HTTP/1.1</p><ul><li>String getProtocol()</li></ul></li><li><p>获取客户机的 IP 地址：</p><ul><li>String getRemoteAddr()</li></ul></li></ol></li></ul></li><li><p>获取请求头数据</p><ul><li>方法：<ul><li>(*) String getHeader (String name): 通过请求头的名称获取请求头的值</li><li>Enumeration<string> getHeaderNames (): 获取所有的请求头名称</string></li></ul></li></ul></li><li><p>获取请求体数据:</p><ul><li>请求体：只有 POST 请求方式，才有请求体，在请求体中封装了 POST 请求的请求参数</li><li>步骤：<ol><li><p>获取流对象</p><ul><li>BufferedReader getReader ()：获取字符输入流，只能操作字符数据</li><li>ServletInputStream getInputStream ()：获取字节输入流，可以操作所有类型数据<ul><li>在文件上传知识点后讲解</li></ul></li></ul></li><li><p>再从流对象中拿数据</p></li></ol></li></ul></li></ol></li></ol></li></ol><p>​<br>​2. 其他功能：<br>​1. 获取请求参数通用方式：不论 get 还是 post 请求方式都可以使用下列方法来获取请求参数<br>​1. String getParameter (String name): 根据参数名称获取参数值    username=zs&amp;password=123<br>​2. String [] getParameterValues (String name): 根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game<br>​3. Enumeration<string> getParameterNames (): 获取所有请求的参数名称<br>​4. Map&lt;String,String []&gt; getParameterMap (): 获取所有参数的 map 集合</string></p><pre><code>* 中文乱码问题：* get方式：tomcat 8 已经将get方式乱码问题解决了* post方式：会乱码* 解决：在获取参数前，设置request的编码request.setCharacterEncoding("utf-8");</code></pre><p>​<br>​2. 请求转发：一种在服务器内部的资源跳转方式<br>​1. 步骤：<br>​1. 通过 request 对象获取请求转发器对象：RequestDispatcher getRequestDispatcher (String path)<br>​2. 使用 RequestDispatcher 对象来进行转发：forward (ServletRequest request, ServletResponse response)</p><pre><code>2. 特点：1. 浏览器地址栏路径不发生变化2. 只能转发到当前服务器内部资源中。3. 转发是一次请求</code></pre><h2 id="案例用户登录"><a class="markdownIt-Anchor" href="#案例用户登录">#</a> 案例：用户登录</h2><ul><li><p>用户登录案例需求：<br>1. 编写 login.html 登录页面<br> username &amp; password 两个输入框<br> 2. 使用 Druid 数据库连接池技术，操作 mysql，day14 数据库中 user 表<br> 3. 使用 JdbcTemplate 技术封装 JDBC<br>4. 登录成功跳转到 SuccessServlet 展示：登录成功！用户名，欢迎您<br> 5. 登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误</p></li><li><p>分析</p></li><li><p>开发步骤</p><ol><li><p>创建项目，导入 html 页面，配置文件，jar 包</p></li><li><p>创建数据库环境<br> CREATE DATABASE day14;<br>USE day14;<br>CREATE TABLE USER(</p><p>​id INT PRIMARY KEY AUTO_INCREMENT,<br>​username VARCHAR(32) UNIQUE NOT NULL,<br>​PASSWORD VARCHAR(32) NOT NULL<br>);</p></li><li><p>创建包 cn.itcast.domain, 创建类 User<br>package cn.itcast.domain;<br>/**</p><ul><li><p>用户的实体类<br> */<br>public class User {</p><p>private int id;<br>private String username;<br>private String password;</p></li></ul></li></ol></li></ul><p>​</p><p>​    public int getId() {<br>​        return id;<br>​    }<br>​<br>​    public void setId(int id) {<br>​        <a href="http://this.id">this.id</a> = id;<br>​    }<br>​<br>​    public String getUsername() {<br>​        return username;<br>​    }<br>​<br>​    public void setUsername(String username) {<br>​        this.username = username;<br>​    }<br>​<br>​    public String getPassword() {<br>​        return password;<br>​    }<br>​<br>​    public void setPassword(String password) {<br>​        this.password = password;<br>​    }<br>​<br>​    @Override<br>​    public String toString() {<br>​        return “User{” +<br>​                “id=” + id +<br>​                “, username=’” + username + ‘’’ +<br>​                “, password=’” + password + ‘’’ +<br>​                ‘}’;<br>​    }<br>​}</p><pre><code>4. 创建包cn.itcast.util,编写工具类JDBCUtilspackage cn.itcast.util;​import com.alibaba.druid.pool.DruidDataSourceFactory;​​import javax.sql.DataSource;​import javax.xml.crypto.Data;​import java.io.IOException;​import java.io.InputStream;​import java.sql.Connection;​import java.sql.SQLException;​import java.util.Properties;​​/** * JDBC工具类 使用Durid连接池 */public class JDBCUtils {​    private static DataSource ds ;​    static {​        try {​            //1.加载配置文件​            Properties pro = new Properties();​            //使用ClassLoader加载配置文件，获取字节输入流​            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");​            pro.load(is);​            //2.初始化连接池对象​            ds = DruidDataSourceFactory.createDataSource(pro);​        } catch (IOException e) {​            e.printStackTrace();​        } catch (Exception e) {​            e.printStackTrace();​        }​    }​    /**     * 获取连接池对象          */        public static DataSource getDataSource(){        return ds;        }</code></pre><p>​</p><p>​    /**<br>​     * 获取连接 Connection 对象<br>​     <em>/<br>​    public static Connection getConnection() throws SQLException {<br>​        return  ds.getConnection();<br>​    }<br>​}<br>​5. 创建包 cn.itcast.dao, 创建类 UserDao, 提供 login 方法<br>​<br>​package cn.itcast.dao;<br>​<br>​import cn.itcast.domain.User;<br>​import cn.itcast.util.JDBCUtils;<br>​import org.springframework.dao.DataAccessException;<br>​import org.springframework.jdbc.core.BeanPropertyRowMapper;<br>​import org.springframework.jdbc.core.JdbcTemplate;<br>​<br>​/</em>*<br>​ * 操作数据库中 User 表的类<br>​ */<br>​public class UserDao {<br>​<br>// 声明 JDBCTemplate 对象共用<br> private JdbcTemplate template = new JdbcTemplate (JDBCUtils.getDataSource ());</p><pre><code>    /**     * 登录方法     * @param loginUser 只有用户名和密码     * @return user包含用户全部数据,没有查询到，返回null     */    public User login(User loginUser){        try {            //1.编写sql            String sql = "select * from user where username = ? and password = ?";            //2.调用query方法            User user = template.queryForObject(sql,                    new BeanPropertyRowMapper&lt;User&gt;(User.class),                    loginUser.getUsername(), loginUser.getPassword());</code></pre><p>​</p><p>​            return user;<br>​        } catch (DataAccessException e) {<br>​            e.printStackTrace ();// 记录日志<br>​            return null;<br>​        }<br>​    }<br>​}<br>​</p><pre><code>6. 编写cn.itcast.web.servlet.LoginServlet类package cn.itcast.web.servlet;​import cn.itcast.dao.UserDao;​import cn.itcast.domain.User;​​import javax.servlet.ServletException;​import javax.servlet.annotation.WebServlet;​import javax.servlet.http.HttpServlet;​import javax.servlet.http.HttpServletRequest;​import javax.servlet.http.HttpServletResponse;​import java.io.IOException;</code></pre><p>​</p><p>​@WebServlet("/loginServlet")<br>​public class LoginServlet extends HttpServlet {</p><p>​</p><p>​    @Override<br>​    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>​        <a href="//1.xn--d8yz4mshv84b">//1. 设置编码</a><br>​        req.setCharacterEncoding (“utf-8”);<br>​        <a href="//2.xn--8nrrb831grng2u5admk">//2. 获取请求参数</a><br>​        String username = req.getParameter (“username”);<br>​        String password = req.getParameter(“password”);<br>​        <a href="//3.xn--user-ou9gnbx382dmbg">//3. 封装 user 对象</a><br>​        User loginUser = new User ();<br>​        loginUser.setUsername(username);<br>​        loginUser.setPassword(password);<br>​<br>​        <a href="//4.xn--UserDaologin-g98y914e5q2aktew64i">//4. 调用 UserDao 的 login 方法</a><br>​        UserDao dao = new UserDao ();<br>​        User user = dao.login(loginUser);<br>​<br>​        <a href="//5.xn--user-zk9fu84h">//5. 判断 user</a><br>​        if(user == null){<br>​            // 登录失败<br>​            req.getRequestDispatcher ("/failServlet").forward (req,resp);<br>​        }else{<br>​            // 登录成功<br>​            // 存储数据<br>​            req.setAttribute (“user”,user);<br>​            // 转发<br>​            req.getRequestDispatcher ("/successServlet").forward (req,resp);<br>​        }<br>​<br>​    }<br>​<br>​    @Override<br>​    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>​        this.doGet(req,resp);<br>​    }<br>​}</p><pre><code>7. 编写FailServlet和SuccessServlet类@WebServlet("/successServlet")public class SuccessServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //获取request域中共享的user对象        User user = (User) request.getAttribute("user");        if(user != null){            //给页面写一句话            //设置编码            response.setContentType("text/html;charset=utf-8");            //输出            response.getWriter().write("登录成功！"+user.getUsername()+",欢迎您");        }</code></pre><p>​</p><p>​    }</p><p>​@WebServlet("/failServlet")<br>​public class FailServlet extends HttpServlet {<br>​    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>​        // 给页面写一句话<br>​<br>​        // 设置编码<br>​        response.setContentType (“text/html;charset=utf-8”);<br>​        // 输出<br>​        response.getWriter ().write (“登录失败，用户名或密码错误”);<br>​<br>​    }<br>​<br>​    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>​        this.doPost(request,response);<br>​    }<br>​}</p><pre><code>8. login.html中form表单的action路径的写法* 虚拟目录+Servlet的资源路径9. BeanUtils工具类，简化数据封装* 用于封装JavaBean的1. JavaBean：标准的Java类1. 要求：1. 类必须被public修饰2. 必须提供空参的构造器3. 成员变量必须使用private修饰4. 提供公共setter和getter方法2. 功能：封装数据2. 概念：成员变量：属性：setter和getter方法截取后的产物例如：getUsername() --&gt; Username--&gt; username3. 方法：1. setProperty()2. getProperty()3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
