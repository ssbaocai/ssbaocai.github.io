<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象</title>
      <link href="2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面向对象"><a class="anchor" href="#面向对象">#</a> 面向对象</h1><h2 id="基础"><a class="anchor" href="#基础">#</a> 基础</h2><h3 id="类与对象"><a class="anchor" href="#类与对象">#</a> 类与对象</h3><ul><li>对象：对象是类的实例</li><li>类：类是一个模板，描述一类对象的行为和状态</li></ul><h3 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h3><ul><li>用于对象初始化。</li><li>构造方法的名称必须与类同名，一个类可以有多个构造方法。</li></ul><h3 id="方法重载方法重写"><a class="anchor" href="#方法重载方法重写">#</a> 方法重载 / 方法重写</h3><ul><li>重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。子类可以根据需要，定义特定于自己的行为。</li><li>重载：重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li></ul><h2 id="高级"><a class="anchor" href="#高级">#</a> 高级</h2><h3 id="final关键字"><a class="anchor" href="#final关键字">#</a> final 关键字</h3><p>1.final 修饰的类叫最终类，该类不能被继承。<br>2.final 修饰的方法不能被重写。<br>3.final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改</p><h3 id="抽象类"><a class="anchor" href="#抽象类">#</a> 抽象类</h3><ol><li><p>抽象类不能被实例化</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h3 id="接口"><a class="anchor" href="#接口">#</a> 接口</h3><p>接口是抽象方法的集合</p><ul><li>定义格式：<br>interface 接口名称 { &nbsp; &nbsp; &nbsp;<br>全局常量；&nbsp; &nbsp; &nbsp;<br>抽象方法；&nbsp;<br>}</li><li>接口和抽象类的区别：<br>1、抽象类要被子类继承，接口要被类实现。<br>2、接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。<br>3、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br>4、抽象类使用继承来使用，无法多继承。接口使用实现来使用，可以多实现<br> 5、抽象类中可以包含 static 方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明 静态方法）     6、接口不能有构造方法，但是抽象类可以有</li></ul><h3 id="equals"><a class="anchor" href="#equals">#</a> equals</h3><h3 id="内部类"><a class="anchor" href="#内部类">#</a> 内部类</h3><h4 id="成员内部类"><a class="anchor" href="#成员内部类">#</a> 成员内部类</h4><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><pre><code>class Outer { &nbsp; &nbsp;private double x = 0; &nbsp; &nbsp;public Outer(double x) { this.x = x;     } &nbsp; &nbsp;  &nbsp; &nbsp;class Inner { &nbsp; //内部类 &nbsp; &nbsp; &nbsp;public void say() {    System.out.println("x="+x);&nbsp;      } &nbsp;} }</code></pre><p>特点： 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。</p><h4 id="局部内部类"><a class="anchor" href="#局部内部类">#</a> 局部内部类</h4><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限 于方法内或者该作用域内。<br>例如：</p><pre><code>class Person{ &nbsp;  public Person() { &nbsp; &nbsp;}      }        class Man{ &nbsp; &nbsp; &nbsp;      public Man(){ &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;public People getPerson(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;          class Student extends People{                //局部内部类         int age =0; &nbsp;          } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;          return new Student(); &nbsp;           }       }</code></pre><h4 id="匿名内部类"><a class="anchor" href="#匿名内部类">#</a> 匿名内部类</h4><p>new 父类构造器（参数列表）| 实现接口（） { &nbsp; &nbsp; &nbsp;<br>// 匿名内部类的类体部分<br>}</p><h4 id="静态内部类"><a class="anchor" href="#静态内部类">#</a> 静态内部类</h4><p>静态内部类是不需要依赖于外部类对象的，并且它不能使用外部类的非 static 成员变量或者方法.<br> 格式：</p><pre><code>public class Test { &nbsp; public static void main(String[] args)  { &nbsp; &nbsp; &nbsp; Outter.Inner inner = new Outter.Inner(); &nbsp; } } class Outter { &nbsp; &nbsp;public Outter() { &nbsp;  } &nbsp; &nbsp;  &nbsp; &nbsp;static class Inner { &nbsp; &nbsp; &nbsp; &nbsp;public Inner() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;     } &nbsp; } }</code></pre><h2 id="进阶"><a class="anchor" href="#进阶">#</a> 进阶</h2><h3 id="封装"><a class="anchor" href="#封装">#</a> 封装</h3><p>private 修饰变量<br> Getter/Setter</p><h3 id="this"><a class="anchor" href="#this">#</a> this</h3><p>使用 this 关键字可以完成以下的操作：</p><ul><li>调用类中的属性</li><li>调用类中的方法或构造方法</li><li>表示当前对象</li></ul><h3 id="static"><a class="anchor" href="#static">#</a> static</h3><p>static 表示 “静态” 的意思，可以用来修饰成员变量和成员方法<br>重点：<br>1. 静态成员 在类加载时加载并初始化。<br>2. 无论一个类存在多少个对象，静态的属性，永远在内存中只有一份<br> 3. 在访问时： 静态不能访问非静态，非静态可以访问静态！</p><h2 id="异常处理"><a class="anchor" href="#异常处理">#</a> 异常处理</h2><h3 id="try-catch"><a class="anchor" href="#try-catch">#</a> try&nbsp; catch</h3><ul><li>异常指的是 Exception，Exception 类，在 Java 中存在一个父 Throwable（可能的抛出）</li><li>Throwable 存在两个子类：<br>1.Error：表示的是错误，是 JVM 发出的错误操作，只能尽量避免，无法用代码处理。<br>2.Exception：一般表示所有程序中的错误，所以一般在程序中将进行 try…catch 的处理。</li></ul><h3 id="throwthrows"><a class="anchor" href="#throwthrows">#</a> throw/throws</h3><ul><li>throws 关键字：<br>此关键字主要在方法的声明上使 用，表示方法中不处理异常，而交给调用处处理。<br>格式：<br>返回值 方法名称 () throws Exception {<br>}</li><li>throw 关键字<br> throw 关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出 的就是一个异常类的实例化对象，那么此对象也可以由 throw 直接抛出。<br>代码： throw new Exception ("抛着玩的。") ;</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java基础语法"><a class="anchor" href="#java基础语法">#</a> JAVA 基础语法</h1><h2 id="基础语法"><a class="anchor" href="#基础语法">#</a> 基础语法</h2><h3 id="运算符"><a class="anchor" href="#运算符">#</a> 运算符</h3><p>算数运算符</p><p>关系运算符</p><p>赋值运算符</p><p>逻辑运算符</p><p>三目运算符</p><h3 id="数据类型"><a class="anchor" href="#数据类型">#</a> 数据类型</h3><h4 id="基本数据类型"><a class="anchor" href="#基本数据类型">#</a> 基本数据类型</h4><ul><li>byte、short、int、long</li><li>float、double、char</li><li>boolean</li></ul><h4 id="引用数据类型"><a class="anchor" href="#引用数据类型">#</a> 引用数据类型</h4><ul><li>class</li><li>interface</li><li>数组</li></ul><h2 id="流程控制"><a class="anchor" href="#流程控制">#</a> 流程控制</h2><h3 id="if"><a class="anchor" href="#if">#</a> if</h3><p>if 条件结构是根据条件判断之后再做处理</p><h3 id="switch"><a class="anchor" href="#switch">#</a> switch</h3><ul><li>switch (表达式){<br>case 取值 1: 语句块 1;break;<br>case 取值 n: 语句块 n;break; default: 语句块 n+1;break;<br>}</li><li>switch 语句有关规则 表达式的返回值必须是下述几种类型之一：int,byte,char,short,String；</li><li>case 子句中的取值必须是常量，且所有 case 子句中的取值应是不同的；</li></ul><h3 id="while"><a class="anchor" href="#while">#</a> while</h3><ul><li>while 循环<br>符合条件，循环继续执行；否则，循环退出<br>特点：先判断，再执行</li><li>do-while 循环<br>先执行一遍循环操作，符合条件，循环继续执行；否则，循环退出<br>特点：先执行，再判断</li></ul><h3 id="for"><a class="anchor" href="#for">#</a> for</h3><p>语法：<br>for (初始化参数；判断条件；更新循环变量){<br>循环体；<br>}</p><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><h3 id="冒泡排序"><a class="anchor" href="#冒泡排序">#</a> 冒泡排序</h3><p>原理：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的</li></ul><h3 id="二分查找"><a class="anchor" href="#二分查找">#</a> 二分查找</h3><p>二分查找也叫折半查找，是一种基本的查找算法，需要待查的表满足两个条件：</p><ul><li>1. 查找表必须使用顺序的存储结构</li><li>2. 查找表必须按关键字大小有序排列</li></ul><p>算法的基本思想是：</p><ul><li><p>将查找表中间位置数据元素的关键字与给定关键字比较，如果相等则查找成功；</p></li><li><p>否则利用中间元素将表一分为二，如果中间关键字大于给定关键字，则在前一子表中进行折半查找，否则在后一子表中进行折半查找。</p></li><li><p>重复以上过程直到找到满足条件的元素，则查找成功；或直到子表为空为止，此时查找不成功。</p></li></ul><p>二分查找递归写法：</p><pre><code>public int firstOccurrence (int [] nums,int target){    int low = 0,high = nums.length - 1;    while(low &lt;=  high){           int mid = low + (high-low)/2;        if(nums[mid] == target){            return mid;        }        if(nums[mid] &lt; target){            low = mid+1;        }else {            high = mid-1;        }    }    return -1;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
