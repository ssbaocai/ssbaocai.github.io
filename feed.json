{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/SpringBoot/",
            "url": "https://www.baocai-blog.cn/2020/10/13/SpringBoot/",
            "title": "SpringBoot",
            "date_published": "2020-10-13T13:46:19.631Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"springboot\"><a class=\"anchor\" href=\"#springboot\">#</a> SpringBoot</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是springboot\"><a class=\"anchor\" href=\"#什么是springboot\">#</a> 什么是 SpringBoot</h3>\n<p>spring boot 为 spring 服务，用来简化新 spring 应用的初始搭建以及开发过程</p>\n<h3 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h3>\n<ol>\n<li>\n<p>减少开发，测试时间和努力。</p>\n</li>\n<li>\n<p>使用 JavaConfig 有助于避免使用 XML。</p>\n</li>\n<li>\n<p>避免大量的 Maven 导入和各种版本冲突。</p>\n</li>\n<li>\n<p>提供意见发展方法。</p>\n</li>\n<li>\n<p>通过提供默认值快速开始开发。</p>\n</li>\n<li>\n<p>没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish 或其他任何东西。</p>\n</li>\n<li>\n<p>需要更少的配置 因为没有 web.xml 文件。只需添加用 @ Configuration 注释的类，然后添加用 @Bean 注释的方法，Spring 将自动加载对象并像以前一样对其进行管理。您甚至可以将 @Autowired 添加到 bean 方法中，以使 Spring 自动装入需要的依赖关系中。</p>\n</li>\n<li>\n<p>基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active = {enviornment}。在加载主应用程序属性文件后，Spring 将在（application {environment} .properties）中加载后续的应用程序属性文件。</p>\n</li>\n</ol>\n<h2 id=\"常见问题\"><a class=\"anchor\" href=\"#常见问题\">#</a> 常见问题</h2>\n<h3 id=\"springboot核心配置文件\"><a class=\"anchor\" href=\"#springboot核心配置文件\">#</a> SpringBoot 核心配置文件</h3>\n<ul>\n<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li>\n<li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/JavaWeb/",
            "url": "https://www.baocai-blog.cn/2020/10/13/JavaWeb/",
            "title": "JavaWeb",
            "date_published": "2020-10-13T13:44:14.924Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"javaweb\"><a class=\"anchor\" href=\"#javaweb\">#</a> JavaWeb</h1>\n<h3 id=\"说下原生jdbc操作数据库流程\"><a class=\"anchor\" href=\"#说下原生jdbc操作数据库流程\">#</a> 说下原生 jdbc 操作数据库流程？</h3>\n<ul>\n<li>第一步：Class.forName () 加载数据库连接驱动；</li>\n<li>第二步：DriverManager.getConnection () 获取数据连接对象；</li>\n<li>第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;</li>\n<li>第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX ();</li>\n<li>第五步：关闭结果集、关闭会话、关闭连接。<br>\n详细代码请看（封装）：<span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjk1NDI2MTEvYXJ0aWNsZS9kZXRhaWxzLzUyNDI2MDA2\">http://blog.csdn.net/qq_29542611/article/details/52426006</span></li>\n</ul>\n<h3 id=\"session-和-cookie-有什么区别\"><a class=\"anchor\" href=\"#session-和-cookie-有什么区别\">#</a> session 和 cookie 有什么区别？</h3>\n<ul>\n<li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li>\n<li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li>\n<li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li>\n<li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li>\n</ul>\n<h3 id=\"简述-tcp-和-udp的区别\"><a class=\"anchor\" href=\"#简述-tcp-和-udp的区别\">#</a> 简述 tcp 和 udp 的区别？</h3>\n<p><strong>tcp</strong> 和 <strong>udp</strong> 是 OSI 模型中的运输层中的协议。</p>\n<p><strong>tcp</strong> 提供可靠的通信传输    <strong>udp</strong> 则常被用于让广播和细节控制交给应用的通信传输。</p>\n<p>两者的区别大致如下：</p>\n<ul>\n<li>tcp <strong>面向连接</strong>，udp <strong>面向非连接</strong>即发送数据前不需要建立链接；</li>\n<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>\n<li>tcp 面向字节流，udp 面向报文；</li>\n<li>tcp 数据传输慢，udp 数据传输快；</li>\n</ul>\n<h3 id=\"tcp三次握手\"><a class=\"anchor\" href=\"#tcp三次握手\">#</a> tcp 三次握手</h3>\n<p>第一次</p>\n<p>第一次握手：建立连接时，客户端  发送<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4=\"> syn</span> 包（seq=j）到  服务器，并进入 SYN_SENT 状态，等待  服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 [3]</p>\n<p>第二次</p>\n<p>第二次握手：服务器  收到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4=\"> syn</span> 包，必须确认  客户端  的 SYN（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=\">ack</span>=j+1），同时自己也发送一个 SYN 包（seq=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。 [3]</p>\n<p>第三次</p>\n<p>第三次握手：客户端  收到  服务器  的 SYN+ACK 包，向  服务器  发送确认包 ACK (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=\">ack</span>=k+1），此包发送完毕，客户端和服务器进入<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9FU1RBQkxJU0hFRA==\"> ESTABLISHED</span>（TCP 连接成功）状态，完成三次握手。</p>\n<h3 id=\"为什么要三次握手两次不行吗为什么\"><a class=\"anchor\" href=\"#为什么要三次握手两次不行吗为什么\">#</a> 为什么要三次握手，两次不行吗？为什么？</h3>\n<p>如果采用两次握手，那么只要<strong>服务器</strong>发出确认数据包就会建立连接，但由于<strong>客户端</strong>此时并未响应服务器端的请求，那此时<strong>服务器端</strong>就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。</p>\n<p>若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "Java基础"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/MySQL/",
            "url": "https://www.baocai-blog.cn/2020/10/13/MySQL/",
            "title": "MySQL",
            "date_published": "2020-10-13T13:43:55.195Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"mysql\"><a class=\"anchor\" href=\"#mysql\">#</a> MySQL</h1>\n<h2 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h2>\n<h3 id=\"数据库的三范式是什么\"><a class=\"anchor\" href=\"#数据库的三范式是什么\">#</a> 数据库的三范式是什么？</h3>\n<ul>\n<li>第一范式：强调的是原子性，即数据库表的每一列都是不可分割的原子数据项。</li>\n<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>\n<li>第三范式：任何非主属性不依赖于其它非主属性。</li>\n</ul>\n<h3 id=\"mysql-的内连接-左连接-右连接有什么区别\"><a class=\"anchor\" href=\"#mysql-的内连接-左连接-右连接有什么区别\">#</a> MySQL 的内连接、左连接、右连接有什么区别？</h3>\n<p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>\n<p>内连接是把匹配的关联数 据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>\n<h3 id=\"数据库基本操作语句\"><a class=\"anchor\" href=\"#数据库基本操作语句\">#</a> 数据库基本操作语句</h3>\n<p>主键约束 (primary key)  唯一约束 (unique) 非空约束 (not null) 外键约束 (foreign key)</p>\n<p><strong>select</strong> ... from 表名  where 条件  group by  分组字段  having 条件  order by  排序字段 ase|desc</p>\n<p>去重操作<strong> distinct</strong>             select distinct 字段名，字段名 2 from 表名</p>\n<p><strong>insert  into  &lt;表名&gt;  [列名]  values  &lt; 列值 &gt;                delete  from  &lt; 表名 &gt;  where  &lt; 删除条件 &gt;</strong>**</p>\n<p><strong>update 表名 set  字段名 = 字段值，字段名 = 字段值   [where 修改条件];</strong></p>\n<h2 id=\"数据库特性\"><a class=\"anchor\" href=\"#数据库特性\">#</a> 数据库特性</h2>\n<h3 id=\"数据库4个特性\"><a class=\"anchor\" href=\"#数据库4个特性\">#</a> 数据库 4 个特性：</h3>\n<ul>\n<li>Atomicity（<strong>原子性</strong>）：事务不可分割、不可约简。</li>\n<li>Consistency（<strong>一致性</strong>）：在事务开始前和事务结束后，<strong>数据库的完整性</strong>没有被破坏。</li>\n<li>Isolation（<strong>隔离性</strong>）：数据库允许多个事务同时对数据处理，隔离性可以<strong>防止</strong>多个事务并发执行时由于交叉执行而<strong>导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>\n<li>Durability（<strong>持久性</strong>）：事务处理结束后，对数据的修改就是永久，不会丢失。</li>\n</ul>\n<h2 id=\"事务隔离\"><a class=\"anchor\" href=\"#事务隔离\">#</a> 事务隔离</h2>\n<h3 id=\"数据库的事务隔离\"><a class=\"anchor\" href=\"#数据库的事务隔离\">#</a> 数据库的事务隔离：</h3>\n<ul>\n<li>\n<p>READ-UNCOMMITTED：<strong>未提交读</strong>，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p>\n</li>\n<li>\n<p>READ-COMMITTED：<strong>提交读</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p>\n</li>\n<li>\n<p>REPEATABLE-READ：<strong>可重复读</strong>，<strong>默认</strong>级别，保证多次读取同一个数据，值和内容一致。禁止读取到别的事务未提交的数据（会造成幻读）。</p>\n</li>\n<li>\n<p>SERIALIZABLE：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>\n<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。<strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>\n</li>\n</ul>\n<h2 id=\"分页查询\"><a class=\"anchor\" href=\"#分页查询\">#</a> 分页查询</h2>\n<h3 id=\"oracle页查询\"><a class=\"anchor\" href=\"#oracle页查询\">#</a> <strong>Oracle 页查询</strong></h3>\n<p>Oracle 中使用 rownum 来进行分页，</p>\n<p>select * from    ( select rownum r,a from tabName where rownum &lt;= 20 )  where r &gt; 10</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/MyBatis/",
            "url": "https://www.baocai-blog.cn/2020/10/13/MyBatis/",
            "title": "MyBatis",
            "date_published": "2020-10-13T13:17:48.784Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"mybatis\"><a class=\"anchor\" href=\"#mybatis\">#</a> MyBatis</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是mybatis\"><a class=\"anchor\" href=\"#什么是mybatis\">#</a> 什么是 MyBatis</h3>\n<p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</p>\n<h3 id=\"mybatis优点\"><a class=\"anchor\" href=\"#mybatis优点\">#</a> MyBatis 优点</h3>\n<ol>\n<li>基于 SQL 语句，灵活</li>\n<li>降低代码量</li>\n<li>与数据库兼容</li>\n<li>与 Spring 集成</li>\n</ol>\n<h2 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h2>\n<h3 id=\"mybatis缓存\"><a class=\"anchor\" href=\"#mybatis缓存\">#</a> MyBatis 缓存</h3>\n<p>MyBatis 的缓存分为一级缓存和二级存，一级缓存放在 session 里面，默认就有，二级缓 存放在它的命名空间里，默认是不打开的，使用二级缓存属性类需要实现 Serializable 序列化 接口 (可用来保存对象的状态), 可在它的映射文件中配置 &lt; cache/&gt;</p>\n<h3 id=\"mybatis分页\"><a class=\"anchor\" href=\"#mybatis分页\">#</a> MyBatis 分页</h3>\n<ul>\n<li>\n<p>分页方式：Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。</p>\n</li>\n<li>\n<p>分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦 截待执行的 sql，然后重写 sql</p>\n</li>\n</ul>\n<h3 id=\"和的区别是什么\"><a class=\"anchor\" href=\"#和的区别是什么\">#</a> #{} 和 ${} 的区别是什么？</h3>\n<ol>\n<li>\n<p>#{} 是预编译处理，${} 是字符串替换。</p>\n</li>\n<li>\n<p>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为？号，调用 PreparedStatement 的 set 方法 来赋值；</p>\n</li>\n<li>\n<p>Mybatis 在处理<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow></mrow><mtext>时，就是把</mtext></mrow><annotation encoding=\"application/x-tex\">{}时，就是把</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">就</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">把</span></span></span></span> {} 替换成变量的值。</p>\n</li>\n<li>\n<p>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性</p>\n</li>\n</ol>\n<h3 id=\"mybatis编程步骤\"><a class=\"anchor\" href=\"#mybatis编程步骤\">#</a> Mybatis 编程步骤</h3>\n<ol>\n<li>创建 SqlSessionFactory</li>\n<li>通过 SqlSessionFactory 创建 SqlSession</li>\n<li>通过 sqlsession 执行数据库操作</li>\n<li>调用 session.commit () 提交事务</li>\n<li>调用 session.close () 关闭会话</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/Spring/",
            "url": "https://www.baocai-blog.cn/2020/10/13/Spring/",
            "title": "Spring",
            "date_published": "2020-10-13T13:01:03.426Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"spring\"><a class=\"anchor\" href=\"#spring\">#</a> Spring</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是spring\"><a class=\"anchor\" href=\"#什么是spring\">#</a> 什么是 Spring</h3>\n<p>Spring 是个 java 企业级应用的开源开发框架。Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</p>\n<h2 id=\"aop\"><a class=\"anchor\" href=\"#aop\">#</a> AOP</h2>\n<h3 id=\"什么是aop\"><a class=\"anchor\" href=\"#什么是aop\">#</a> 什么是 AOP</h3>\n<p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>\n<h2 id=\"ioc\"><a class=\"anchor\" href=\"#ioc\">#</a> IOC</h2>\n<h3 id=\"什么是ioc\"><a class=\"anchor\" href=\"#什么是ioc\">#</a> 什么是 IOC</h3>\n<ul>\n<li>IOC 容器负责实例化、配置程序中的对象及建立对象间的依赖。\"控制反转\" 是指 new 实例工作交给 Spring 容器来做。</li>\n<li>所谓 IoC (控制反转)，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</li>\n</ul>\n<h3 id=\"ioc优点\"><a class=\"anchor\" href=\"#ioc优点\">#</a> IOC 优点</h3>\n<ol>\n<li>降低代码量</li>\n<li>易于测试</li>\n<li>轻松实现耦合</li>\n<li>支持饿汉式初始化和懒加载</li>\n</ol>\n<h2 id=\"依赖\"><a class=\"anchor\" href=\"#依赖\">#</a> 依赖</h2>\n<h3 id=\"什么是依赖注入\"><a class=\"anchor\" href=\"#什么是依赖注入\">#</a> 什么是依赖注入</h3>\n<p>spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。</p>\n<h3 id=\"依赖注入方式\"><a class=\"anchor\" href=\"#依赖注入方式\">#</a> 依赖注入方式</h3>\n<ul>\n<li>setter 属性注入</li>\n<li>构造方法注入</li>\n<li>接口注入</li>\n</ul>\n<h2 id=\"特性\"><a class=\"anchor\" href=\"#特性\">#</a> 特性</h2>\n<h3 id=\"spring优点\"><a class=\"anchor\" href=\"#spring优点\">#</a> Spring 优点</h3>\n<ol>\n<li>\n<p>方便解耦 ——Spring 提供的 IoC 容器实现了对象依赖关系的管理，避免了硬编码导致的耦合。</p>\n</li>\n<li>\n<p>支持 AOP——Spring 提供的 AOP 功能，方便进行面向切面编程。</p>\n</li>\n<li>\n<p>集成了多种优秀框架 ——Spring 提供了对各种优秀框架（如 Struts、Hibernate、Hessian、Quartz 等）的直接支持。</p>\n</li>\n<li>\n<p>降低对 API 依赖</p>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/SpringMVC/",
            "url": "https://www.baocai-blog.cn/2020/10/13/SpringMVC/",
            "title": "SpringMVC",
            "date_published": "2020-10-13T12:08:53.439Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"springmvc\"><a class=\"anchor\" href=\"#springmvc\">#</a> SpringMVC</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是springmvc\"><a class=\"anchor\" href=\"#什么是springmvc\">#</a> 什么是 SpringMVC</h3>\n<p>SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。 简化开发，减少出错。</p>\n<h2 id=\"特性\"><a class=\"anchor\" href=\"#特性\">#</a> 特性</h2>\n<h3 id=\"springmvc的优点\"><a class=\"anchor\" href=\"#springmvc的优点\">#</a> SpringMVC 的优点</h3>\n<ol>\n<li>\n<p>它是基于组件技术的。全部的应用对象，无论控制器和视图，还是业务对象之类的都是 java 组件。并且和 Spring 提供的其他基础结构紧密集成.</p>\n</li>\n<li>\n<p>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的)</p>\n</li>\n<li>\n<p>可以任意使用各种视图技术，而不仅仅局限于 JSP</p>\n</li>\n<li>\n<p>支持各种请求资源的映射策略</p>\n</li>\n<li>\n<p>它应是易于扩展的</p>\n</li>\n</ol>\n<h2 id=\"工作原理\"><a class=\"anchor\" href=\"#工作原理\">#</a> 工作原理</h2>\n<h3 id=\"springmvc的工作原理\"><a class=\"anchor\" href=\"#springmvc的工作原理\">#</a> SpringMVC 的工作原理</h3>\n<ol>\n<li>\n<p>客户端发送请求 DispatcherServlet</p>\n</li>\n<li>\n<p>DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller</p>\n</li>\n<li>\n<p>Controller 调用业务逻辑后，返回 ModelAndView</p>\n</li>\n<li>\n<p>DispatcherServlet 查询 ModelAndView，找到指定视图</p>\n</li>\n<li>\n<p>视图将结果返回到客户端</p>\n</li>\n</ol>\n<h3 id=\"springmvc常用注解\"><a class=\"anchor\" href=\"#springmvc常用注解\">#</a> SpringMVC 常用注解</h3>\n<ol>\n<li>\n<p>@requestMapping 用于请求 url 映射。</p>\n</li>\n<li>\n<p>@RequestBody 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。</p>\n</li>\n<li>\n<p>@ResponseBody 注解实现将 controller 方法返回对象转化为 json 响应给客户。</p>\n</li>\n</ol>\n<h2 id=\"常见问题\"><a class=\"anchor\" href=\"#常见问题\">#</a> 常见问题</h2>\n<h3 id=\"如何解决getpost乱码\"><a class=\"anchor\" href=\"#如何解决getpost乱码\">#</a> 如何解决 get/post 乱码</h3>\n<ul>\n<li>解决 post 请求乱码：我们可以在 web.xml 里边配置一个 CharacterEncodingFilter 过滤器。 设置为 utf-8，解决 get 请求的乱码：有两种方法。</li>\n<li>get 请求中文参数出现乱码解决方法有两个:</li>\n</ul>\n<ol>\n<li>\n<p>修改 tomcat 配置文件添加编码与工程编码一致。</p>\n</li>\n<li>\n<p>另 外 一 种 方 法 对 参 数 进 行 重 新 编 码 String userName = New String (Request.getParameter (“userName”).getBytes (“ISO8859-1”), “utf-8”);</p>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "url": "https://www.baocai-blog.cn/2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "title": "Java基础语法",
            "date_published": "2020-10-10T04:45:31.957Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"java基础语法\"><a class=\"anchor\" href=\"#java基础语法\">#</a> JAVA 基础语法</h1>\n<h2 id=\"基础语法\"><a class=\"anchor\" href=\"#基础语法\">#</a> 基础语法</h2>\n<h3 id=\"运算符\"><a class=\"anchor\" href=\"#运算符\">#</a> 运算符</h3>\n<p>算数运算符、关系运算符、赋值运算符、逻辑运算符、三目运算符</p>\n<h3 id=\"数据类型\"><a class=\"anchor\" href=\"#数据类型\">#</a> 数据类型</h3>\n<h4 id=\"基本数据类型\"><a class=\"anchor\" href=\"#基本数据类型\">#</a> 基本数据类型</h4>\n<ul>\n<li>byte、short、int、long</li>\n<li>float、double、char</li>\n<li>boolean</li>\n</ul>\n<h4 id=\"引用数据类型\"><a class=\"anchor\" href=\"#引用数据类型\">#</a> 引用数据类型</h4>\n<ul>\n<li>class</li>\n<li>interface</li>\n<li>数组</li>\n</ul>\n<h2 id=\"流程控制\"><a class=\"anchor\" href=\"#流程控制\">#</a> 流程控制</h2>\n<h3 id=\"if\"><a class=\"anchor\" href=\"#if\">#</a> if</h3>\n<p>if 条件结构是根据条件判断之后再做处理</p>\n<h3 id=\"switch\"><a class=\"anchor\" href=\"#switch\">#</a> switch</h3>\n<ul>\n<li>\n<p>switch (表达式){</p>\n<p>case 取值 1: 语句块 1;break;<br>\ncase 取值 n: 语句块 n;break; \t\t<br>\ndefault: 语句块 n+1;break;<br>\n}</p>\n</li>\n<li>\n<p>switch 语句有关规则 表达式的返回值必须是下述几种类型之一：int,byte,char,short,String；</p>\n</li>\n<li>\n<p>case 子句中的取值必须是常量，且所有 case 子句中的取值应是不同的；</p>\n</li>\n</ul>\n<h3 id=\"while\"><a class=\"anchor\" href=\"#while\">#</a> while</h3>\n<ul>\n<li>while 循环<br>\n符合条件，循环继续执行；否则，循环退出<br>\n特点：先判断，再执行</li>\n<li>do-while 循环<br>\n先执行一遍循环操作，符合条件，循环继续执行；否则，循环退出<br>\n特点：先执行，再判断</li>\n</ul>\n<h3 id=\"for\"><a class=\"anchor\" href=\"#for\">#</a> for</h3>\n<p>语法：<br>\nfor (初始化参数；判断条件；更新循环变量){<br>\n循环体；<br>\n}</p>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<h3 id=\"冒泡排序\"><a class=\"anchor\" href=\"#冒泡排序\">#</a> 冒泡排序</h3>\n<p>原理：</p>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的</li>\n</ul>\n<h3 id=\"二分查找\"><a class=\"anchor\" href=\"#二分查找\">#</a> 二分查找</h3>\n<p>二分查找也叫折半查找，是一种基本的查找算法，需要待查的表满足两个条件：</p>\n<ol>\n<li>\n<p>查找表必须使用顺序的存储结构</p>\n</li>\n<li>\n<p>查找表必须按关键字大小有序排列</p>\n</li>\n</ol>\n<p>算法的基本思想是：</p>\n<ul>\n<li>\n<p>将查找表中间位置数据元素的关键字与给定关键字比较，如果相等则查找成功；</p>\n</li>\n<li>\n<p>否则利用中间元素将表一分为二，如果中间关键字大于给定关键字，则在前一子表中进行折半查找，否则在后一子表中进行折半查找。</p>\n</li>\n<li>\n<p>重复以上过程直到找到满足条件的元素，则查找成功；或直到子表为空为止，此时查找不成功。</p>\n</li>\n</ul>\n<p>二分查找递归写法：</p>\n<pre><code>public int firstOccurrence (int [] nums,int target){\n    int low = 0,high = nums.length - 1;\n    while(low &lt;=  high){   \n        int mid = low + (high-low)/2;\n        if(nums[mid] == target){\n            return mid;\n        }\n        if(nums[mid] &lt; target){\n            low = mid+1;\n        }else {\n            high = mid-1;\n        }\n    }\n    return -1;\n}\n</code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "Java基础"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "url": "https://www.baocai-blog.cn/2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "title": "面向对象",
            "date_published": "2020-10-10T04:42:25.431Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"面向对象\"><a class=\"anchor\" href=\"#面向对象\">#</a> 面向对象</h1>\n<h2 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h2>\n<h3 id=\"类与对象\"><a class=\"anchor\" href=\"#类与对象\">#</a> 类与对象</h3>\n<ul>\n<li>对象：对象是类的实例</li>\n<li>类：类是一个模板，描述一类对象的行为和状态</li>\n</ul>\n<h3 id=\"构造方法\"><a class=\"anchor\" href=\"#构造方法\">#</a> 构造方法</h3>\n<ul>\n<li>用于对象初始化。</li>\n<li>构造方法的名称必须与类同名，一个类可以有多个构造方法。</li>\n</ul>\n<h3 id=\"方法重载方法重写\"><a class=\"anchor\" href=\"#方法重载方法重写\">#</a> 方法重载 / 方法重写</h3>\n<ul>\n<li>重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。子类可以根据需要，定义特定于自己的行为。</li>\n<li>重载：重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li>\n</ul>\n<h2 id=\"高级\"><a class=\"anchor\" href=\"#高级\">#</a> 高级</h2>\n<h3 id=\"final关键字\"><a class=\"anchor\" href=\"#final关键字\">#</a> final 关键字</h3>\n<ol>\n<li>\n<p>final 修饰的类叫最终类，该类不能被继承。</p>\n</li>\n<li>\n<p>final 修饰的方法不能被重写。</p>\n</li>\n<li>\n<p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改</p>\n</li>\n</ol>\n<h3 id=\"抽象类\"><a class=\"anchor\" href=\"#抽象类\">#</a> 抽象类</h3>\n<ol>\n<li>\n<p>抽象类不能被实例化</p>\n</li>\n<li>\n<p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>\n</li>\n<li>\n<p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p>\n</li>\n<li>\n<p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p>\n</li>\n<li>\n<p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p>\n</li>\n</ol>\n<h3 id=\"接口\"><a class=\"anchor\" href=\"#接口\">#</a> 接口</h3>\n<p>接口是抽象方法的集合<br>\n定义格式：<br>\ninterface 接口名称 { &nbsp; &nbsp; &nbsp;<br>\n全局常量；&nbsp; &nbsp; &nbsp;<br>\n抽象方法；&nbsp;<br>\n}<br>\n 接口和抽象类的区别：</p>\n<ol>\n<li>\n<p>抽象类要被子类继承，接口要被类实现。</p>\n</li>\n<li>\n<p>接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。</p>\n</li>\n<li>\n<p>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p>\n</li>\n<li>\n<p>抽象类使用继承来使用，无法多继承。接口使用实现来使用，可以多实现</p>\n</li>\n<li>\n<p>抽象类中可以包含 static 方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明 静态方法）</p>\n</li>\n<li>\n<p>接口不能有构造方法，但是抽象类可以有</p>\n</li>\n</ol>\n<h3 id=\"equals\"><a class=\"anchor\" href=\"#equals\">#</a> equals</h3>\n<h3 id=\"内部类\"><a class=\"anchor\" href=\"#内部类\">#</a> 内部类</h3>\n<h4 id=\"成员内部类\"><a class=\"anchor\" href=\"#成员内部类\">#</a> 成员内部类</h4>\n<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>\n<pre><code>class Outer { &nbsp; &nbsp;\n\tprivate double x = 0; &nbsp; &nbsp;\n\tpublic Outer(double x) { \n\tthis.x = x; \n    } &nbsp; &nbsp;  &nbsp; &nbsp;\nclass Inner { &nbsp; //内部类 &nbsp; &nbsp; &nbsp;\n\tpublic void say() {\n    \tSystem.out.println(\"x=\"+x);&nbsp;  \n    } &nbsp;\n} \n}\n</code></pre>\n<p>特点： 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。</p>\n<h4 id=\"局部内部类\"><a class=\"anchor\" href=\"#局部内部类\">#</a> 局部内部类</h4>\n<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限 于方法内或者该作用域内。<br>\n例如：</p>\n<pre><code>\tclass Person{ &nbsp;  \n\t\tpublic Person() {\n\t\t}  \n    }&nbsp;  \n    class Man{ &nbsp; &nbsp; &nbsp;  \n    \tpublic Man(){\n &nbsp; &nbsp; &nbsp;  }\n &nbsp; &nbsp; &nbsp; &nbsp;public People getPerson(){         \n        \tclass Student extends People{        \n        \t  //局部内部类 \n       \t\t  int age =0; &nbsp;  \n       \t\t} &nbsp;      \n        return new Student(); &nbsp;   \n        }   \n    }\n</code></pre>\n<h4 id=\"匿名内部类\"><a class=\"anchor\" href=\"#匿名内部类\">#</a> 匿名内部类</h4>\n<p>new 父类构造器（参数列表）| 实现接口（） { &nbsp; &nbsp; &nbsp;<br>\n// 匿名内部类的类体部分<br>\n}</p>\n<h4 id=\"静态内部类\"><a class=\"anchor\" href=\"#静态内部类\">#</a> 静态内部类</h4>\n<p>静态内部类是不需要依赖于外部类对象的，并且它不能使用外部类的非 static 成员变量或者方法.<br>\n 格式：</p>\n<pre><code>public class Test { &nbsp; \n\tpublic static void main(String[] args)  { &nbsp; &nbsp; &nbsp; \n\t\tOutter.Inner inner = new Outter.Inner(); &nbsp; \n\t} \n}\n \nclass Outter { &nbsp; &nbsp;\n\tpublic Outter() { &nbsp;\n  \t} &nbsp; &nbsp;  &nbsp; &nbsp;\nstatic class Inner { &nbsp; &nbsp; &nbsp; &nbsp;\n\tpublic Inner() { &nbsp; &nbsp; &nbsp; \n    } &nbsp; \n} \n}\n</code></pre>\n<h2 id=\"进阶\"><a class=\"anchor\" href=\"#进阶\">#</a> 进阶</h2>\n<h3 id=\"封装\"><a class=\"anchor\" href=\"#封装\">#</a> 封装</h3>\n<p>private 修饰变量<br>\n Getter/Setter</p>\n<h3 id=\"this\"><a class=\"anchor\" href=\"#this\">#</a> this</h3>\n<p>使用 this 关键字可以完成以下的操作：</p>\n<ul>\n<li>调用类中的属性</li>\n<li>调用类中的方法或构造方法</li>\n<li>表示当前对象</li>\n</ul>\n<h3 id=\"static\"><a class=\"anchor\" href=\"#static\">#</a> static</h3>\n<p>static 表示 “静态” 的意思，可以用来修饰成员变量和成员方法<br>\n重点：</p>\n<ol>\n<li>\n<p>静态成员 在类加载时加载并初始化。</p>\n</li>\n<li>\n<p>无论一个类存在多少个对象，静态的属性，永远在内存中只有一份</p>\n</li>\n<li>\n<p>在访问时： 静态不能访问非静态，非静态可以访问静态！</p>\n</li>\n</ol>\n<h2 id=\"异常处理\"><a class=\"anchor\" href=\"#异常处理\">#</a> 异常处理</h2>\n<h3 id=\"try-catch\"><a class=\"anchor\" href=\"#try-catch\">#</a> try&nbsp; catch</h3>\n<ul>\n<li>异常指的是 Exception，Exception 类，在 Java 中存在一个父 Throwable（可能的抛出）</li>\n<li>Throwable 存在两个子类：\n<ol>\n<li>Error：表示的是错误，是 JVM 发出的错误操作，只能尽量避免，无法用代码处理。</li>\n<li>Exception：一般表示所有程序中的错误，所以一般在程序中将进行 try…catch 的处理。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"throwthrows\"><a class=\"anchor\" href=\"#throwthrows\">#</a> throw/throws</h3>\n<ul>\n<li>throws 关键字：<br>\n此关键字主要在方法的声明上使 用，表示方法中不处理异常，而交给调用处处理。<br>\n格式：<br>\n返回值 方法名称 () throws Exception {<br>\n}</li>\n<li>throw 关键字<br>\n throw 关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出 的就是一个异常类的实例化对象，那么此对象也可以由 throw 直接抛出。<br>\n代码： throw new Exception (\"抛着玩的。\") ;</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "面向对象"
            ]
        }
    ]
}