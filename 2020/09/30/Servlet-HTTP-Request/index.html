<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="手撕包菜"><meta name="renderer" content="webkit"><meta name="copyright" content="手撕包菜"><meta name="keywords" content="手撕包菜"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Servlet-HTTP-Request · Baocai's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/myfavicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="手撕包菜" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">手撕包菜</div><div class="profile-signature">for me</div><div class="friends"><div>FRIENDS</div><span><a href="//github.com/Longlongyu" target="_black">friendA</a></span><span><a href="//github.com/" target="_black">friendB</a></span><span><a href="//github.com/" target="_black">friendC</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Baocai's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Servlet-HTTP-Request</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2020-10-03 10:57:55</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="JavaWeb"> JavaWeb</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">2.4k</span> | Reading time: <span class="post-count">10</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="目录"><a class="markdownIt-Anchor" href="#目录">#</a> 目录：</h1>
<ol>
<li>Servlet</li>
<li>HTTP 协议</li>
<li>Request</li>
</ol>
<h2 id="servlet"><a class="markdownIt-Anchor" href="#servlet">#</a> Servlet：</h2>
<ol>
<li>
<p>概念</p>
</li>
<li>
<p>步骤</p>
</li>
<li>
<p>执行原理</p>
</li>
<li>
<p>生命周期</p>
</li>
<li>
<p>Servlet3.0 注解配置</p>
</li>
<li>
<p>Servlet 的体系结构	<br>
Servlet – 接口<br>
 |<br>
GenericServlet – 抽象类<br>
 |<br>
HttpServlet  – 抽象类</p>
<ul>
<li>
<p>GenericServlet：将 Servlet 接口中其他的方法做了默认空实现，只将 service () 方法作为抽象</p>
<ul>
<li>将来定义 Servlet 类时，可以继承 GenericServlet，实现 service () 方法即可</li>
</ul>
</li>
<li>
<p>HttpServlet：对 http 协议的一种封装，简化操作</p>
<ol>
<li>定义类继承 HttpServlet</li>
<li>复写 doGet/doPost 方法</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Servlet 相关配置</p>
<ol>
<li>urlpartten:Servlet 访问路径
<ol>
<li>一个 Servlet 可以定义多个访问路径 ： @WebServlet ({"/d4","/dd4","/ddd4"})</li>
<li>路径定义规则：
<ol>
<li>/xxx：路径匹配</li>
<li>/xxx/xxx: 多层路径，目录结构</li>
<li>*.do：扩展名匹配</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="http"><a class="markdownIt-Anchor" href="#http">#</a> HTTP：</h2>
<ul>
<li>
<p>概念：Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li>
<p>传输协议：定义了，客户端和服务器端通信时，发送数据的格式</p>
</li>
<li>
<p>特点：</p>
<ol>
<li>基于 TCP/IP 的高级协议</li>
<li>默认端口号：80</li>
<li>基于请求 / 响应模型的：一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
</li>
<li>
<p>历史版本：</p>
<ul>
<li>1.0：每一次请求响应都会建立新的连接</li>
<li>1.1：复用连接</li>
</ul>
</li>
</ul>
</li>
<li>
<p>请求消息数据格式</p>
<ol>
<li>
<p>请求行<br>
请求方式 请求 url 请求协议 / 版本<br>
 GET /login.html	HTTP/1.1</p>
<ul>
<li>请求方式：
<ul>
<li>HTTP 协议有 7 中请求方式，常用的有 2 种
<ul>
<li>GET：
<ol>
<li>请求参数在请求行中，在 url 后。</li>
<li>请求的 url 长度有限制的</li>
<li>不太安全</li>
</ol>
</li>
<li>POST：
<ol>
<li>请求参数在请求体中</li>
<li>请求的 url 长度没有限制的</li>
<li>相对安全</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>请求头：客户端浏览器告诉服务器一些信息<br>
请求头名称：请求头值</p>
<ul>
<li>常见的请求头：
<ol>
<li>
<p>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息</p>
<ul>
<li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li>
</ul>
</li>
<li>
<p>Referer：<a target="_blank" rel="noopener" href="http://localhost/login.html">http://localhost/login.html</a></p>
<ul>
<li>告诉服务器，我 (当前请求) 从哪里来？
<ul>
<li>作用：
<ol>
<li>防盗链：</li>
<li>统计工作：</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>请求空行<br>
空行，就是用于分割 POST 请求的请求头，和请求体的。</p>
</li>
<li>
<p>请求体 (正文)：</p>
<ul>
<li>封装 POST 请求消息的请求参数的</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>字符串格式：<br>
POST /login.html	HTTP/1.1<br>
Host: localhost<br>
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0<br>
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br>
Accept-Encoding: gzip, deflate<br>
Referer: <a target="_blank" rel="noopener" href="http://localhost/login.html">http://localhost/login.html</a><br>
Connection: keep-alive<br>
Upgrade-Insecure-Requests: 1</p>
<p>username=zhangsan</p>
</li>
</ul>
</li>
<li>
<p>响应消息数据格式</p>
</li>
</ul>
<h2 id="request"><a class="markdownIt-Anchor" href="#request">#</a> Request：</h2>
<ol>
<li>
<p>request 对象和 response 对象的原理</p>
<ol>
<li>request 和 response 对象是由服务器创建的。我们来使用它们</li>
<li>request 对象是来获取请求消息，response 对象是来设置响应消息</li>
</ol>
</li>
<li>
<p>request 对象继承体系结构：	<br>
ServletRequest		–	接口<br>
 |	继承<br>
 HttpServletRequest	– 接口<br>
 |	实现<br>
 org.apache.catalina.connector.RequestFacade 类 (tomcat)</p>
</li>
<li>
<p>request 功能：</p>
<ol>
<li>获取请求消息数据
<ol>
<li>
<p>获取请求行数据</p>
<ul>
<li>GET /day14/demo1?name=zhangsan HTTP/1.1</li>
<li>方法：
<ol>
<li>
<p>获取请求方式 ：GET</p>
<ul>
<li>String getMethod()</li>
</ul>
</li>
<li>
<p>(*) 获取虚拟目录：/day14</p>
<ul>
<li>String getContextPath()</li>
</ul>
</li>
<li>
<p>获取 Servlet 路径: /demo1</p>
<ul>
<li>String getServletPath()</li>
</ul>
</li>
<li>
<p>获取 get 方式请求参数：name=zhangsan</p>
<ul>
<li>String getQueryString()</li>
</ul>
</li>
<li>
<p>(*) 获取请求 URI：/day14/demo1</p>
<ul>
<li>
<p>String getRequestURI():		/day14/demo1</p>
</li>
<li>
<p>StringBuffer getRequestURL()  :<a target="_blank" rel="noopener" href="http://localhost/day14/demo1">http://localhost/day14/demo1</a></p>
</li>
<li>
<p>URL: 统一资源定位符 ： <a target="_blank" rel="noopener" href="http://localhost/day14/demo1">http://localhost/day14/demo1</a>	中华人民共和国</p>
</li>
<li>
<p>URI：统一资源标识符 : /day14/demo1					共和国</p>
</li>
</ul>
</li>
<li>
<p>获取协议及版本：HTTP/1.1</p>
<ul>
<li>String getProtocol()</li>
</ul>
</li>
<li>
<p>获取客户机的 IP 地址：</p>
<ul>
<li>String getRemoteAddr()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>获取请求头数据</p>
<ul>
<li>方法：
<ul>
<li>(*) String getHeader (String name): 通过请求头的名称获取请求头的值</li>
<li>Enumeration<string> getHeaderNames (): 获取所有的请求头名称</string></li>
</ul>
</li>
</ul>
</li>
<li>
<p>获取请求体数据:</p>
<ul>
<li>请求体：只有 POST 请求方式，才有请求体，在请求体中封装了 POST 请求的请求参数</li>
<li>步骤：
<ol>
<li>
<p>获取流对象</p>
<ul>
<li>BufferedReader getReader ()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream ()：获取字节输入流，可以操作所有类型数据
<ul>
<li>在文件上传知识点后讲解</li>
</ul>
</li>
</ul>
</li>
<li>
<p>再从流对象中拿数据</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​				<br>
​	2. 其他功能：<br>
​		1. 获取请求参数通用方式：不论 get 还是 post 请求方式都可以使用下列方法来获取请求参数<br>
​			1. String getParameter (String name): 根据参数名称获取参数值    username=zs&amp;password=123<br>
​			2. String [] getParameterValues (String name): 根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game<br>
​			3. Enumeration<string> getParameterNames (): 获取所有请求的参数名称<br>
​			4. Map&lt;String,String []&gt; getParameterMap (): 获取所有参数的 map 集合</string></p>
<pre><code>		* 中文乱码问题：
			* get方式：tomcat 8 已经将get方式乱码问题解决了
			* post方式：会乱码
				* 解决：在获取参数前，设置request的编码request.setCharacterEncoding("utf-8");
</code></pre>
<p>​					<br>
​		2. 请求转发：一种在服务器内部的资源跳转方式<br>
​			1. 步骤：<br>
​				1. 通过 request 对象获取请求转发器对象：RequestDispatcher getRequestDispatcher (String path)<br>
​				2. 使用 RequestDispatcher 对象来进行转发：forward (ServletRequest request, ServletResponse response)</p>
<pre><code>		2. 特点：
			1. 浏览器地址栏路径不发生变化
			2. 只能转发到当前服务器内部资源中。
			3. 转发是一次请求
</code></pre>
<h2 id="案例用户登录"><a class="markdownIt-Anchor" href="#案例用户登录">#</a> 案例：用户登录</h2>
<ul>
<li>
<p>用户登录案例需求：<br>
1. 编写 login.html 登录页面<br>
 username &amp; password 两个输入框<br>
 2. 使用 Druid 数据库连接池技术，操作 mysql，day14 数据库中 user 表<br>
 3. 使用 JdbcTemplate 技术封装 JDBC<br>
4. 登录成功跳转到 SuccessServlet 展示：登录成功！用户名，欢迎您<br>
 5. 登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误</p>
</li>
<li>
<p>分析</p>
</li>
<li>
<p>开发步骤</p>
<ol>
<li>
<p>创建项目，导入 html 页面，配置文件，jar 包</p>
</li>
<li>
<p>创建数据库环境<br>
 CREATE DATABASE day14;<br>
USE day14;<br>
CREATE TABLE USER(</p>
<p>​	id INT PRIMARY KEY AUTO_INCREMENT,<br>
​	username VARCHAR(32) UNIQUE NOT NULL,<br>
​	PASSWORD VARCHAR(32) NOT NULL<br>
);</p>
</li>
<li>
<p>创建包 cn.itcast.domain, 创建类 User<br>
package cn.itcast.domain;<br>
/**</p>
<ul>
<li>
<p>用户的实体类<br>
 */<br>
public class User {</p>
<p>private int id;<br>
private String username;<br>
private String password;</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>​</p>
<p>​		    public int getId() {<br>
​		        return id;<br>
​		    }<br>
​		<br>
​		    public void setId(int id) {<br>
​		        <a target="_blank" rel="noopener" href="http://this.id">this.id</a> = id;<br>
​		    }<br>
​		<br>
​		    public String getUsername() {<br>
​		        return username;<br>
​		    }<br>
​		<br>
​		    public void setUsername(String username) {<br>
​		        this.username = username;<br>
​		    }<br>
​		<br>
​		    public String getPassword() {<br>
​		        return password;<br>
​		    }<br>
​		<br>
​		    public void setPassword(String password) {<br>
​		        this.password = password;<br>
​		    }<br>
​		<br>
​		    @Override<br>
​		    public String toString() {<br>
​		        return “User{” +<br>
​		                “id=” + id +<br>
​		                “, username=’” + username + ‘’’ +<br>
​		                “, password=’” + password + ‘’’ +<br>
​		                ‘}’;<br>
​		    }<br>
​		}</p>
<pre><code>4. 创建包cn.itcast.util,编写工具类JDBCUtils
	package cn.itcast.util;

​	import com.alibaba.druid.pool.DruidDataSourceFactory;
​	
​	import javax.sql.DataSource;
​	import javax.xml.crypto.Data;
​	import java.io.IOException;
​	import java.io.InputStream;
​	import java.sql.Connection;
​	import java.sql.SQLException;
​	import java.util.Properties;
​	
​	/**
	 * JDBC工具类 使用Durid连接池
	 */
	public class JDBCUtils {
	
	​    private static DataSource ds ;
	
	​    static {
	
	​        try {
	​            //1.加载配置文件
	​            Properties pro = new Properties();
	​            //使用ClassLoader加载配置文件，获取字节输入流
	​            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");
	​            pro.load(is);
	
	​            //2.初始化连接池对象
	​            ds = DruidDataSourceFactory.createDataSource(pro);
	
	​        } catch (IOException e) {
	​            e.printStackTrace();
	​        } catch (Exception e) {
	​            e.printStackTrace();
	​        }
	​    }
	
	​    /**
	     * 获取连接池对象
	          */
	        public static DataSource getDataSource(){
	        return ds;
	        }
</code></pre>
<p>​</p>
<p>​		    /**<br>
​		     * 获取连接 Connection 对象<br>
​		     <em>/<br>
​		    public static Connection getConnection() throws SQLException {<br>
​		        return  ds.getConnection();<br>
​		    }<br>
​		}<br>
​	5. 创建包 cn.itcast.dao, 创建类 UserDao, 提供 login 方法<br>
​		<br>
​		package cn.itcast.dao;<br>
​	<br>
​		import cn.itcast.domain.User;<br>
​		import cn.itcast.util.JDBCUtils;<br>
​		import org.springframework.dao.DataAccessException;<br>
​		import org.springframework.jdbc.core.BeanPropertyRowMapper;<br>
​		import org.springframework.jdbc.core.JdbcTemplate;<br>
​		<br>
​		/</em>*<br>
​		 * 操作数据库中 User 表的类<br>
​		 */<br>
​		public class UserDao {<br>
​		<br>
// 声明 JDBCTemplate 对象共用<br>
 private JdbcTemplate template = new JdbcTemplate (JDBCUtils.getDataSource ());</p>
<pre><code>	    /**
	     * 登录方法
	     * @param loginUser 只有用户名和密码
	     * @return user包含用户全部数据,没有查询到，返回null
	     */
	    public User login(User loginUser){
	        try {
	            //1.编写sql
	            String sql = "select * from user where username = ? and password = ?";
	            //2.调用query方法
	            User user = template.queryForObject(sql,
	                    new BeanPropertyRowMapper&lt;User&gt;(User.class),
	                    loginUser.getUsername(), loginUser.getPassword());
</code></pre>
<p>​</p>
<p>​		            return user;<br>
​		        } catch (DataAccessException e) {<br>
​		            e.printStackTrace ();// 记录日志<br>
​		            return null;<br>
​		        }<br>
​		    }<br>
​		}<br>
​</p>
<pre><code>6. 编写cn.itcast.web.servlet.LoginServlet类
	package cn.itcast.web.servlet;

​	import cn.itcast.dao.UserDao;
​	import cn.itcast.domain.User;
​	
​	import javax.servlet.ServletException;
​	import javax.servlet.annotation.WebServlet;
​	import javax.servlet.http.HttpServlet;
​	import javax.servlet.http.HttpServletRequest;
​	import javax.servlet.http.HttpServletResponse;
​	import java.io.IOException;
</code></pre>
<p>​</p>
<p>​		@WebServlet("/loginServlet")<br>
​		public class LoginServlet extends HttpServlet {</p>
<p>​</p>
<p>​		    @Override<br>
​		    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>
​		        <a target="_blank" rel="noopener" href="//1.xn--d8yz4mshv84b">//1. 设置编码</a><br>
​		        req.setCharacterEncoding (“utf-8”);<br>
​		        <a target="_blank" rel="noopener" href="//2.xn--8nrrb831grng2u5admk">//2. 获取请求参数</a><br>
​		        String username = req.getParameter (“username”);<br>
​		        String password = req.getParameter(“password”);<br>
​		        <a target="_blank" rel="noopener" href="//3.xn--user-ou9gnbx382dmbg">//3. 封装 user 对象</a><br>
​		        User loginUser = new User ();<br>
​		        loginUser.setUsername(username);<br>
​		        loginUser.setPassword(password);<br>
​		<br>
​		        <a target="_blank" rel="noopener" href="//4.xn--UserDaologin-g98y914e5q2aktew64i">//4. 调用 UserDao 的 login 方法</a><br>
​		        UserDao dao = new UserDao ();<br>
​		        User user = dao.login(loginUser);<br>
​		<br>
​		        <a target="_blank" rel="noopener" href="//5.xn--user-zk9fu84h">//5. 判断 user</a><br>
​		        if(user == null){<br>
​		            // 登录失败<br>
​		            req.getRequestDispatcher ("/failServlet").forward (req,resp);<br>
​		        }else{<br>
​		            // 登录成功<br>
​		            // 存储数据<br>
​		            req.setAttribute (“user”,user);<br>
​		            // 转发<br>
​		            req.getRequestDispatcher ("/successServlet").forward (req,resp);<br>
​		        }<br>
​		<br>
​		    }<br>
​		<br>
​		    @Override<br>
​		    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>
​		        this.doGet(req,resp);<br>
​		    }<br>
​		}</p>
<pre><code>7. 编写FailServlet和SuccessServlet类
	@WebServlet("/successServlet")
	public class SuccessServlet extends HttpServlet {
	    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	        //获取request域中共享的user对象
	        User user = (User) request.getAttribute("user");
	
	        if(user != null){
	            //给页面写一句话
	
	            //设置编码
	            response.setContentType("text/html;charset=utf-8");
	            //输出
	            response.getWriter().write("登录成功！"+user.getUsername()+",欢迎您");
	        }
</code></pre>
<p>​</p>
<p>​		    }</p>
<p>​		@WebServlet("/failServlet")<br>
​		public class FailServlet extends HttpServlet {<br>
​		    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>
​		        // 给页面写一句话<br>
​		<br>
​		        // 设置编码<br>
​		        response.setContentType (“text/html;charset=utf-8”);<br>
​		        // 输出<br>
​		        response.getWriter ().write (“登录失败，用户名或密码错误”);<br>
​		<br>
​		    }<br>
​		<br>
​		    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>
​		        this.doPost(request,response);<br>
​		    }<br>
​		}</p>
<pre><code>8. login.html中form表单的action路径的写法
	* 虚拟目录+Servlet的资源路径

9. BeanUtils工具类，简化数据封装
	* 用于封装JavaBean的
	1. JavaBean：标准的Java类
		1. 要求：
			1. 类必须被public修饰
			2. 必须提供空参的构造器
			3. 成员变量必须使用private修饰
			4. 提供公共setter和getter方法
		2. 功能：封装数据

	2. 概念：
		成员变量：
		属性：setter和getter方法截取后的产物
			例如：getUsername() --&gt; Username--&gt; username

	3. 方法：
		1. setProperty()
		2. getProperty()
		3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://www.baocai-blog.cn">手撕包菜</a></p><p> <span>Link:  </span><a href="https://www.baocai-blog.cn/2020/09/30/Servlet-HTTP-Request/">https://www.baocai-blog.cn/2020/09/30/Servlet-HTTP-Request/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2020/09/30/MySQL%E5%A4%9A%E8%A1%A8-%E4%BA%8B%E5%8A%A1/" title="MySQL多表和事务"><span>< PreviousPost</span><br><span class="prevTitle">MySQL多表和事务</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text"> 目录：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#servlet"><span class="toc-number">1.1.</span> <span class="toc-text"> Servlet：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http"><span class="toc-number">1.2.</span> <span class="toc-text"> HTTP：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#request"><span class="toc-number">1.3.</span> <span class="toc-text"> Request：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="toc-number">1.4.</span> <span class="toc-text"> 案例：用户登录</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>