{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"线程\" category",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/09/30/Servlet-HTTP-Request/",
            "url": "https://www.baocai-blog.cn/2020/09/30/Servlet-HTTP-Request/",
            "title": "Servlet-HTTP-Request",
            "date_published": "2020-09-29T16:00:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"目录\"><a class=\"anchor\" href=\"#目录\">#</a> 目录：</h1>\n<ol>\n<li>Servlet</li>\n<li>HTTP 协议</li>\n<li>Request</li>\n</ol>\n<h2 id=\"servlet\"><a class=\"anchor\" href=\"#servlet\">#</a> Servlet：</h2>\n<ol>\n<li>\n<p>概念</p>\n</li>\n<li>\n<p>步骤</p>\n</li>\n<li>\n<p>执行原理</p>\n</li>\n<li>\n<p>生命周期</p>\n</li>\n<li>\n<p>Servlet3.0 注解配置</p>\n</li>\n<li>\n<p>Servlet 的体系结构\t<br>\nServlet -- 接口<br>\n |<br>\nGenericServlet -- 抽象类<br>\n |<br>\nHttpServlet  -- 抽象类</p>\n<ul>\n<li>\n<p>GenericServlet：将 Servlet 接口中其他的方法做了默认空实现，只将 service () 方法作为抽象</p>\n<ul>\n<li>将来定义 Servlet 类时，可以继承 GenericServlet，实现 service () 方法即可</li>\n</ul>\n</li>\n<li>\n<p>HttpServlet：对 http 协议的一种封装，简化操作</p>\n<ol>\n<li>定义类继承 HttpServlet</li>\n<li>复写 doGet/doPost 方法</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Servlet 相关配置</p>\n<ol>\n<li>urlpartten:Servlet 访问路径\n<ol>\n<li>一个 Servlet 可以定义多个访问路径 ： @WebServlet ({\"/d4\",\"/dd4\",\"/ddd4\"})</li>\n<li>路径定义规则：\n<ol>\n<li>/xxx：路径匹配</li>\n<li>/xxx/xxx: 多层路径，目录结构</li>\n<li>*.do：扩展名匹配</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"http\"><a class=\"anchor\" href=\"#http\">#</a> HTTP：</h2>\n<ul>\n<li>\n<p>概念：Hyper Text Transfer Protocol 超文本传输协议</p>\n<ul>\n<li>\n<p>传输协议：定义了，客户端和服务器端通信时，发送数据的格式</p>\n</li>\n<li>\n<p>特点：</p>\n<ol>\n<li>基于 TCP/IP 的高级协议</li>\n<li>默认端口号：80</li>\n<li>基于请求 / 响应模型的：一次请求对应一次响应</li>\n<li>无状态的：每次请求之间相互独立，不能交互数据</li>\n</ol>\n</li>\n<li>\n<p>历史版本：</p>\n<ul>\n<li>1.0：每一次请求响应都会建立新的连接</li>\n<li>1.1：复用连接</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>请求消息数据格式</p>\n<ol>\n<li>\n<p>请求行<br>\n请求方式 请求 url 请求协议 / 版本<br>\n GET /login.html\tHTTP/1.1</p>\n<ul>\n<li>请求方式：\n<ul>\n<li>HTTP 协议有 7 中请求方式，常用的有 2 种\n<ul>\n<li>GET：\n<ol>\n<li>请求参数在请求行中，在 url 后。</li>\n<li>请求的 url 长度有限制的</li>\n<li>不太安全</li>\n</ol>\n</li>\n<li>POST：\n<ol>\n<li>请求参数在请求体中</li>\n<li>请求的 url 长度没有限制的</li>\n<li>相对安全</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>请求头：客户端浏览器告诉服务器一些信息<br>\n请求头名称：请求头值</p>\n<ul>\n<li>常见的请求头：\n<ol>\n<li>\n<p>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息</p>\n<ul>\n<li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li>\n</ul>\n</li>\n<li>\n<p>Referer：<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdC9sb2dpbi5odG1s\">http://localhost/login.html</span></p>\n<ul>\n<li>告诉服务器，我 (当前请求) 从哪里来？\n<ul>\n<li>作用：\n<ol>\n<li>防盗链：</li>\n<li>统计工作：</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>请求空行<br>\n空行，就是用于分割 POST 请求的请求头，和请求体的。</p>\n</li>\n<li>\n<p>请求体 (正文)：</p>\n<ul>\n<li>封装 POST 请求消息的请求参数的</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>\n<p>字符串格式：<br>\nPOST /login.html\tHTTP/1.1<br>\nHost: localhost<br>\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0<br>\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br>\nAccept-Encoding: gzip, deflate<br>\nReferer: <span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdC9sb2dpbi5odG1s\">http://localhost/login.html</span><br>\nConnection: keep-alive<br>\nUpgrade-Insecure-Requests: 1</p>\n<p>username=zhangsan</p>\n</li>\n</ul>\n</li>\n<li>\n<p>响应消息数据格式</p>\n</li>\n</ul>\n<h2 id=\"request\"><a class=\"anchor\" href=\"#request\">#</a> Request：</h2>\n<ol>\n<li>\n<p>request 对象和 response 对象的原理</p>\n<ol>\n<li>request 和 response 对象是由服务器创建的。我们来使用它们</li>\n<li>request 对象是来获取请求消息，response 对象是来设置响应消息</li>\n</ol>\n</li>\n<li>\n<p>request 对象继承体系结构：\t<br>\nServletRequest\t\t--\t接口<br>\n |\t继承<br>\n HttpServletRequest\t-- 接口<br>\n |\t实现<br>\n org.apache.catalina.connector.RequestFacade 类 (tomcat)</p>\n</li>\n<li>\n<p>request 功能：</p>\n<ol>\n<li>获取请求消息数据\n<ol>\n<li>\n<p>获取请求行数据</p>\n<ul>\n<li>GET /day14/demo1?name=zhangsan HTTP/1.1</li>\n<li>方法：\n<ol>\n<li>\n<p>获取请求方式 ：GET</p>\n<ul>\n<li>String getMethod()</li>\n</ul>\n</li>\n<li>\n<p>(*) 获取虚拟目录：/day14</p>\n<ul>\n<li>String getContextPath()</li>\n</ul>\n</li>\n<li>\n<p>获取 Servlet 路径: /demo1</p>\n<ul>\n<li>String getServletPath()</li>\n</ul>\n</li>\n<li>\n<p>获取 get 方式请求参数：name=zhangsan</p>\n<ul>\n<li>String getQueryString()</li>\n</ul>\n</li>\n<li>\n<p>(*) 获取请求 URI：/day14/demo1</p>\n<ul>\n<li>\n<p>String getRequestURI():\t\t/day14/demo1</p>\n</li>\n<li>\n<p>StringBuffer getRequestURL()  :<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdC9kYXkxNC9kZW1vMQ==\">http://localhost/day14/demo1</span></p>\n</li>\n<li>\n<p>URL: 统一资源定位符 ： <span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdC9kYXkxNC9kZW1vMQ==\">http://localhost/day14/demo1</span>\t中华人民共和国</p>\n</li>\n<li>\n<p>URI：统一资源标识符 : /day14/demo1\t\t\t\t\t共和国</p>\n</li>\n</ul>\n</li>\n<li>\n<p>获取协议及版本：HTTP/1.1</p>\n<ul>\n<li>String getProtocol()</li>\n</ul>\n</li>\n<li>\n<p>获取客户机的 IP 地址：</p>\n<ul>\n<li>String getRemoteAddr()</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>获取请求头数据</p>\n<ul>\n<li>方法：\n<ul>\n<li>(*) String getHeader (String name): 通过请求头的名称获取请求头的值</li>\n<li>Enumeration&lt;String&gt; getHeaderNames (): 获取所有的请求头名称</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>获取请求体数据:</p>\n<ul>\n<li>请求体：只有 POST 请求方式，才有请求体，在请求体中封装了 POST 请求的请求参数</li>\n<li>步骤：\n<ol>\n<li>\n<p>获取流对象</p>\n<ul>\n<li>BufferedReader getReader ()：获取字符输入流，只能操作字符数据</li>\n<li>ServletInputStream getInputStream ()：获取字节输入流，可以操作所有类型数据\n<ul>\n<li>在文件上传知识点后讲解</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>再从流对象中拿数据</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>​\t\t\t\t<br>\n​\t2. 其他功能：<br>\n​\t\t1. 获取请求参数通用方式：不论 get 还是 post 请求方式都可以使用下列方法来获取请求参数<br>\n​\t\t\t1. String getParameter (String name): 根据参数名称获取参数值    username=zs&amp;password=123<br>\n​\t\t\t2. String [] getParameterValues (String name): 根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game<br>\n​\t\t\t3. Enumeration&lt;String&gt; getParameterNames (): 获取所有请求的参数名称<br>\n​\t\t\t4. Map&lt;String,String []&gt; getParameterMap (): 获取所有参数的 map 集合</p>\n<pre><code>\t\t* 中文乱码问题：\n\t\t\t* get方式：tomcat 8 已经将get方式乱码问题解决了\n\t\t\t* post方式：会乱码\n\t\t\t\t* 解决：在获取参数前，设置request的编码request.setCharacterEncoding(\"utf-8\");\n</code></pre>\n<p>​\t\t\t\t\t<br>\n​\t\t2. 请求转发：一种在服务器内部的资源跳转方式<br>\n​\t\t\t1. 步骤：<br>\n​\t\t\t\t1. 通过 request 对象获取请求转发器对象：RequestDispatcher getRequestDispatcher (String path)<br>\n​\t\t\t\t2. 使用 RequestDispatcher 对象来进行转发：forward (ServletRequest request, ServletResponse response)</p>\n<pre><code>\t\t2. 特点：\n\t\t\t1. 浏览器地址栏路径不发生变化\n\t\t\t2. 只能转发到当前服务器内部资源中。\n\t\t\t3. 转发是一次请求\n</code></pre>\n<h2 id=\"案例用户登录\"><a class=\"anchor\" href=\"#案例用户登录\">#</a> 案例：用户登录</h2>\n<ul>\n<li>\n<p>用户登录案例需求：<br>\n1. 编写 login.html 登录页面<br>\n username &amp; password 两个输入框<br>\n 2. 使用 Druid 数据库连接池技术，操作 mysql，day14 数据库中 user 表<br>\n 3. 使用 JdbcTemplate 技术封装 JDBC<br>\n4. 登录成功跳转到 SuccessServlet 展示：登录成功！用户名，欢迎您<br>\n 5. 登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误</p>\n</li>\n<li>\n<p>分析</p>\n</li>\n<li>\n<p>开发步骤</p>\n<ol>\n<li>\n<p>创建项目，导入 html 页面，配置文件，jar 包</p>\n</li>\n<li>\n<p>创建数据库环境<br>\n CREATE DATABASE day14;<br>\nUSE day14;<br>\nCREATE TABLE USER(</p>\n<p>​\tid INT PRIMARY KEY AUTO_INCREMENT,<br>\n​\tusername VARCHAR(32) UNIQUE NOT NULL,<br>\n​\tPASSWORD VARCHAR(32) NOT NULL<br>\n);</p>\n</li>\n<li>\n<p>创建包 cn.itcast.domain, 创建类 User<br>\npackage cn.itcast.domain;<br>\n/**</p>\n<ul>\n<li>\n<p>用户的实体类<br>\n */<br>\npublic class User {</p>\n<p>private int id;<br>\nprivate String username;<br>\nprivate String password;</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>​</p>\n<p>​\t\t    public int getId() {<br>\n​\t\t        return id;<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    public void setId(int id) {<br>\n​\t\t        <span class=\"exturl\" data-url=\"aHR0cDovL3RoaXMuaWQ=\">this.id</span> = id;<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    public String getUsername() {<br>\n​\t\t        return username;<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    public void setUsername(String username) {<br>\n​\t\t        this.username = username;<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    public String getPassword() {<br>\n​\t\t        return password;<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    public void setPassword(String password) {<br>\n​\t\t        this.password = password;<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    @Override<br>\n​\t\t    public String toString() {<br>\n​\t\t        return \"User{\" +<br>\n​\t\t                \"id=\" + id +<br>\n​\t\t                \", username='\" + username + ''' +<br>\n​\t\t                \", password='\" + password + ''' +<br>\n​\t\t                '}';<br>\n​\t\t    }<br>\n​\t\t}</p>\n<pre><code>4. 创建包cn.itcast.util,编写工具类JDBCUtils\n\tpackage cn.itcast.util;\n\n​\timport com.alibaba.druid.pool.DruidDataSourceFactory;\n​\t\n​\timport javax.sql.DataSource;\n​\timport javax.xml.crypto.Data;\n​\timport java.io.IOException;\n​\timport java.io.InputStream;\n​\timport java.sql.Connection;\n​\timport java.sql.SQLException;\n​\timport java.util.Properties;\n​\t\n​\t/**\n\t * JDBC工具类 使用Durid连接池\n\t */\n\tpublic class JDBCUtils {\n\t\n\t​    private static DataSource ds ;\n\t\n\t​    static {\n\t\n\t​        try {\n\t​            //1.加载配置文件\n\t​            Properties pro = new Properties();\n\t​            //使用ClassLoader加载配置文件，获取字节输入流\n\t​            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\n\t​            pro.load(is);\n\t\n\t​            //2.初始化连接池对象\n\t​            ds = DruidDataSourceFactory.createDataSource(pro);\n\t\n\t​        } catch (IOException e) {\n\t​            e.printStackTrace();\n\t​        } catch (Exception e) {\n\t​            e.printStackTrace();\n\t​        }\n\t​    }\n\t\n\t​    /**\n\t     * 获取连接池对象\n\t          */\n\t        public static DataSource getDataSource(){\n\t        return ds;\n\t        }\n</code></pre>\n<p>​</p>\n<p>​\t\t    /**<br>\n​\t\t     * 获取连接 Connection 对象<br>\n​\t\t     <em>/<br>\n​\t\t    public static Connection getConnection() throws SQLException {<br>\n​\t\t        return  ds.getConnection();<br>\n​\t\t    }<br>\n​\t\t}<br>\n​\t5. 创建包 cn.itcast.dao, 创建类 UserDao, 提供 login 方法<br>\n​\t\t<br>\n​\t\tpackage cn.itcast.dao;<br>\n​\t<br>\n​\t\timport cn.itcast.domain.User;<br>\n​\t\timport cn.itcast.util.JDBCUtils;<br>\n​\t\timport org.springframework.dao.DataAccessException;<br>\n​\t\timport org.springframework.jdbc.core.BeanPropertyRowMapper;<br>\n​\t\timport org.springframework.jdbc.core.JdbcTemplate;<br>\n​\t\t<br>\n​\t\t/</em>*<br>\n​\t\t * 操作数据库中 User 表的类<br>\n​\t\t */<br>\n​\t\tpublic class UserDao {<br>\n​\t\t<br>\n// 声明 JDBCTemplate 对象共用<br>\n private JdbcTemplate template = new JdbcTemplate (JDBCUtils.getDataSource ());</p>\n<pre><code>\t    /**\n\t     * 登录方法\n\t     * @param loginUser 只有用户名和密码\n\t     * @return user包含用户全部数据,没有查询到，返回null\n\t     */\n\t    public User login(User loginUser){\n\t        try {\n\t            //1.编写sql\n\t            String sql = \"select * from user where username = ? and password = ?\";\n\t            //2.调用query方法\n\t            User user = template.queryForObject(sql,\n\t                    new BeanPropertyRowMapper&lt;User&gt;(User.class),\n\t                    loginUser.getUsername(), loginUser.getPassword());\n</code></pre>\n<p>​</p>\n<p>​\t\t            return user;<br>\n​\t\t        } catch (DataAccessException e) {<br>\n​\t\t            e.printStackTrace ();// 记录日志<br>\n​\t\t            return null;<br>\n​\t\t        }<br>\n​\t\t    }<br>\n​\t\t}<br>\n​</p>\n<pre><code>6. 编写cn.itcast.web.servlet.LoginServlet类\n\tpackage cn.itcast.web.servlet;\n\n​\timport cn.itcast.dao.UserDao;\n​\timport cn.itcast.domain.User;\n​\t\n​\timport javax.servlet.ServletException;\n​\timport javax.servlet.annotation.WebServlet;\n​\timport javax.servlet.http.HttpServlet;\n​\timport javax.servlet.http.HttpServletRequest;\n​\timport javax.servlet.http.HttpServletResponse;\n​\timport java.io.IOException;\n</code></pre>\n<p>​</p>\n<p>​\t\t@WebServlet(\"/loginServlet\")<br>\n​\t\tpublic class LoginServlet extends HttpServlet {</p>\n<p>​</p>\n<p>​\t\t    @Override<br>\n​\t\t    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>\n​\t\t        <a href=\"//1.xn--d8yz4mshv84b\">//1. 设置编码</a><br>\n​\t\t        req.setCharacterEncoding (\"utf-8\");<br>\n​\t\t        <a href=\"//2.xn--8nrrb831grng2u5admk\">//2. 获取请求参数</a><br>\n​\t\t        String username = req.getParameter (\"username\");<br>\n​\t\t        String password = req.getParameter(\"password\");<br>\n​\t\t        <a href=\"//3.xn--user-ou9gnbx382dmbg\">//3. 封装 user 对象</a><br>\n​\t\t        User loginUser = new User ();<br>\n​\t\t        loginUser.setUsername(username);<br>\n​\t\t        loginUser.setPassword(password);<br>\n​\t\t<br>\n​\t\t        <a href=\"//4.xn--UserDaologin-g98y914e5q2aktew64i\">//4. 调用 UserDao 的 login 方法</a><br>\n​\t\t        UserDao dao = new UserDao ();<br>\n​\t\t        User user = dao.login(loginUser);<br>\n​\t\t<br>\n​\t\t        <a href=\"//5.xn--user-zk9fu84h\">//5. 判断 user</a><br>\n​\t\t        if(user == null){<br>\n​\t\t            // 登录失败<br>\n​\t\t            req.getRequestDispatcher (\"/failServlet\").forward (req,resp);<br>\n​\t\t        }else{<br>\n​\t\t            // 登录成功<br>\n​\t\t            // 存储数据<br>\n​\t\t            req.setAttribute (\"user\",user);<br>\n​\t\t            // 转发<br>\n​\t\t            req.getRequestDispatcher (\"/successServlet\").forward (req,resp);<br>\n​\t\t        }<br>\n​\t\t<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    @Override<br>\n​\t\t    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>\n​\t\t        this.doGet(req,resp);<br>\n​\t\t    }<br>\n​\t\t}</p>\n<pre><code>7. 编写FailServlet和SuccessServlet类\n\t@WebServlet(\"/successServlet\")\n\tpublic class SuccessServlet extends HttpServlet {\n\t    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t        //获取request域中共享的user对象\n\t        User user = (User) request.getAttribute(\"user\");\n\t\n\t        if(user != null){\n\t            //给页面写一句话\n\t\n\t            //设置编码\n\t            response.setContentType(\"text/html;charset=utf-8\");\n\t            //输出\n\t            response.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎您\");\n\t        }\n</code></pre>\n<p>​</p>\n<p>​\t\t    }</p>\n<p>​\t\t@WebServlet(\"/failServlet\")<br>\n​\t\tpublic class FailServlet extends HttpServlet {<br>\n​\t\t    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>\n​\t\t        // 给页面写一句话<br>\n​\t\t<br>\n​\t\t        // 设置编码<br>\n​\t\t        response.setContentType (\"text/html;charset=utf-8\");<br>\n​\t\t        // 输出<br>\n​\t\t        response.getWriter ().write (\"登录失败，用户名或密码错误\");<br>\n​\t\t<br>\n​\t\t    }<br>\n​\t\t<br>\n​\t\t    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>\n​\t\t        this.doPost(request,response);<br>\n​\t\t    }<br>\n​\t\t}</p>\n<pre><code>8. login.html中form表单的action路径的写法\n\t* 虚拟目录+Servlet的资源路径\n\n9. BeanUtils工具类，简化数据封装\n\t* 用于封装JavaBean的\n\t1. JavaBean：标准的Java类\n\t\t1. 要求：\n\t\t\t1. 类必须被public修饰\n\t\t\t2. 必须提供空参的构造器\n\t\t\t3. 成员变量必须使用private修饰\n\t\t\t4. 提供公共setter和getter方法\n\t\t2. 功能：封装数据\n\n\t2. 概念：\n\t\t成员变量：\n\t\t属性：setter和getter方法截取后的产物\n\t\t\t例如：getUsername() --&gt; Username--&gt; username\n\n\t3. 方法：\n\t\t1. setProperty()\n\t\t2. getProperty()\n\t\t3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "JavaWeb"
            ]
        }
    ]
}