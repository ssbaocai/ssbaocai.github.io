{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"mysql\" category",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/04/MySQL/",
            "url": "https://www.baocai-blog.cn/2020/10/04/MySQL/",
            "title": "MySQL",
            "date_published": "2020-10-04T06:58:46.799Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"数据库的三范式是什么\"><a class=\"anchor\" href=\"#数据库的三范式是什么\">#</a> 数据库的三范式是什么？</h4>\n<ul>\n<li>第一范式：强调的是原子性，即数据库表的每一列都是不可分割的原子数据项。</li>\n<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>\n<li>第三范式：任何非主属性不依赖于其它非主属性。</li>\n</ul>\n<h4 id=\"mysql-的内连接-左连接-右连接有什么区别\"><a class=\"anchor\" href=\"#mysql-的内连接-左连接-右连接有什么区别\">#</a> MySQL 的内连接、左连接、右连接有什么区别？</h4>\n<p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>\n<p>内连接是把匹配的关联数 据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>\n<h4 id=\"数据库基本操作语句\"><a class=\"anchor\" href=\"#数据库基本操作语句\">#</a> 数据库基本操作语句</h4>\n<p>主键约束 (primary key)  唯一约束 (unique) 非空约束 (not null) 外键约束 (foreign key)</p>\n<p><strong>select</strong> ... from 表名  where 条件  group by  分组字段  having 条件  order by  排序字段 ase|desc</p>\n<p>去重操作<strong> distinct</strong>             select distinct 字段名，字段名 2 from 表名</p>\n<p><strong>insert  into  &lt;表名&gt;  [列名]  values  &lt; 列值 &gt;                delete  from  &lt; 表名 &gt;  where  &lt; 删除条件 &gt;</strong>**</p>\n<p><strong>update 表名 set  字段名 = 字段值，字段名 = 字段值   [where 修改条件];</strong></p>\n<h4 id=\"数据库特性\"><a class=\"anchor\" href=\"#数据库特性\">#</a> 数据库特性</h4>\n<ul>\n<li>Atomicity（<strong>原子性</strong>）：事务不可分割、不可约简。</li>\n<li>Consistency（<strong>一致性</strong>）：在事务开始前和事务结束后，<strong>数据库的完整性</strong>没有被破坏。</li>\n<li>Isolation（<strong>隔离性</strong>）：数据库允许多个事务同时对数据处理，隔离性可以<strong>防止</strong>多个事务并发执行时由于交叉执行而<strong>导致数据的不一致</strong>。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>\n<li>Durability（<strong>持久性</strong>）：事务处理结束后，对数据的修改就是永久，不会丢失。</li>\n</ul>\n<h4 id=\"事务隔离\"><a class=\"anchor\" href=\"#事务隔离\">#</a> 事务隔离</h4>\n<ul>\n<li>READ-UNCOMMITTED：<strong>未提交读</strong>，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>\n<li>READ-COMMITTED：<strong>提交读</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>\n<li>REPEATABLE-READ：<strong>可重复读</strong>，<strong>默认</strong>级别，保证多次读取同一个数据，值和内容一致。禁止读取到别的事务未提交的数据（会造成幻读）。</li>\n<li>SERIALIZABLE：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ul>\n<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。<strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>\n<h4 id=\"oracle页查询\"><a class=\"anchor\" href=\"#oracle页查询\">#</a> <strong>Oracle 页查询</strong></h4>\n<p>Oracle 中使用 rownum 来进行分页，</p>\n<p>select * from    ( select rownum r,a from tabName where rownum &lt;= 20 )  where r &gt; 10</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "MySQL"
            ]
        }
    ]
}