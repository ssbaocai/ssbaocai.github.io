<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.baocai-blog.cn</id>
    <title>手撕包菜 • Posts by &#34;java&#34; category</title>
    <link href="https://www.baocai-blog.cn" />
    <updated>2020-10-04T06:58:46.815Z</updated>
    <category term="MyBatis" />
    <category term="MySQL" />
    <category term="Java" />
    <category term="Spring" />
    <category term="多线程" />
    <category term="容器" />
    <category term="设计模式" />
    <entry>
        <id>https://www.baocai-blog.cn/2020/10/04/%E5%9F%BA%E7%A1%80/</id>
        <title>Java基础</title>
        <link rel="alternate" href="https://www.baocai-blog.cn/2020/10/04/%E5%9F%BA%E7%A1%80/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;string-和-stringbuffer-stringbuilder-的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#string-和-stringbuffer-stringbuilder-的区别&#34;&gt;#&lt;/a&gt; &lt;strong&gt;String 和 StringBuffer、StringBuilder&lt;/strong&gt; 的区别：&lt;/h4&gt;
&lt;p&gt;String 声明的是&lt;strong&gt;不可变&lt;/strong&gt;的对象，StringBuffer、StringBuilder 可以在原有对象的基础上进行操作。&lt;/p&gt;
&lt;p&gt;StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是&lt;strong&gt;线程安全的&lt;/strong&gt;，但 StringBuilder 的性能却高于 StringBuffer，所以在&lt;strong&gt;单线程&lt;/strong&gt;环境下推荐使用 StringBuilder，&lt;strong&gt;多线程&lt;/strong&gt;环境下推荐使用 StringBuffer。&lt;/p&gt;
&lt;h4 id=&#34;方法重载与方法重写&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#方法重载与方法重写&#34;&gt;#&lt;/a&gt; 方法重载与方法重写&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法重写：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重写是子类对父类的允许访问的方法的&lt;strong&gt;实现过程&lt;/strong&gt;进行重新编写，&lt;strong&gt;返回值&lt;/strong&gt;和&lt;strong&gt;形参&lt;/strong&gt;都不能改变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法重载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个类中，方法名相同，参数不同。返回类型可以相同也可以不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法重载&lt;/strong&gt;是一个类中定义了多个方法名相同，而他们的&lt;strong&gt;参数&lt;/strong&gt;的数量不同或数量相同而&lt;strong&gt;类型&lt;/strong&gt;和&lt;strong&gt;顺序&lt;/strong&gt;不同，则称为方法的重载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法重写&lt;/strong&gt;是在子类存在方法与父类的&lt;strong&gt;方法名&lt;/strong&gt;相同，而且&lt;strong&gt;参数&lt;/strong&gt;的个数与类型一样，&lt;strong&gt; 返回值&lt;/strong&gt;也一样的方法，就称为重写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;接口和抽象类有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#接口和抽象类有什么区别&#34;&gt;#&lt;/a&gt; 接口和抽象类有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;实现：抽象类的子类使用  extends 来继承；接口必须使用 implements 来实现接口。&lt;/li&gt;
&lt;li&gt;构造函数：抽象类可以有构造函数；接口不能有。&lt;/li&gt;
&lt;li&gt;实现数量：类可以实现很多个接口；但是只能继承一个抽象类。&lt;/li&gt;
&lt;li&gt;访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态变量和实例变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#静态变量和实例变量&#34;&gt;#&lt;/a&gt; 静态变量和实例变量&lt;/h4&gt;
&lt;p&gt;** 静态变量：** 独立存在，属于类所有，可以直接类名加点调用静态变量名使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例变量&lt;/strong&gt;：需要先初始化该类，就是 new 该类后，才可以调用。但是该类被垃圾回收器回收后，该实例也将不存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1. 存储区域不同：静态变量存储在&lt;strong&gt;方法区&lt;/strong&gt;，普通变量存储在&lt;strong&gt;堆&lt;/strong&gt;中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2. 静态变量与类相关，普通变量则与实例相关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3. 内存分配方式不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4. 生命周期不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;和的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#和的区别&#34;&gt;#&lt;/a&gt; &amp;amp; 和 &amp;amp;&amp;amp; 的区别&lt;/h4&gt;
&lt;p&gt;&amp;amp; 运算符有两种用法：(1) 按位与；(2) 逻辑与。&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp; 运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;amp;&amp;amp; 之所以称为短路运算，是因为如果 &amp;amp;&amp;amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。&lt;/p&gt;
&lt;h4 id=&#34;final-有什么用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#final-有什么用&#34;&gt;#&lt;/a&gt; final 有什么用？&lt;/h4&gt;
&lt;p&gt;用于修饰类、属性和方法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被 final 修饰的类不可以被继承&lt;/li&gt;
&lt;li&gt;被 final 修饰的方法不可以被重写&lt;/li&gt;
&lt;li&gt;被 final 修饰的变量不可以被改变，被 final 修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;final-finally-finalize区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#final-finally-finalize区别&#34;&gt;#&lt;/a&gt; final finally finalize 区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;final 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表&lt;br&gt;
示该变量是一个常量不能被重新赋值。&lt;/li&gt;
&lt;li&gt;finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法 finally 代码块&lt;br&gt;
中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。&lt;/li&gt;
&lt;li&gt;finalize 是一个方法，属于 Object 类的一个方法，而 Object 类是所有类的父类，该方法一般由垃圾回收器来调&lt;br&gt;
用，当我们调用 System.gc () 方法的时候，由垃圾回收器调用 finalize ()，回收垃圾，一个对象是否可回收的&lt;br&gt;
最后判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt;</content>
        <category term="Java" />
        <updated>2020-10-04T06:58:46.815Z</updated>
    </entry>
    <entry>
        <id>https://www.baocai-blog.cn/2020/10/04/%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</id>
        <title>Java容器（Cellection/Map）</title>
        <link rel="alternate" href="https://www.baocai-blog.cn/2020/10/04/%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;java-容器分为-collection-和-map-两大类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#java-容器分为-collection-和-map-两大类&#34;&gt;#&lt;/a&gt; Java 容器分为 Collection 和 Map 两大类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Collection&lt;/p&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList&lt;/li&gt;
&lt;li&gt;LinkedList&lt;/li&gt;
&lt;li&gt;Vector&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​       Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;HashSet&lt;/li&gt;
&lt;li&gt;LinkedHashSet&lt;/li&gt;
&lt;li&gt;TreeSet&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map&lt;/p&gt;
&lt;p&gt;HashMap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;LinkedHashMap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​       TreeMap、ConcurrentHashMap、Hashtable&lt;/p&gt;
&lt;h4 id=&#34;list-set-map-之间的区别是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#list-set-map-之间的区别是什么&#34;&gt;#&lt;/a&gt; List、Set、Map 之间的区别是什么？&lt;/h4&gt;
&lt;p&gt;List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;C:%5CUsers%5CYangMiemie%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200925103453410.png&#34; alt=&#34;image-20200925103453410&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List 和 Set&lt;/strong&gt; 是存储 &lt;strong&gt;单列数据&lt;/strong&gt; 的集合，&lt;strong&gt;Map&lt;/strong&gt; 是存储&lt;strong&gt;键和值&lt;/strong&gt;这样的双列数据的集合；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt; 中存储的数据是&lt;strong&gt;有顺序&lt;/strong&gt;，并且允许&lt;strong&gt;重复&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt; 中存储的数据是&lt;strong&gt;无序&lt;/strong&gt;的，其&lt;strong&gt;键&lt;/strong&gt;是不能重复的，它的&lt;strong&gt;值&lt;/strong&gt;是可以有重复的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt; 中存储的数据是&lt;strong&gt;无序&lt;/strong&gt;的，且不允许有重复。&lt;/p&gt;
&lt;h4 id=&#34;hashmap-和-hashtable-有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#hashmap-和-hashtable-有什么区别&#34;&gt;#&lt;/a&gt; HashMap 和 Hashtable 有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;存储：HashMap 允许 key 和 value 为  null，而 Hashtable 不允许。&lt;/li&gt;
&lt;li&gt;线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。&lt;/li&gt;
&lt;li&gt;推荐使用：在  Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用     ConcurrentHashMap 替代。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;如何决定使用-hashmap-还是-treemap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#如何决定使用-hashmap-还是-treemap&#34;&gt;#&lt;/a&gt; 如何决定使用 HashMap 还是 TreeMap？&lt;/h4&gt;
&lt;p&gt;对在 Map 中插入、删除、定位一个元素这类操作，HashMap 最好，因为相对而言 HashMap 的插入会更快&lt;/p&gt;
&lt;p&gt;对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。&lt;/p&gt;
&lt;h4 id=&#34;说一下-hashmap-的实现原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说一下-hashmap-的实现原理&#34;&gt;#&lt;/a&gt; 说一下 HashMap 的实现原理？&lt;/h4&gt;
&lt;p&gt;HashMap 基于 Hash 算法实现的，我们通过 **put (key,value)** 存储，**get (key)** 来获取。&lt;/p&gt;
&lt;p&gt;当传入 key 时，HashMap 会根据 key. hashCode () 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。&lt;/p&gt;
&lt;h4 id=&#34;说一下-hashset-的实现原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说一下-hashset-的实现原理&#34;&gt;#&lt;/a&gt; 说一下 HashSet 的实现原理？&lt;/h4&gt;
&lt;p&gt;HashSet 是基于 HashMap 实现的，底层使用 HashMap 来保存所有元素，HashSet 的实现比较简单，&lt;/p&gt;
&lt;p&gt;相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。&lt;/p&gt;
&lt;h4 id=&#34;arraylist-和-linkedlist-的区别是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arraylist-和-linkedlist-的区别是什么&#34;&gt;#&lt;/a&gt; ArrayList 和 LinkedList 的区别是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数据结构实现：ArrayList  是&lt;strong&gt;动态数组&lt;/strong&gt;的数据结构实现，而 LinkedList 是&lt;strong&gt;双向链表&lt;/strong&gt;的数据结构实现。&lt;/li&gt;
&lt;li&gt;随机访问效率：ArrayList  比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。&lt;/li&gt;
&lt;li&gt;增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList.&lt;/p&gt;
&lt;p&gt;在插入和删除操作较多时，更推荐使用 LinkedList。&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt;</content>
        <category term="容器" />
        <updated>2020-10-04T06:58:46.815Z</updated>
    </entry>
</feed>
