{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"java\" category",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/04/%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/",
            "url": "https://www.baocai-blog.cn/2020/10/04/%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/",
            "title": "Java容器（Cellection/Map）",
            "date_published": "2020-10-04T06:58:46.815Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"java-容器分为-collection-和-map-两大类\"><a class=\"anchor\" href=\"#java-容器分为-collection-和-map-两大类\">#</a> Java 容器分为 Collection 和 Map 两大类</h4>\n<ul>\n<li>\n<p>Collection</p>\n<p>List</p>\n</li>\n<li>\n<ul>\n<li>ArrayList</li>\n<li>LinkedList</li>\n<li>Vector</li>\n<li>Stack</li>\n</ul>\n</li>\n</ul>\n<p>​       Set</p>\n<ul>\n<li>\n<ul>\n<li>HashSet</li>\n<li>LinkedHashSet</li>\n<li>TreeSet</li>\n</ul>\n</li>\n<li>\n<p>Map</p>\n<p>HashMap</p>\n</li>\n<li>\n<ul>\n<li>LinkedHashMap</li>\n</ul>\n</li>\n</ul>\n<p>​       TreeMap、ConcurrentHashMap、Hashtable</p>\n<h4 id=\"list-set-map-之间的区别是什么\"><a class=\"anchor\" href=\"#list-set-map-之间的区别是什么\">#</a> List、Set、Map 之间的区别是什么？</h4>\n<p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>\n<p><img data-src=\"C:%5CUsers%5CYangMiemie%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200925103453410.png\" alt=\"image-20200925103453410\"></p>\n<p><strong>List 和 Set</strong> 是存储 <strong>单列数据</strong> 的集合，<strong>Map</strong> 是存储<strong>键和值</strong>这样的双列数据的集合；</p>\n<p><strong>List</strong> 中存储的数据是<strong>有顺序</strong>，并且允许<strong>重复</strong>；</p>\n<p><strong>Map</strong> 中存储的数据是<strong>无序</strong>的，其<strong>键</strong>是不能重复的，它的<strong>值</strong>是可以有重复的。</p>\n<p><strong>Set</strong> 中存储的数据是<strong>无序</strong>的，且不允许有重复。</p>\n<h4 id=\"hashmap-和-hashtable-有什么区别\"><a class=\"anchor\" href=\"#hashmap-和-hashtable-有什么区别\">#</a> HashMap 和 Hashtable 有什么区别？</h4>\n<ul>\n<li>存储：HashMap 允许 key 和 value 为  null，而 Hashtable 不允许。</li>\n<li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>\n<li>推荐使用：在  Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用     ConcurrentHashMap 替代。</li>\n</ul>\n<h4 id=\"如何决定使用-hashmap-还是-treemap\"><a class=\"anchor\" href=\"#如何决定使用-hashmap-还是-treemap\">#</a> 如何决定使用 HashMap 还是 TreeMap？</h4>\n<p>对在 Map 中插入、删除、定位一个元素这类操作，HashMap 最好，因为相对而言 HashMap 的插入会更快</p>\n<p>对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>\n<h4 id=\"说一下-hashmap-的实现原理\"><a class=\"anchor\" href=\"#说一下-hashmap-的实现原理\">#</a> 说一下 HashMap 的实现原理？</h4>\n<p>HashMap 基于 Hash 算法实现的，我们通过 **put (key,value)** 存储，**get (key)** 来获取。</p>\n<p>当传入 key 时，HashMap 会根据 key. hashCode () 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>\n<h4 id=\"说一下-hashset-的实现原理\"><a class=\"anchor\" href=\"#说一下-hashset-的实现原理\">#</a> 说一下 HashSet 的实现原理？</h4>\n<p>HashSet 是基于 HashMap 实现的，底层使用 HashMap 来保存所有元素，HashSet 的实现比较简单，</p>\n<p>相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>\n<h4 id=\"arraylist-和-linkedlist-的区别是什么\"><a class=\"anchor\" href=\"#arraylist-和-linkedlist-的区别是什么\">#</a> ArrayList 和 LinkedList 的区别是什么？</h4>\n<ul>\n<li>数据结构实现：ArrayList  是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</li>\n<li>随机访问效率：ArrayList  比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>\n<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>\n</ul>\n<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList.</p>\n<p>在插入和删除操作较多时，更推荐使用 LinkedList。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "容器"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/04/%E5%9F%BA%E7%A1%80/",
            "url": "https://www.baocai-blog.cn/2020/10/04/%E5%9F%BA%E7%A1%80/",
            "title": "Java基础",
            "date_published": "2020-10-04T06:58:46.815Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"string-和-stringbuffer-stringbuilder-的区别\"><a class=\"anchor\" href=\"#string-和-stringbuffer-stringbuilder-的区别\">#</a> <strong>String 和 StringBuffer、StringBuilder</strong> 的区别：</h4>\n<p>String 声明的是<strong>不可变</strong>的对象，StringBuffer、StringBuilder 可以在原有对象的基础上进行操作。</p>\n<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是<strong>线程安全的</strong>，但 StringBuilder 的性能却高于 StringBuffer，所以在<strong>单线程</strong>环境下推荐使用 StringBuilder，<strong>多线程</strong>环境下推荐使用 StringBuffer。</p>\n<h4 id=\"方法重载与方法重写\"><a class=\"anchor\" href=\"#方法重载与方法重写\">#</a> 方法重载与方法重写</h4>\n<ul>\n<li>\n<p><strong>方法重写：</strong></p>\n<p>重写是子类对父类的允许访问的方法的<strong>实现过程</strong>进行重新编写，<strong>返回值</strong>和<strong>形参</strong>都不能改变。</p>\n</li>\n<li>\n<p><strong>方法重载：</strong></p>\n<p>在一个类中，方法名相同，参数不同。返回类型可以相同也可以不同。</p>\n</li>\n<li>\n<p><strong>区别：</strong></p>\n<p><strong>方法重载</strong>是一个类中定义了多个方法名相同，而他们的<strong>参数</strong>的数量不同或数量相同而<strong>类型</strong>和<strong>顺序</strong>不同，则称为方法的重载。</p>\n<p><strong>方法重写</strong>是在子类存在方法与父类的<strong>方法名</strong>相同，而且<strong>参数</strong>的个数与类型一样，<strong> 返回值</strong>也一样的方法，就称为重写。</p>\n</li>\n</ul>\n<h4 id=\"接口和抽象类有什么区别\"><a class=\"anchor\" href=\"#接口和抽象类有什么区别\">#</a> 接口和抽象类有什么区别？</h4>\n<ul>\n<li>实现：抽象类的子类使用  extends 来继承；接口必须使用 implements 来实现接口。</li>\n<li>构造函数：抽象类可以有构造函数；接口不能有。</li>\n<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>\n<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>\n</ul>\n<h4 id=\"静态变量和实例变量\"><a class=\"anchor\" href=\"#静态变量和实例变量\">#</a> 静态变量和实例变量</h4>\n<p>** 静态变量：** 独立存在，属于类所有，可以直接类名加点调用静态变量名使用。</p>\n<p><strong>实例变量</strong>：需要先初始化该类，就是 new 该类后，才可以调用。但是该类被垃圾回收器回收后，该实例也将不存在。</p>\n<p><strong>区别：</strong></p>\n<ul>\n<li>\n<p>1. 存储区域不同：静态变量存储在<strong>方法区</strong>，普通变量存储在<strong>堆</strong>中；</p>\n</li>\n<li>\n<p>2. 静态变量与类相关，普通变量则与实例相关</p>\n</li>\n<li>\n<p>3. 内存分配方式不同。</p>\n</li>\n<li>\n<p>4. 生命周期不同。</p>\n</li>\n</ul>\n<h4 id=\"和的区别\"><a class=\"anchor\" href=\"#和的区别\">#</a> &amp; 和 &amp;&amp; 的区别</h4>\n<p>&amp; 运算符有两种用法：(1) 按位与；(2) 逻辑与。</p>\n<p>&amp;&amp; 运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;&amp; 之所以称为短路运算，是因为如果 &amp;&amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>\n<h4 id=\"final-有什么用\"><a class=\"anchor\" href=\"#final-有什么用\">#</a> final 有什么用？</h4>\n<p>用于修饰类、属性和方法；</p>\n<ul>\n<li>被 final 修饰的类不可以被继承</li>\n<li>被 final 修饰的方法不可以被重写</li>\n<li>被 final 修饰的变量不可以被改变，被 final 修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>\n</ul>\n<h4 id=\"final-finally-finalize区别\"><a class=\"anchor\" href=\"#final-finally-finalize区别\">#</a> final finally finalize 区别</h4>\n<ul>\n<li>final 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表<br>\n示该变量是一个常量不能被重新赋值。</li>\n<li>finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法 finally 代码块<br>\n中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>\n<li>finalize 是一个方法，属于 Object 类的一个方法，而 Object 类是所有类的父类，该方法一般由垃圾回收器来调<br>\n用，当我们调用 System.gc () 方法的时候，由垃圾回收器调用 finalize ()，回收垃圾，一个对象是否可回收的<br>\n最后判断。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "Java"
            ]
        }
    ]
}