{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"java\" category",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "url": "https://www.baocai-blog.cn/2020/10/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
            "title": "面向对象",
            "date_published": "2020-10-10T04:07:06.642Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"面向对象\"><a class=\"anchor\" href=\"#面向对象\">#</a> 面向对象</h1>\n<h2 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h2>\n<h3 id=\"类与对象\"><a class=\"anchor\" href=\"#类与对象\">#</a> 类与对象</h3>\n<ul>\n<li>对象：对象是类的实例</li>\n<li>类：类是一个模板，描述一类对象的行为和状态</li>\n</ul>\n<h3 id=\"构造方法\"><a class=\"anchor\" href=\"#构造方法\">#</a> 构造方法</h3>\n<ul>\n<li>用于对象初始化。</li>\n<li>构造方法的名称必须与类同名，一个类可以有多个构造方法。</li>\n</ul>\n<h3 id=\"方法重载方法重写\"><a class=\"anchor\" href=\"#方法重载方法重写\">#</a> 方法重载 / 方法重写</h3>\n<ul>\n<li>重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。子类可以根据需要，定义特定于自己的行为。</li>\n<li>重载：重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li>\n</ul>\n<h2 id=\"高级\"><a class=\"anchor\" href=\"#高级\">#</a> 高级</h2>\n<h3 id=\"final关键字\"><a class=\"anchor\" href=\"#final关键字\">#</a> final 关键字</h3>\n<p>1.final 修饰的类叫最终类，该类不能被继承。<br>\n2.final 修饰的方法不能被重写。<br>\n3.final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改</p>\n<h3 id=\"抽象类\"><a class=\"anchor\" href=\"#抽象类\">#</a> 抽象类</h3>\n<ol>\n<li>\n<p>抽象类不能被实例化</p>\n</li>\n<li>\n<p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>\n</li>\n<li>\n<p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p>\n</li>\n<li>\n<p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p>\n</li>\n<li>\n<p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p>\n</li>\n</ol>\n<h3 id=\"接口\"><a class=\"anchor\" href=\"#接口\">#</a> 接口</h3>\n<p>接口是抽象方法的集合</p>\n<ul>\n<li>定义格式：<br>\ninterface 接口名称 { &nbsp; &nbsp; &nbsp;<br>\n全局常量；&nbsp; &nbsp; &nbsp;<br>\n抽象方法；&nbsp;<br>\n}</li>\n<li>接口和抽象类的区别：<br>\n1、抽象类要被子类继承，接口要被类实现。<br>\n2、接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。<br>\n3、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br>\n4、抽象类使用继承来使用，无法多继承。接口使用实现来使用，可以多实现<br>\n 5、抽象类中可以包含 static 方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明 静态方法）     6、接口不能有构造方法，但是抽象类可以有</li>\n</ul>\n<h3 id=\"equals\"><a class=\"anchor\" href=\"#equals\">#</a> equals</h3>\n<h3 id=\"内部类\"><a class=\"anchor\" href=\"#内部类\">#</a> 内部类</h3>\n<h4 id=\"成员内部类\"><a class=\"anchor\" href=\"#成员内部类\">#</a> 成员内部类</h4>\n<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>\n<pre><code>class Outer { &nbsp; &nbsp;\n\tprivate double x = 0; &nbsp; &nbsp;\n\tpublic Outer(double x) { \n\tthis.x = x; \n    } &nbsp; &nbsp;  &nbsp; &nbsp;\nclass Inner { &nbsp; //内部类 &nbsp; &nbsp; &nbsp;\n\tpublic void say() {\n    \tSystem.out.println(\"x=\"+x);&nbsp;  \n    } &nbsp;\n} \n}\n</code></pre>\n<p>特点： 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。</p>\n<h4 id=\"局部内部类\"><a class=\"anchor\" href=\"#局部内部类\">#</a> 局部内部类</h4>\n<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限 于方法内或者该作用域内。<br>\n例如：</p>\n<pre><code>\tclass Person{ &nbsp;  \n\t\tpublic Person() {\n &nbsp; &nbsp;\t}  \n    }\n    \n    class Man{ &nbsp; &nbsp; &nbsp;  \n    \tpublic Man(){\n &nbsp; &nbsp; &nbsp;  }\n &nbsp; &nbsp; &nbsp; &nbsp;public People getPerson(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n        class Student extends People{        \n        //局部内部类 \n        int age =0; &nbsp;  \n        } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n        return new Student(); &nbsp;   \n        }   \n    }\n</code></pre>\n<h4 id=\"匿名内部类\"><a class=\"anchor\" href=\"#匿名内部类\">#</a> 匿名内部类</h4>\n<p>new 父类构造器（参数列表）| 实现接口（） { &nbsp; &nbsp; &nbsp;<br>\n// 匿名内部类的类体部分<br>\n}</p>\n<h4 id=\"静态内部类\"><a class=\"anchor\" href=\"#静态内部类\">#</a> 静态内部类</h4>\n<p>静态内部类是不需要依赖于外部类对象的，并且它不能使用外部类的非 static 成员变量或者方法.<br>\n 格式：</p>\n<pre><code>public class Test { &nbsp; \n\tpublic static void main(String[] args)  { &nbsp; &nbsp; &nbsp; \n\tOutter.Inner inner = new Outter.Inner(); &nbsp; \n\t} \n}\n \nclass Outter { &nbsp; &nbsp;\n\tpublic Outter() { &nbsp;\n  \t} &nbsp; &nbsp;  &nbsp; &nbsp;\nstatic class Inner { &nbsp; &nbsp; &nbsp; &nbsp;\n\tpublic Inner() { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; \n    } &nbsp; \n} \n}\n</code></pre>\n<h2 id=\"进阶\"><a class=\"anchor\" href=\"#进阶\">#</a> 进阶</h2>\n<h3 id=\"封装\"><a class=\"anchor\" href=\"#封装\">#</a> 封装</h3>\n<p>private 修饰变量<br>\n Getter/Setter</p>\n<h3 id=\"this\"><a class=\"anchor\" href=\"#this\">#</a> this</h3>\n<p>使用 this 关键字可以完成以下的操作：</p>\n<ul>\n<li>调用类中的属性</li>\n<li>调用类中的方法或构造方法</li>\n<li>表示当前对象</li>\n</ul>\n<h3 id=\"static\"><a class=\"anchor\" href=\"#static\">#</a> static</h3>\n<p>static 表示 “静态” 的意思，可以用来修饰成员变量和成员方法<br>\n重点：<br>\n1. 静态成员 在类加载时加载并初始化。<br>\n2. 无论一个类存在多少个对象，静态的属性，永远在内存中只有一份<br>\n 3. 在访问时： 静态不能访问非静态，非静态可以访问静态！</p>\n<h2 id=\"异常处理\"><a class=\"anchor\" href=\"#异常处理\">#</a> 异常处理</h2>\n<h3 id=\"try-catch\"><a class=\"anchor\" href=\"#try-catch\">#</a> try&nbsp; catch</h3>\n<ul>\n<li>异常指的是 Exception，Exception 类，在 Java 中存在一个父 Throwable（可能的抛出）</li>\n<li>Throwable 存在两个子类：<br>\n1.Error：表示的是错误，是 JVM 发出的错误操作，只能尽量避免，无法用代码处理。<br>\n2.Exception：一般表示所有程序中的错误，所以一般在程序中将进行 try…catch 的处理。</li>\n</ul>\n<h3 id=\"throwthrows\"><a class=\"anchor\" href=\"#throwthrows\">#</a> throw/throws</h3>\n<ul>\n<li>throws 关键字：<br>\n此关键字主要在方法的声明上使 用，表示方法中不处理异常，而交给调用处处理。<br>\n格式：<br>\n返回值 方法名称 () throws Exception {<br>\n}</li>\n<li>throw 关键字<br>\n throw 关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出 的就是一个异常类的实例化对象，那么此对象也可以由 throw 直接抛出。<br>\n代码： throw new Exception (\"抛着玩的。\") ;</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "面向对象"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "url": "https://www.baocai-blog.cn/2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "title": "Java基础语法",
            "date_published": "2020-10-10T02:41:02.214Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"java基础语法\"><a class=\"anchor\" href=\"#java基础语法\">#</a> JAVA 基础语法</h1>\n<h2 id=\"基础语法\"><a class=\"anchor\" href=\"#基础语法\">#</a> 基础语法</h2>\n<h3 id=\"运算符\"><a class=\"anchor\" href=\"#运算符\">#</a> 运算符</h3>\n<p>算数运算符</p>\n<p>关系运算符</p>\n<p>赋值运算符</p>\n<p>逻辑运算符</p>\n<p>三目运算符</p>\n<h3 id=\"数据类型\"><a class=\"anchor\" href=\"#数据类型\">#</a> 数据类型</h3>\n<h4 id=\"基本数据类型\"><a class=\"anchor\" href=\"#基本数据类型\">#</a> 基本数据类型</h4>\n<ul>\n<li>byte、short、int、long</li>\n<li>float、double、char</li>\n<li>boolean</li>\n</ul>\n<h4 id=\"引用数据类型\"><a class=\"anchor\" href=\"#引用数据类型\">#</a> 引用数据类型</h4>\n<ul>\n<li>class</li>\n<li>interface</li>\n<li>数组</li>\n</ul>\n<h2 id=\"流程控制\"><a class=\"anchor\" href=\"#流程控制\">#</a> 流程控制</h2>\n<h3 id=\"if\"><a class=\"anchor\" href=\"#if\">#</a> if</h3>\n<p>if 条件结构是根据条件判断之后再做处理</p>\n<h3 id=\"switch\"><a class=\"anchor\" href=\"#switch\">#</a> switch</h3>\n<ul>\n<li>switch (表达式){<br>\ncase 取值 1: 语句块 1;break;<br>\ncase 取值 n: 语句块 n;break; \t\tdefault: 语句块 n+1;break;<br>\n}</li>\n<li>switch 语句有关规则 表达式的返回值必须是下述几种类型之一：int,byte,char,short,String；</li>\n<li>case 子句中的取值必须是常量，且所有 case 子句中的取值应是不同的；</li>\n</ul>\n<h3 id=\"while\"><a class=\"anchor\" href=\"#while\">#</a> while</h3>\n<ul>\n<li>while 循环<br>\n符合条件，循环继续执行；否则，循环退出<br>\n特点：先判断，再执行</li>\n<li>do-while 循环<br>\n先执行一遍循环操作，符合条件，循环继续执行；否则，循环退出<br>\n特点：先执行，再判断</li>\n</ul>\n<h3 id=\"for\"><a class=\"anchor\" href=\"#for\">#</a> for</h3>\n<p>语法：<br>\nfor (初始化参数；判断条件；更新循环变量){<br>\n循环体；<br>\n}</p>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<h3 id=\"冒泡排序\"><a class=\"anchor\" href=\"#冒泡排序\">#</a> 冒泡排序</h3>\n<p>原理：</p>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的</li>\n</ul>\n<h3 id=\"二分查找\"><a class=\"anchor\" href=\"#二分查找\">#</a> 二分查找</h3>\n<p>二分查找也叫折半查找，是一种基本的查找算法，需要待查的表满足两个条件：</p>\n<ul>\n<li>1. 查找表必须使用顺序的存储结构</li>\n<li>2. 查找表必须按关键字大小有序排列</li>\n</ul>\n<p>算法的基本思想是：</p>\n<ul>\n<li>\n<p>将查找表中间位置数据元素的关键字与给定关键字比较，如果相等则查找成功；</p>\n</li>\n<li>\n<p>否则利用中间元素将表一分为二，如果中间关键字大于给定关键字，则在前一子表中进行折半查找，否则在后一子表中进行折半查找。</p>\n</li>\n<li>\n<p>重复以上过程直到找到满足条件的元素，则查找成功；或直到子表为空为止，此时查找不成功。</p>\n</li>\n</ul>\n<p>二分查找递归写法：</p>\n<pre><code>public int firstOccurrence (int [] nums,int target){\n\t\n    int low = 0,high = nums.length - 1;\n    while(low &lt;=  high){   \n        int mid = low + (high-low)/2;\n        if(nums[mid] == target){\n            return mid;\n        }\n        if(nums[mid] &lt; target){\n            low = mid+1;\n        }else {\n            high = mid-1;\n        }\n    }\n    return -1;\n}\n</code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "Java基础"
            ]
        }
    ]
}