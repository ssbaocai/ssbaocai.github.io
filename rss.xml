<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>手撕包菜</title>
        <link>https://www.baocai-blog.cn</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
        <lastBuildDate>Sun, 04 Oct 2020 14:58:46 +0800</lastBuildDate>
        <category>MyBatis</category>
        <category>MySQL</category>
        <category>Java</category>
        <category>Spring</category>
        <category>多线程</category>
        <category>容器</category>
        <category>设计模式</category>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
            <title>设计模式</title>
            <link>https://www.baocai-blog.cn/2020/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
            <category>设计模式</category>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;熟悉的设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#熟悉的设计模式&#34;&gt;#&lt;/a&gt; 熟悉的设计模式？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单例模式：保证被创建一次，节省系统开销。&lt;/li&gt;
&lt;li&gt;工厂模式（简单工厂、抽象工厂）：解耦代码。&lt;/li&gt;
&lt;li&gt;观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。&lt;/li&gt;
&lt;li&gt;外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。&lt;/li&gt;
&lt;li&gt;模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。&lt;/li&gt;
&lt;li&gt;状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/%E5%9F%BA%E7%A1%80/</guid>
            <title>Java基础</title>
            <link>https://www.baocai-blog.cn/2020/10/04/%E5%9F%BA%E7%A1%80/</link>
            <category>Java</category>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;string-和-stringbuffer-stringbuilder-的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#string-和-stringbuffer-stringbuilder-的区别&#34;&gt;#&lt;/a&gt; &lt;strong&gt;String 和 StringBuffer、StringBuilder&lt;/strong&gt; 的区别：&lt;/h4&gt;
&lt;p&gt;String 声明的是&lt;strong&gt;不可变&lt;/strong&gt;的对象，StringBuffer、StringBuilder 可以在原有对象的基础上进行操作。&lt;/p&gt;
&lt;p&gt;StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是&lt;strong&gt;线程安全的&lt;/strong&gt;，但 StringBuilder 的性能却高于 StringBuffer，所以在&lt;strong&gt;单线程&lt;/strong&gt;环境下推荐使用 StringBuilder，&lt;strong&gt;多线程&lt;/strong&gt;环境下推荐使用 StringBuffer。&lt;/p&gt;
&lt;h4 id=&#34;方法重载与方法重写&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#方法重载与方法重写&#34;&gt;#&lt;/a&gt; 方法重载与方法重写&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法重写：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重写是子类对父类的允许访问的方法的&lt;strong&gt;实现过程&lt;/strong&gt;进行重新编写，&lt;strong&gt;返回值&lt;/strong&gt;和&lt;strong&gt;形参&lt;/strong&gt;都不能改变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法重载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个类中，方法名相同，参数不同。返回类型可以相同也可以不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法重载&lt;/strong&gt;是一个类中定义了多个方法名相同，而他们的&lt;strong&gt;参数&lt;/strong&gt;的数量不同或数量相同而&lt;strong&gt;类型&lt;/strong&gt;和&lt;strong&gt;顺序&lt;/strong&gt;不同，则称为方法的重载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法重写&lt;/strong&gt;是在子类存在方法与父类的&lt;strong&gt;方法名&lt;/strong&gt;相同，而且&lt;strong&gt;参数&lt;/strong&gt;的个数与类型一样，&lt;strong&gt; 返回值&lt;/strong&gt;也一样的方法，就称为重写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;接口和抽象类有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#接口和抽象类有什么区别&#34;&gt;#&lt;/a&gt; 接口和抽象类有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;实现：抽象类的子类使用  extends 来继承；接口必须使用 implements 来实现接口。&lt;/li&gt;
&lt;li&gt;构造函数：抽象类可以有构造函数；接口不能有。&lt;/li&gt;
&lt;li&gt;实现数量：类可以实现很多个接口；但是只能继承一个抽象类。&lt;/li&gt;
&lt;li&gt;访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态变量和实例变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#静态变量和实例变量&#34;&gt;#&lt;/a&gt; 静态变量和实例变量&lt;/h4&gt;
&lt;p&gt;** 静态变量：** 独立存在，属于类所有，可以直接类名加点调用静态变量名使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例变量&lt;/strong&gt;：需要先初始化该类，就是 new 该类后，才可以调用。但是该类被垃圾回收器回收后，该实例也将不存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1. 存储区域不同：静态变量存储在&lt;strong&gt;方法区&lt;/strong&gt;，普通变量存储在&lt;strong&gt;堆&lt;/strong&gt;中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2. 静态变量与类相关，普通变量则与实例相关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3. 内存分配方式不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4. 生命周期不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;和的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#和的区别&#34;&gt;#&lt;/a&gt; &amp;amp; 和 &amp;amp;&amp;amp; 的区别&lt;/h4&gt;
&lt;p&gt;&amp;amp; 运算符有两种用法：(1) 按位与；(2) 逻辑与。&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp; 运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;amp;&amp;amp; 之所以称为短路运算，是因为如果 &amp;amp;&amp;amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。&lt;/p&gt;
&lt;h4 id=&#34;final-有什么用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#final-有什么用&#34;&gt;#&lt;/a&gt; final 有什么用？&lt;/h4&gt;
&lt;p&gt;用于修饰类、属性和方法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被 final 修饰的类不可以被继承&lt;/li&gt;
&lt;li&gt;被 final 修饰的方法不可以被重写&lt;/li&gt;
&lt;li&gt;被 final 修饰的变量不可以被改变，被 final 修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;final-finally-finalize区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#final-finally-finalize区别&#34;&gt;#&lt;/a&gt; final finally finalize 区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;final 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表&lt;br&gt;
示该变量是一个常量不能被重新赋值。&lt;/li&gt;
&lt;li&gt;finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法 finally 代码块&lt;br&gt;
中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。&lt;/li&gt;
&lt;li&gt;finalize 是一个方法，属于 Object 类的一个方法，而 Object 类是所有类的父类，该方法一般由垃圾回收器来调&lt;br&gt;
用，当我们调用 System.gc () 方法的时候，由垃圾回收器调用 finalize ()，回收垃圾，一个对象是否可回收的&lt;br&gt;
最后判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/Spring/</guid>
            <title>Spring/SpringMVC</title>
            <link>https://www.baocai-blog.cn/2020/10/04/Spring/</link>
            <category>Spring</category>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;spring是一个ioc和aop容器框架&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring是一个ioc和aop容器框架&#34;&gt;#&lt;/a&gt; Spring 是一个 IOC 和 AOP 容器框架。&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制反转（IOC&lt;/strong&gt;）在 spring 开发模式中，&lt;strong&gt;spring 容器&lt;/strong&gt;使用了工厂模式为我们&lt;strong&gt;创建&lt;/strong&gt;所需要的对象，我们自己直接调用 spring 提供的对象就可以了，这是控制反转的思想。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;（&lt;strong&gt;DI&lt;/strong&gt;），spring 使用 javaBean 对象的 &lt;strong&gt;set 方法&lt;/strong&gt;或者&lt;strong&gt;带参数的构造方法&lt;/strong&gt;为我们在创建所需对象时将其&lt;strong&gt;属性&lt;/strong&gt;自动设置所需要的值 ** 的过程，就是依赖注入的思想。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;面向切面编程&lt;/strong&gt;（&lt;strong&gt;AOP&lt;/strong&gt;），在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口  采用 JDK 动态代理，如果是类  采用 CGLIB 方式实现动态代理。&lt;/p&gt;
&lt;p&gt;通过预编译方式和运行期动态代理&lt;strong&gt;实现程序功能的统一维护&lt;/strong&gt;的一种技术。就是统一处理某一 “切面”（类）的问题，比如统一处理日志、异常等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;spring-常用的注入方式有哪些&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-常用的注入方式有哪些&#34;&gt;#&lt;/a&gt; spring 常用的注入方式有哪些？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;setter 属性注入&lt;/li&gt;
&lt;li&gt;构造方法注入&lt;/li&gt;
&lt;li&gt;注解方式注入&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;说一下-spring-mvc-运行流程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说一下-spring-mvc-运行流程&#34;&gt;#&lt;/a&gt; 说一下 spring mvc 运行流程？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;spring     mvc 先将&lt;strong&gt;请求发送&lt;/strong&gt;给 DispatcherServlet（前置控制器）。&lt;/li&gt;
&lt;li&gt;DispatcherServlet     查询一个或多个 HandlerMapping（映射控制器），&lt;strong&gt;找到&lt;/strong&gt;处理请求的 Controller（处理器）。&lt;/li&gt;
&lt;li&gt;DispatcherServlet     再把请求&lt;strong&gt;提交到&lt;/strong&gt;对应的 Controller。&lt;/li&gt;
&lt;li&gt;Controller     进行业务逻辑&lt;strong&gt;处理后，会返回&lt;/strong&gt;一个 ModelAndView。&lt;/li&gt;
&lt;li&gt;Dispathcher     查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。&lt;/li&gt;
&lt;li&gt;视图对象负责渲染返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;springbootspringmvc区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#springbootspringmvc区别&#34;&gt;#&lt;/a&gt; SpringBoot/SpringMVC 区别&lt;/h4&gt;
&lt;p&gt;Spring MVC 基于 Spring 的 web 框架，主要解决 WEB 开发的问题&lt;/p&gt;
&lt;p&gt;SpringBoot 实现自动配置，降低项目搭建的复杂度&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
            <title>多线程</title>
            <link>https://www.baocai-blog.cn/2020/10/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
            <category>多线程</category>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;并行和并发有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#并行和并发有什么区别&#34;&gt;#&lt;/a&gt; 并行和并发有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;并行：多个处理器或多核处理器同时处理多个任务。&lt;/li&gt;
&lt;li&gt;并发：多个任务在同一个 CPU     核上，按细分的时间片轮流 (交替) 执行，从逻辑上来看那些任务是同时执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图：&lt;img data-src=&#34;C:%5CUsers%5CYangMiemie%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201004132903253.png&#34; alt=&#34;image-20201004132903253&#34;&gt;&lt;/p&gt;
&lt;p&gt;​				并发 = 两个队列和一台咖啡机。&lt;/p&gt;
&lt;p&gt;​				并行 = 两个队列和两台咖啡机。&lt;/p&gt;
&lt;h4 id=&#34;创建线程有哪几种方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建线程有哪几种方式&#34;&gt;#&lt;/a&gt; 创建线程有哪几种方式？&lt;/h4&gt;
&lt;p&gt;创建线程有三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承 Thread 重写 run 方法；&lt;/li&gt;
&lt;li&gt;实现 Runnable 接口；&lt;/li&gt;
&lt;li&gt;实现 Callable 接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;说一下-runnable-和-callable-有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说一下-runnable-和-callable-有什么区别&#34;&gt;#&lt;/a&gt; 说一下 runnable 和 callable 有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，支持泛型&lt;/li&gt;
&lt;li&gt;Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;java-线程状态有哪些&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#java-线程状态有哪些&#34;&gt;#&lt;/a&gt; Java 线程状态有哪些？&lt;/h4&gt;
&lt;p&gt;线程状态有 5 种，新建，就绪，运行，阻塞，死亡。&lt;/p&gt;
&lt;h4 id=&#34;sleep-和-wait-有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sleep-和-wait-有什么区别&#34;&gt;#&lt;/a&gt; sleep () 和 wait () 有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;类的不同：sleep () 来自 Thread，wait () 来自 Object。&lt;/li&gt;
&lt;li&gt;释放锁：sleep () 不释放锁；wait () 释放锁。&lt;/li&gt;
&lt;li&gt;用法不同：sleep () 时间到会自动恢复；wait () 可以使用 notify ()/notifyAll () 直接唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</guid>
            <title>Java容器（Cellection/Map）</title>
            <link>https://www.baocai-blog.cn/2020/10/04/%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</link>
            <category>容器</category>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;java-容器分为-collection-和-map-两大类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#java-容器分为-collection-和-map-两大类&#34;&gt;#&lt;/a&gt; Java 容器分为 Collection 和 Map 两大类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Collection&lt;/p&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList&lt;/li&gt;
&lt;li&gt;LinkedList&lt;/li&gt;
&lt;li&gt;Vector&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​       Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;HashSet&lt;/li&gt;
&lt;li&gt;LinkedHashSet&lt;/li&gt;
&lt;li&gt;TreeSet&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map&lt;/p&gt;
&lt;p&gt;HashMap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;LinkedHashMap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​       TreeMap、ConcurrentHashMap、Hashtable&lt;/p&gt;
&lt;h4 id=&#34;list-set-map-之间的区别是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#list-set-map-之间的区别是什么&#34;&gt;#&lt;/a&gt; List、Set、Map 之间的区别是什么？&lt;/h4&gt;
&lt;p&gt;List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;C:%5CUsers%5CYangMiemie%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200925103453410.png&#34; alt=&#34;image-20200925103453410&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List 和 Set&lt;/strong&gt; 是存储 &lt;strong&gt;单列数据&lt;/strong&gt; 的集合，&lt;strong&gt;Map&lt;/strong&gt; 是存储&lt;strong&gt;键和值&lt;/strong&gt;这样的双列数据的集合；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt; 中存储的数据是&lt;strong&gt;有顺序&lt;/strong&gt;，并且允许&lt;strong&gt;重复&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt; 中存储的数据是&lt;strong&gt;无序&lt;/strong&gt;的，其&lt;strong&gt;键&lt;/strong&gt;是不能重复的，它的&lt;strong&gt;值&lt;/strong&gt;是可以有重复的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt; 中存储的数据是&lt;strong&gt;无序&lt;/strong&gt;的，且不允许有重复。&lt;/p&gt;
&lt;h4 id=&#34;hashmap-和-hashtable-有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#hashmap-和-hashtable-有什么区别&#34;&gt;#&lt;/a&gt; HashMap 和 Hashtable 有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;存储：HashMap 允许 key 和 value 为  null，而 Hashtable 不允许。&lt;/li&gt;
&lt;li&gt;线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。&lt;/li&gt;
&lt;li&gt;推荐使用：在  Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用     ConcurrentHashMap 替代。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;如何决定使用-hashmap-还是-treemap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#如何决定使用-hashmap-还是-treemap&#34;&gt;#&lt;/a&gt; 如何决定使用 HashMap 还是 TreeMap？&lt;/h4&gt;
&lt;p&gt;对在 Map 中插入、删除、定位一个元素这类操作，HashMap 最好，因为相对而言 HashMap 的插入会更快&lt;/p&gt;
&lt;p&gt;对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。&lt;/p&gt;
&lt;h4 id=&#34;说一下-hashmap-的实现原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说一下-hashmap-的实现原理&#34;&gt;#&lt;/a&gt; 说一下 HashMap 的实现原理？&lt;/h4&gt;
&lt;p&gt;HashMap 基于 Hash 算法实现的，我们通过 **put (key,value)** 存储，**get (key)** 来获取。&lt;/p&gt;
&lt;p&gt;当传入 key 时，HashMap 会根据 key. hashCode () 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。&lt;/p&gt;
&lt;h4 id=&#34;说一下-hashset-的实现原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说一下-hashset-的实现原理&#34;&gt;#&lt;/a&gt; 说一下 HashSet 的实现原理？&lt;/h4&gt;
&lt;p&gt;HashSet 是基于 HashMap 实现的，底层使用 HashMap 来保存所有元素，HashSet 的实现比较简单，&lt;/p&gt;
&lt;p&gt;相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。&lt;/p&gt;
&lt;h4 id=&#34;arraylist-和-linkedlist-的区别是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arraylist-和-linkedlist-的区别是什么&#34;&gt;#&lt;/a&gt; ArrayList 和 LinkedList 的区别是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数据结构实现：ArrayList  是&lt;strong&gt;动态数组&lt;/strong&gt;的数据结构实现，而 LinkedList 是&lt;strong&gt;双向链表&lt;/strong&gt;的数据结构实现。&lt;/li&gt;
&lt;li&gt;随机访问效率：ArrayList  比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。&lt;/li&gt;
&lt;li&gt;增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList.&lt;/p&gt;
&lt;p&gt;在插入和删除操作较多时，更推荐使用 LinkedList。&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/JavaWeb/</guid>
            <title></title>
            <link>https://www.baocai-blog.cn/2020/10/04/JavaWeb/</link>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h2 id=&#34;javaweb&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#javaweb&#34;&gt;#&lt;/a&gt; JavaWeb&lt;/h2&gt;
&lt;h3 id=&#34;说下原生jdbc操作数据库流程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说下原生jdbc操作数据库流程&#34;&gt;#&lt;/a&gt; 说下原生 jdbc 操作数据库流程？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一步：Class.forName () 加载数据库连接驱动；&lt;/li&gt;
&lt;li&gt;第二步：DriverManager.getConnection () 获取数据连接对象；&lt;/li&gt;
&lt;li&gt;第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;&lt;/li&gt;
&lt;li&gt;第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX ();&lt;/li&gt;
&lt;li&gt;第五步：关闭结果集、关闭会话、关闭连接。&lt;br&gt;
详细代码请看（封装）：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjk1NDI2MTEvYXJ0aWNsZS9kZXRhaWxzLzUyNDI2MDA2&#34;&gt;http://blog.csdn.net/qq_29542611/article/details/52426006&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;session-和-cookie-有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#session-和-cookie-有什么区别&#34;&gt;#&lt;/a&gt; session 和 cookie 有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。&lt;/li&gt;
&lt;li&gt;安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。&lt;/li&gt;
&lt;li&gt;容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。&lt;/li&gt;
&lt;li&gt;存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述-tcp-和-udp的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简述-tcp-和-udp的区别&#34;&gt;#&lt;/a&gt; 简述 tcp 和 udp 的区别？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;tcp&lt;/strong&gt; 和 &lt;strong&gt;udp&lt;/strong&gt; 是 OSI 模型中的运输层中的协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tcp&lt;/strong&gt; 提供可靠的通信传输    &lt;strong&gt;udp&lt;/strong&gt; 则常被用于让广播和细节控制交给应用的通信传输。&lt;/p&gt;
&lt;p&gt;两者的区别大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tcp &lt;strong&gt;面向连接&lt;/strong&gt;，udp &lt;strong&gt;面向非连接&lt;/strong&gt;即发送数据前不需要建立链接；&lt;/li&gt;
&lt;li&gt;tcp 提供可靠的服务（数据传输），udp 无法保证；&lt;/li&gt;
&lt;li&gt;tcp 面向字节流，udp 面向报文；&lt;/li&gt;
&lt;li&gt;tcp 数据传输慢，udp 数据传输快；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp三次握手&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp三次握手&#34;&gt;#&lt;/a&gt; tcp 三次握手&lt;/h3&gt;
&lt;p&gt;第一次&lt;/p&gt;
&lt;p&gt;第一次握手：建立连接时，客户端  发送&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4=&#34;&gt; syn&lt;/span&gt; 包（seq=j）到  服务器，并进入 SYN_SENT 状态，等待  服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 [3]&lt;/p&gt;
&lt;p&gt;第二次&lt;/p&gt;
&lt;p&gt;第二次握手：服务器  收到&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4=&#34;&gt; syn&lt;/span&gt; 包，必须确认  客户端  的 SYN（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=&#34;&gt;ack&lt;/span&gt;=j+1），同时自己也发送一个 SYN 包（seq=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。 [3]&lt;/p&gt;
&lt;p&gt;第三次&lt;/p&gt;
&lt;p&gt;第三次握手：客户端  收到  服务器  的 SYN+ACK 包，向  服务器  发送确认包 ACK (&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=&#34;&gt;ack&lt;/span&gt;=k+1），此包发送完毕，客户端和服务器进入&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9FU1RBQkxJU0hFRA==&#34;&gt; ESTABLISHED&lt;/span&gt;（TCP 连接成功）状态，完成三次握手。&lt;/p&gt;
&lt;h3 id=&#34;为什么要三次握手两次不行吗为什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#为什么要三次握手两次不行吗为什么&#34;&gt;#&lt;/a&gt; 为什么要三次握手，两次不行吗？为什么？&lt;/h3&gt;
&lt;p&gt;如果采用两次握手，那么只要&lt;strong&gt;服务器&lt;/strong&gt;发出确认数据包就会建立连接，但由于&lt;strong&gt;客户端&lt;/strong&gt;此时并未响应服务器端的请求，那此时&lt;strong&gt;服务器端&lt;/strong&gt;就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。&lt;/p&gt;
&lt;p&gt;若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/MyBatis/</guid>
            <title>MyBatis</title>
            <link>https://www.baocai-blog.cn/2020/10/04/MyBatis/</link>
            <category>MyBatis</category>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;缓存&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#缓存&#34;&gt;#&lt;/a&gt; 缓存&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，&lt;strong&gt;声明周期&lt;/strong&gt;是和 SQLSession 一致的，作用域 session。&lt;strong&gt;当 Session flush 或 close 之后， Cache 就将清空，一级缓存开启&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，作用域为 Mapper 级别的，如果多个 SQLSession 之间需要&lt;strong&gt;共享缓存&lt;/strong&gt;，则需要使用到二级缓存，并且二级缓存可自定义存储源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mybatis的编程步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mybatis的编程步骤&#34;&gt;#&lt;/a&gt; Mybatis 的编程步骤&lt;/h4&gt;
&lt;p&gt;1、创建 SqlSessionFactory&lt;br&gt;
2、通过 SqlSessionFactory 创建 SqlSession&lt;br&gt;
3、通过 sqlsession 执行数据库操作&lt;br&gt;
 4、调用 session.commit () 提交事务&lt;br&gt;
 5、调用 session.close () 关闭会话&lt;/p&gt;
&lt;p&gt;MyBatis 是一个可以自定义 SQL、存储过程和高级映射的&lt;strong&gt;持久层框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyBatis 只使用&lt;strong&gt;简单的 XML 和注解&lt;/strong&gt;来&lt;strong&gt;配置和映射&lt;/strong&gt;基本数据类型、Map 接口和 POJO 到数据库记录。&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/10/04/MySQL/</guid>
            <title>MySQL</title>
            <link>https://www.baocai-blog.cn/2020/10/04/MySQL/</link>
            <category>MySQL</category>
            <pubDate>Sun, 04 Oct 2020 14:58:46 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h4 id=&#34;数据库的三范式是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的三范式是什么&#34;&gt;#&lt;/a&gt; 数据库的三范式是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;第一范式：强调的是原子性，即数据库表的每一列都是不可分割的原子数据项。&lt;/li&gt;
&lt;li&gt;第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。&lt;/li&gt;
&lt;li&gt;第三范式：任何非主属性不依赖于其它非主属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mysql-的内连接-左连接-右连接有什么区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mysql-的内连接-左连接-右连接有什么区别&#34;&gt;#&lt;/a&gt; MySQL 的内连接、左连接、右连接有什么区别？&lt;/h4&gt;
&lt;p&gt;内连接关键字：inner join；左连接：left join；右连接：right join。&lt;/p&gt;
&lt;p&gt;内连接是把匹配的关联数 据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。&lt;/p&gt;
&lt;h4 id=&#34;数据库基本操作语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库基本操作语句&#34;&gt;#&lt;/a&gt; 数据库基本操作语句&lt;/h4&gt;
&lt;p&gt;主键约束 (primary key)  唯一约束 (unique) 非空约束 (not null) 外键约束 (foreign key)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select&lt;/strong&gt; ... from 表名  where 条件  group by  分组字段  having 条件  order by  排序字段 ase|desc&lt;/p&gt;
&lt;p&gt;去重操作&lt;strong&gt; distinct&lt;/strong&gt;             select distinct 字段名，字段名 2 from 表名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insert  into  &amp;lt;表名&amp;gt;  [列名]  values  &amp;lt; 列值 &amp;gt;                delete  from  &amp;lt; 表名 &amp;gt;  where  &amp;lt; 删除条件 &amp;gt;&lt;/strong&gt;**&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;update 表名 set  字段名 = 字段值，字段名 = 字段值   [where 修改条件];&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;数据库特性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库特性&#34;&gt;#&lt;/a&gt; 数据库特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Atomicity（&lt;strong&gt;原子性&lt;/strong&gt;）：事务不可分割、不可约简。&lt;/li&gt;
&lt;li&gt;Consistency（&lt;strong&gt;一致性&lt;/strong&gt;）：在事务开始前和事务结束后，&lt;strong&gt;数据库的完整性&lt;/strong&gt;没有被破坏。&lt;/li&gt;
&lt;li&gt;Isolation（&lt;strong&gt;隔离性&lt;/strong&gt;）：数据库允许多个事务同时对数据处理，隔离性可以&lt;strong&gt;防止&lt;/strong&gt;多个事务并发执行时由于交叉执行而&lt;strong&gt;导致数据的不一致&lt;/strong&gt;。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/li&gt;
&lt;li&gt;Durability（&lt;strong&gt;持久性&lt;/strong&gt;）：事务处理结束后，对数据的修改就是永久，不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;事务隔离&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#事务隔离&#34;&gt;#&lt;/a&gt; 事务隔离&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;READ-UNCOMMITTED：&lt;strong&gt;未提交读&lt;/strong&gt;，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。&lt;/li&gt;
&lt;li&gt;READ-COMMITTED：&lt;strong&gt;提交读&lt;/strong&gt;，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。&lt;/li&gt;
&lt;li&gt;REPEATABLE-READ：&lt;strong&gt;可重复读&lt;/strong&gt;，&lt;strong&gt;默认&lt;/strong&gt;级别，保证多次读取同一个数据，值和内容一致。禁止读取到别的事务未提交的数据（会造成幻读）。&lt;/li&gt;
&lt;li&gt;SERIALIZABLE：&lt;strong&gt;序列化&lt;/strong&gt;，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;脏读&lt;/strong&gt; ：表示一个事务能够读取另一个事务中还未提交的数据。&lt;strong&gt;不可重复读&lt;/strong&gt; ：是指在一个事务内，多次读同一数据。&lt;/p&gt;
&lt;h4 id=&#34;oracle页查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#oracle页查询&#34;&gt;#&lt;/a&gt; &lt;strong&gt;Oracle 页查询&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Oracle 中使用 rownum 来进行分页，&lt;/p&gt;
&lt;p&gt;select * from    ( select rownum r,a from tabName where rownum &amp;lt;= 20 )  where r &amp;gt; 10&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
    </channel>
</rss>
