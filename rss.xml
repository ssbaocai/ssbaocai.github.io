<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>手撕包菜</title>
        <link>https://www.baocai-blog.cn</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
        <lastBuildDate>Wed, 30 Sep 2020 00:00:00 +0800</lastBuildDate>
        <category>MySQL</category>
        <category>JavaWeb</category>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/09/30/MySQL%E5%9F%BA%E7%A1%80/</guid>
            <title>MySQL基础</title>
            <link>https://www.baocai-blog.cn/2020/09/30/MySQL%E5%9F%BA%E7%A1%80/</link>
            <category>MySQL</category>
            <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h1 id=&#34;目录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#目录&#34;&gt;#&lt;/a&gt; 目录&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据库的基本概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 数据库软件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;li&gt;卸载&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据库的基本概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的基本概念&#34;&gt;#&lt;/a&gt; 数据库的基本概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据库的英文单词： DataBase 简称 ： DB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么数据库？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于存储和管理数据的仓库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;持久化存储数据的。其实数据库就是一个文件系统&lt;/li&gt;
&lt;li&gt;方便存储和管理数据&lt;/li&gt;
&lt;li&gt;使用了统一的方式操作数据库 -- SQL&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	&lt;br&gt;
4. 常见的数据库软件&lt;br&gt;
 * 参见《MySQL 基础.pdf》&lt;/p&gt;
&lt;h2 id=&#34;mysql数据库软件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mysql数据库软件&#34;&gt;#&lt;/a&gt; MySQL 数据库软件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参见《MySQL 基础.pdf》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卸载&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;去 mysql 的安装目录找到 my.ini 文件
&lt;ul&gt;
&lt;li&gt;复制 datadir=&#34;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&#34;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卸载 MySQL&lt;/li&gt;
&lt;li&gt;删除 C:/ProgramData 目录下的 MySQL 文件夹。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MySQL 服务启动&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动。&lt;/li&gt;
&lt;li&gt;cmd--&amp;gt; services.msc 打开服务的窗口&lt;/li&gt;
&lt;li&gt;使用管理员打开 cmd
&lt;ul&gt;
&lt;li&gt;net start mysql : 启动 mysql 的服务&lt;/li&gt;
&lt;li&gt;net stop mysql: 关闭 mysql 服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 登录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mysql -uroot -p 密码&lt;/li&gt;
&lt;li&gt;mysql -hip -uroot -p 连接目标的密码&lt;/li&gt;
&lt;li&gt;mysql --host=ip --user=root --password = 连接目标的密码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 退出&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;exit&lt;/li&gt;
&lt;li&gt;quit&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 目录结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 安装目录：basedir=&#34;D:/develop/MySQL/&#34;
&lt;ul&gt;
&lt;li&gt;配置文件 my.ini&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MySQL 数据目录：datadir=&#34;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&#34;
&lt;ul&gt;
&lt;li&gt;几个概念
&lt;ul&gt;
&lt;li&gt;数据库：文件夹&lt;/li&gt;
&lt;li&gt;表：文件&lt;/li&gt;
&lt;li&gt;数据：数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sql&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sql&#34;&gt;#&lt;/a&gt; SQL&lt;/h2&gt;
&lt;p&gt;1. 什么是 SQL？&lt;br&gt;
Structured Query Language：结构化查询语言&lt;br&gt;
其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为 “方言”。&lt;/p&gt;
&lt;p&gt;2.SQL 通用语法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SQL 语句可以单行或多行书写，以分号结尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可使用空格和缩进来增强语句的可读性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3 种注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单行注释: -- 注释内容 或 # 注释内容 (mysql 特有)&lt;/li&gt;
&lt;li&gt;多行注释: /* 注释 */&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL 分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DDL (Data Definition Language) 数据定义语言&lt;br&gt;
用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等&lt;/li&gt;
&lt;li&gt;DML (Data Manipulation Language) 数据操作语言&lt;br&gt;
用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等&lt;/li&gt;
&lt;li&gt;DQL (Data Query Language) 数据查询语言&lt;br&gt;
用来查询数据库中表的记录 (数据)。关键字：select, where 等&lt;/li&gt;
&lt;li&gt;DCL (Data Control Language) 数据控制语言 (了解)&lt;br&gt;
 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ddl操作数据库-表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ddl操作数据库-表&#34;&gt;#&lt;/a&gt; DDL: 操作数据库、表&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;操作数据库：CRUD&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C (Create): 创建
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建数据库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create database 数据库名称；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建数据库，判断不存在，再创建：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create database if not exists 数据库名称；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建数据库，并指定字符集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create database 数据库名称 character set 字符集名；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;练习： 创建 db4 数据库，判断是否存在，并制定字符集为 gbk&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create database if not exists db4 character set gbk;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;R (Retrieve)：查询
&lt;ul&gt;
&lt;li&gt;查询所有数据库的名称:
&lt;ul&gt;
&lt;li&gt;show databases;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查询某个数据库的字符集：查询某个数据库的创建语句
&lt;ul&gt;
&lt;li&gt;show create database 数据库名称；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;U (Update): 修改
&lt;ul&gt;
&lt;li&gt;修改数据库的字符集
&lt;ul&gt;
&lt;li&gt;alter database 数据库名称 character set 字符集名称；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D (Delete): 删除
&lt;ul&gt;
&lt;li&gt;删除数据库
&lt;ul&gt;
&lt;li&gt;drop database 数据库名称；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;判断数据库存在，存在再删除
&lt;ul&gt;
&lt;li&gt;drop database if exists 数据库名称；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用数据库
&lt;ul&gt;
&lt;li&gt;查询当前正在使用的数据库名称
&lt;ul&gt;
&lt;li&gt;select database();&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用数据库
&lt;ul&gt;
&lt;li&gt;use 数据库名称；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;C (Create): 创建&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法：&lt;br&gt;
create table 表名 (&lt;br&gt;
列名 1 数据类型 1,&lt;br&gt;
 列名 2 数据类型 2,&lt;br&gt;
....&lt;br&gt;
 列名 n 数据类型 n&lt;br&gt;
);
&lt;ul&gt;
&lt;li&gt;注意：最后一列，不需要加逗号（,）&lt;/li&gt;
&lt;li&gt;数据库类型：
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;int：整数类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;age int,&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;double: 小数类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;score double(5,2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;date: 日期，只包含年月日，yyyy-MM-dd&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;datetime: 日期，包含年月日时分秒	 yyyy-MM-dd HH:mm:ss&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;timestamp: 时间错类型	包含年月日时分秒	 yyyy-MM-dd HH:mm:ss&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果将来不给这个字段赋值，或赋值为 null，则默认使用当前的系统时间，来自动赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;varchar：字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name varchar (20): 姓名最大 20 个字符&lt;/li&gt;
&lt;li&gt;zhangsan 8 个字符  张三 2 个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;创建表&lt;br&gt;
 create table student (&lt;br&gt;
id int,&lt;br&gt;
name varchar(32),&lt;br&gt;
age int ,&lt;br&gt;
score double(4,1),&lt;br&gt;
birthday date,&lt;br&gt;
insert_time timestamp&lt;br&gt;
);&lt;/li&gt;
&lt;li&gt;复制表：
&lt;ul&gt;
&lt;li&gt;create table 表名 like 被复制的表名；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R (Retrieve)：查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询某个数据库中所有的表名称
&lt;ul&gt;
&lt;li&gt;show tables;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查询表结构
&lt;ul&gt;
&lt;li&gt;desc 表名；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;U (Update): 修改&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改表名&lt;br&gt;
 alter table 表名 rename to 新的表名；&lt;/li&gt;
&lt;li&gt;修改表的字符集&lt;br&gt;
 alter table 表名 character set 字符集名称；&lt;/li&gt;
&lt;li&gt;添加一列&lt;br&gt;
 alter table 表名 add 列名 数据类型；&lt;/li&gt;
&lt;li&gt;修改列名称 类型&lt;br&gt;
 alter table 表名 change 列名 新列别 新数据类型；&lt;br&gt;
alter table 表名 modify 列名 新数据类型；&lt;/li&gt;
&lt;li&gt;删除列&lt;br&gt;
 alter table 表名 drop 列名；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;D (Delete): 删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drop table 表名；&lt;/li&gt;
&lt;li&gt;drop table  if exists 表名；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;客户端图形化工具：SQLYog&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dml增删改表中数据&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dml增删改表中数据&#34;&gt;#&lt;/a&gt; DML：增删改表中数据&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;添加数据：
&lt;ul&gt;
&lt;li&gt;语法：
&lt;ul&gt;
&lt;li&gt;insert into 表名 (列名 1, 列名 2,... 列名 n) values (值 1, 值 2,... 值 n);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ol&gt;
&lt;li&gt;列名和值要一一对应。&lt;/li&gt;
&lt;li&gt;如果表名后，不定义列名，则默认给所有列添加值&lt;br&gt;
 insert into 表名 values (值 1, 值 2,... 值 n);&lt;/li&gt;
&lt;li&gt;除了数字类型，其他类型需要使用引号 (单双都可以) 引起来&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除数据：
&lt;ul&gt;
&lt;li&gt;语法：
&lt;ul&gt;
&lt;li&gt;delete from 表名 [where 条件]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ol&gt;
&lt;li&gt;如果不加条件，则删除表中所有记录。&lt;/li&gt;
&lt;li&gt;如果要删除所有记录
&lt;ol&gt;
&lt;li&gt;delete from 表名；-- 不推荐使用。有多少条记录就会执行多少次删除操作&lt;/li&gt;
&lt;li&gt;TRUNCATE TABLE 表名；-- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;修改数据：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;update 表名 set 列名 1 = 值 1, 列名 2 = 值 2,... [where 条件];&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果不加任何条件，则会将表中所有记录全部修改。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dql查询表中的记录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dql查询表中的记录&#34;&gt;#&lt;/a&gt; DQL：查询表中的记录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;select * from 表名；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;br&gt;
select&lt;br&gt;
 字段列表&lt;br&gt;
 from&lt;br&gt;
 表名列表&lt;br&gt;
 where&lt;br&gt;
 条件列表&lt;br&gt;
 group by&lt;br&gt;
 分组字段&lt;br&gt;
 having&lt;br&gt;
 分组之后的条件&lt;br&gt;
 order by&lt;br&gt;
 排序&lt;br&gt;
 limit&lt;br&gt;
 分页限定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基础查询&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个字段的查询&lt;br&gt;
 select 字段名 1，字段名 2... from 表名；
&lt;ul&gt;
&lt;li&gt;注意：
&lt;ul&gt;
&lt;li&gt;如果查询所有字段，则可以使用 * 来替代字段列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;去除重复：
&lt;ul&gt;
&lt;li&gt;distinct&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算列
&lt;ul&gt;
&lt;li&gt;一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）&lt;/li&gt;
&lt;li&gt;ifnull (表达式 1, 表达式 2)：null 参与的运算，计算结果都为 null
&lt;ul&gt;
&lt;li&gt;表达式 1：哪个字段需要判断是否为 null&lt;/li&gt;
&lt;li&gt;如果该字段为 null 后的替换值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;起别名：
&lt;ul&gt;
&lt;li&gt;as：as 也可以省略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件查询&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;where 子句后跟条件&lt;/li&gt;
&lt;li&gt;运算符
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;、&amp;lt; 、&amp;lt;= 、&amp;gt;= 、= 、&amp;lt;&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BETWEEN...AND&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN (集合)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LIKE：模糊查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;占位符：
&lt;ul&gt;
&lt;li&gt;_: 单个任意字符&lt;/li&gt;
&lt;li&gt;%：多个任意字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IS NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and  或 &amp;amp;&amp;amp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;or  或 ||&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;not  或！&lt;/p&gt;
&lt;p&gt;-- 查询年龄大于 20 岁&lt;/p&gt;
&lt;p&gt;SELECT * FROM student WHERE age &amp;gt; 20;&lt;/p&gt;
&lt;p&gt;SELECT * FROM student WHERE age &amp;gt;= 20;&lt;/p&gt;
&lt;p&gt;-- 查询年龄等于 20 岁&lt;br&gt;
 SELECT * FROM student WHERE age = 20;&lt;/p&gt;
&lt;p&gt;-- 查询年龄不等于 20 岁&lt;br&gt;
 SELECT * FROM student WHERE age != 20;&lt;br&gt;
SELECT * FROM student WHERE age &amp;lt;&amp;gt; 20;&lt;/p&gt;
&lt;p&gt;-- 查询年龄大于等于 20 小于等于 30&lt;/p&gt;
&lt;p&gt;SELECT * FROM student WHERE age &amp;gt;= 20 &amp;amp;&amp;amp;  age &amp;lt;=30;&lt;br&gt;
SELECT * FROM student WHERE age &amp;gt;= 20 AND  age &amp;lt;=30;&lt;br&gt;
SELECT * FROM student WHERE age BETWEEN 20 AND 30;&lt;/p&gt;
&lt;p&gt;-- 查询年龄 22 岁，18 岁，25 岁的信息&lt;br&gt;
 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25&lt;br&gt;
SELECT * FROM student WHERE age IN (22,18,25);&lt;/p&gt;
&lt;p&gt;-- 查询英语成绩为 null&lt;br&gt;
SELECT * FROM student WHERE english = NULL; -- 不对的。null 值不能使用 = （!=） 判断&lt;/p&gt;
&lt;p&gt;SELECT * FROM student WHERE english IS NULL;&lt;/p&gt;
&lt;p&gt;-- 查询英语成绩不为 null&lt;br&gt;
SELECT * FROM student WHERE english  IS NOT NULL;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​			-- 查询姓马的有哪些？ like&lt;br&gt;
​			SELECT * FROM student WHERE NAME LIKE &#39; 马 %&#39;;&lt;br&gt;
​			-- 查询姓名第二个字是化的人&lt;br&gt;
​			&lt;br&gt;
​			SELECT * FROM student WHERE NAME LIKE &#34;&lt;em&gt;化 %&#34;;&lt;br&gt;
​			&lt;br&gt;
​			-- 查询姓名是 3 个字的人&lt;br&gt;
​			SELECT * FROM student WHERE NAME LIKE &#39;&lt;/em&gt;__&#39;;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​			-- 查询姓名中包含德的人&lt;br&gt;
​			SELECT * FROM student WHERE NAME LIKE &#39;% 德 %&#39;;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/09/30/MySQL%E5%A4%9A%E8%A1%A8-%E4%BA%8B%E5%8A%A1/</guid>
            <title>MySQL多表和事务</title>
            <link>https://www.baocai-blog.cn/2020/09/30/MySQL%E5%A4%9A%E8%A1%A8-%E4%BA%8B%E5%8A%A1/</link>
            <category>MySQL</category>
            <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;hr&gt;
&lt;h1 id=&#34;目录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#目录&#34;&gt;#&lt;/a&gt; 目录&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;多表查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCL&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多表查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多表查询&#34;&gt;#&lt;/a&gt; 多表查询：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查询语法：&lt;br&gt;
select&lt;br&gt;
 列名列表&lt;br&gt;
 from&lt;br&gt;
 表名列表&lt;br&gt;
 where....&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备 sql&lt;/p&gt;
&lt;h3 id=&#34;创建部门表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建部门表&#34;&gt;#&lt;/a&gt; 创建部门表&lt;/h3&gt;
&lt;p&gt;CREATE TABLE dept(&lt;br&gt;
id INT PRIMARY KEY AUTO_INCREMENT,&lt;br&gt;
NAME VARCHAR(20)&lt;br&gt;
);&lt;br&gt;
INSERT INTO dept (NAME) VALUES (&#39; 开发部 &#39;),(&#39; 市场部 &#39;),(&#39; 财务部 &#39;);&lt;/p&gt;
&lt;h3 id=&#34;创建员工表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建员工表&#34;&gt;#&lt;/a&gt; 创建员工表&lt;/h3&gt;
&lt;p&gt;CREATE TABLE emp (&lt;br&gt;
id INT PRIMARY KEY AUTO_INCREMENT,&lt;br&gt;
NAME VARCHAR(10),&lt;br&gt;
gender CHAR (1), -- 性别&lt;br&gt;
 salary DOUBLE, -- 工资&lt;br&gt;
 join_date DATE, -- 入职日期&lt;br&gt;
 dept_id INT,&lt;br&gt;
FOREIGN KEY (dept_id) REFERENCES dept (id) -- 外键，关联部门表 (部门表的主键)&lt;br&gt;
);&lt;br&gt;
INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (&#39; 孙悟空 &#39;,&#39; 男 &#39;,7200,&#39;2013-02-24&#39;,1);&lt;br&gt;
INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (&#39; 猪八戒 &#39;,&#39; 男 &#39;,3600,&#39;2010-12-02&#39;,2);&lt;br&gt;
INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (&#39; 唐僧 &#39;,&#39; 男 &#39;,9000,&#39;2008-08-08&#39;,2);&lt;br&gt;
INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (&#39; 白骨精 &#39;,&#39; 女 &#39;,5000,&#39;2015-10-07&#39;,3);&lt;br&gt;
INSERT INTO emp (NAME,gender,salary,join_date,dept_id) VALUES (&#39; 蜘蛛精 &#39;,&#39; 女 &#39;,4500,&#39;2011-03-14&#39;,1);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;笛卡尔积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有两个集合 A,B . 取这两个集合的所有组成情况。&lt;/li&gt;
&lt;li&gt;要完成多表查询，需要消除无用的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多表查询的分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内连接查询：
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;隐式内连接：使用 where 条件消除无用数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：&lt;br&gt;
-- 查询所有员工信息和对应的部门信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SELECT * FROM emp,dept WHERE emp. &lt;code&gt;dept_id&lt;/code&gt;  = dept. &lt;code&gt;id&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;-- 查询员工表的名称，性别。部门表的名称&lt;br&gt;
 SELECT &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2VtcC5uYW1l&#34;&gt;emp.name&lt;/span&gt;,emp.gender,&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2RlcHQubmFtZQ==&#34;&gt;dept.name&lt;/span&gt; FROM emp,dept WHERE emp. &lt;code&gt;dept_id&lt;/code&gt;  = dept. &lt;code&gt;id&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;SELECT&lt;br&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3QxLm5hbWU=&#34;&gt;t1.name&lt;/span&gt;, -- 员工表的姓名&lt;br&gt;
 t1.gender,-- 员工表的性别&lt;br&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3QyLm5hbWU=&#34;&gt; t2.name&lt;/span&gt; -- 部门表的名称&lt;br&gt;
 FROM&lt;br&gt;
emp t1,&lt;br&gt;
dept t2&lt;br&gt;
WHERE&lt;br&gt;
t1. &lt;code&gt;dept_id&lt;/code&gt;  = t2. &lt;code&gt;id&lt;/code&gt; ;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	&lt;br&gt;
​		2. 显式内连接：&lt;br&gt;
​			* 语法： select 字段列表 from 表名 1 [inner] join 表名 2 on 条件&lt;br&gt;
​			* 例如：&lt;br&gt;
​				* SELECT * FROM emp INNER JOIN dept ON emp. &lt;code&gt;dept_id&lt;/code&gt;  = dept. &lt;code&gt;id&lt;/code&gt; ;	&lt;br&gt;
​				* SELECT * FROM emp JOIN dept ON emp. &lt;code&gt;dept_id&lt;/code&gt;  = dept. &lt;code&gt;id&lt;/code&gt; ;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3. 内连接查询：
	1. 从哪些表中查询数据
	2. 条件是什么
	3. 查询哪些字段
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;外链接查询：
&lt;ol&gt;
&lt;li&gt;左外连接：
&lt;ul&gt;
&lt;li&gt;语法：select 字段列表 from 表 1 left [outer] join 表 2 on 条件；&lt;/li&gt;
&lt;li&gt;查询的是左表所有数据以及其交集部分。&lt;/li&gt;
&lt;li&gt;例子：&lt;br&gt;
-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称&lt;br&gt;
 SELECT 	t1.*,t2. &lt;code&gt;name&lt;/code&gt;  FROM emp t1 LEFT JOIN dept t2 ON t1. &lt;code&gt;dept_id&lt;/code&gt;  = t2. &lt;code&gt;id&lt;/code&gt; ;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;右外连接：
&lt;ul&gt;
&lt;li&gt;语法：select 字段列表 from 表 1 right [outer] join 表 2 on 条件；&lt;/li&gt;
&lt;li&gt;查询的是右表所有数据以及其交集部分。&lt;/li&gt;
&lt;li&gt;例子：&lt;br&gt;
SELECT 	* FROM dept t2 RIGHT JOIN emp t1 ON t1. &lt;code&gt;dept_id&lt;/code&gt;  = t2. &lt;code&gt;id&lt;/code&gt; ;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;子查询：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念：查询中嵌套查询，称嵌套查询为子查询。&lt;br&gt;
-- 查询工资最高的员工信息&lt;br&gt;
 -- 1 查询最高的工资是多少 9000&lt;br&gt;
SELECT MAX(salary) FROM emp;&lt;/p&gt;
&lt;p&gt;-- 2 查询员工信息，并且工资等于 9000 的&lt;br&gt;
 SELECT * FROM emp WHERE emp. &lt;code&gt;salary&lt;/code&gt;  = 9000;&lt;/p&gt;
&lt;p&gt;-- 一条 sql 就完成这个操作。子查询&lt;br&gt;
 SELECT * FROM emp WHERE emp. &lt;code&gt;salary&lt;/code&gt;  = (SELECT MAX(salary) FROM emp);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子查询不同情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;子查询的结果是单行单列的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子查询可以作为条件，使用运算符去判断。 运算符： &amp;gt; &amp;gt;= &amp;lt; &amp;lt;= =&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-- 查询员工工资小于平均工资的人&lt;br&gt;
 SELECT * FROM emp WHERE emp.salary &amp;lt;(SELECT AVG (salary) FROM emp);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子查询的结果是多行单列的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子查询可以作为条件，使用运算符 in 来判断&lt;br&gt;
 -- 查询 &#39; 财务部 &#39; 和&#39; 市场部 &#39; 所有的员工信息&lt;br&gt;
 SELECT id FROM dept WHERE NAME = &#39; 财务部 &#39; OR NAME = &#39; 市场部 &#39;;&lt;br&gt;
SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;&lt;br&gt;
-- 子查询&lt;br&gt;
 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39; 财务部 &#39; OR NAME = &#39; 市场部 &#39;);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子查询的结果是多行多列的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子查询可以作为一张虚拟表参与查询&lt;br&gt;
 -- 查询员工入职日期是 2011-11-11 日之后的员工信息和部门信息&lt;br&gt;
 -- 子查询&lt;br&gt;
 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp. &lt;code&gt;join_date&lt;/code&gt;  &amp;gt; &#39;2011-11-11&#39;) t2&lt;br&gt;
WHERE &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3QxLmlk&#34;&gt;t1.id&lt;/span&gt; = t2.dept_id;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-- 普通内连接&lt;br&gt;
 SELECT * FROM emp t1,dept t2 WHERE t1. &lt;code&gt;dept_id&lt;/code&gt;  = t2. &lt;code&gt;id&lt;/code&gt;  AND t1. &lt;code&gt;join_date&lt;/code&gt;  &amp;gt;  &#39;2011-11-11&#39;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多表查询练习&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  -- 部门表
  CREATE TABLE dept (
    id INT PRIMARY KEY PRIMARY KEY, -- 部门id
    dname VARCHAR(50), -- 部门名称
    loc VARCHAR(50) -- 部门所在地
  );
  
  -- 添加4个部门
  INSERT INTO dept(id,dname,loc) VALUES 
  (10,&#39;教研部&#39;,&#39;北京&#39;),
  (20,&#39;学工部&#39;,&#39;上海&#39;),
  (30,&#39;销售部&#39;,&#39;广州&#39;),
  (40,&#39;财务部&#39;,&#39;深圳&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​				&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;​			-- 职务表，职务名称，职务描述&lt;br&gt;
​			CREATE TABLE job (&lt;br&gt;
​			  id INT PRIMARY KEY,&lt;br&gt;
​			  jname VARCHAR(20),&lt;br&gt;
​			  description VARCHAR(50)&lt;br&gt;
​			);&lt;br&gt;
​			&lt;br&gt;
​			-- 添加 4 个职务&lt;br&gt;
​			INSERT INTO job (id, jname, description) VALUES&lt;br&gt;
​			(1, &#39; 董事长 &#39;, &#39; 管理整个公司，接单 &#39;),&lt;br&gt;
​			(2, &#39; 经理 &#39;, &#39; 管理部门员工 &#39;),&lt;br&gt;
​			(3, &#39; 销售员 &#39;, &#39; 向客人推销产品 &#39;),&lt;br&gt;
​			(4, &#39; 文员 &#39;, &#39; 使用办公软件 &#39;);&lt;/p&gt;
&lt;p&gt;​				&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;​			-- 员工表&lt;br&gt;
​			CREATE TABLE emp (&lt;br&gt;
​			  id INT PRIMARY KEY, -- 员工 id&lt;br&gt;
​			  ename VARCHAR (50), -- 员工姓名&lt;br&gt;
​			  job_id INT, -- 职务 id&lt;br&gt;
​			  mgr INT , -- 上级领导&lt;br&gt;
​			  joindate DATE, -- 入职日期&lt;br&gt;
​			  salary DECIMAL (7,2), -- 工资&lt;br&gt;
​			  bonus DECIMAL (7,2), -- 奖金&lt;br&gt;
​			  dept_id INT, -- 所在部门编号&lt;br&gt;
​			  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),&lt;br&gt;
​			  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)&lt;br&gt;
​			);&lt;br&gt;
​			&lt;br&gt;
​			-- 添加员工&lt;br&gt;
​			INSERT INTO emp (id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES&lt;br&gt;
​			(1001,&#39; 孙悟空 &#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),&lt;br&gt;
​			(1002,&#39; 卢俊义 &#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),&lt;br&gt;
​			(1003,&#39; 林冲 &#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),&lt;br&gt;
​			(1004,&#39; 唐僧 &#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),&lt;br&gt;
​			(1005,&#39; 李逵 &#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),&lt;br&gt;
​			(1006,&#39; 宋江 &#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),&lt;br&gt;
​			(1007,&#39; 刘备 &#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),&lt;br&gt;
​			(1008,&#39; 猪八戒 &#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),&lt;br&gt;
​			(1009,&#39; 罗贯中 &#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),&lt;br&gt;
​			(1010,&#39; 吴用 &#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),&lt;br&gt;
​			(1011,&#39; 沙僧 &#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),&lt;br&gt;
​			(1012,&#39; 李逵 &#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),&lt;br&gt;
​			(1013,&#39; 小白龙 &#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),&lt;br&gt;
​			(1014,&#39; 关羽 &#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);&lt;/p&gt;
&lt;p&gt;​				&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;​			-- 工资等级表&lt;br&gt;
​			CREATE TABLE salarygrade (&lt;br&gt;
​			  grade INT PRIMARY KEY,   -- 级别&lt;br&gt;
​			  losalary INT,  -- 最低工资&lt;br&gt;
​			  hisalary INT -- 最高工资&lt;br&gt;
​			);&lt;br&gt;
​			&lt;br&gt;
​			-- 添加 5 个工资等级&lt;br&gt;
​			INSERT INTO salarygrade (grade,losalary,hisalary) VALUES&lt;br&gt;
​			(1,7000,12000),&lt;br&gt;
​			(2,12010,14000),&lt;br&gt;
​			(3,14010,20000),&lt;br&gt;
​			(4,20010,30000),&lt;br&gt;
​			(5,30010,99990);&lt;br&gt;
​			&lt;br&gt;
​			-- 需求：&lt;br&gt;
​			&lt;br&gt;
​			-- 1. 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述&lt;br&gt;
​			/*&lt;br&gt;
​				分析：&lt;br&gt;
​					1. 员工编号，员工姓名，工资，需要查询 emp 表  职务名称，职务描述 需要查询 job 表&lt;br&gt;
​					2. 查询条件 emp.job_id = &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2pvYi5pZA==&#34;&gt;job.id&lt;/span&gt;&lt;br&gt;
​			&lt;br&gt;
​			*/&lt;br&gt;
​			SELECT&lt;br&gt;
​				t1. &lt;code&gt;id&lt;/code&gt; , -- 员工编号&lt;br&gt;
​				t1. &lt;code&gt;ename&lt;/code&gt; , -- 员工姓名&lt;br&gt;
​				t1. &lt;code&gt;salary&lt;/code&gt; ,-- 工资&lt;br&gt;
​				t2. &lt;code&gt;jname&lt;/code&gt; , -- 职务名称&lt;br&gt;
​				t2. &lt;code&gt;description&lt;/code&gt;  -- 职务描述&lt;br&gt;
​			FROM&lt;br&gt;
​				emp t1, job t2&lt;br&gt;
​			WHERE&lt;br&gt;
​				t1. &lt;code&gt;job_id&lt;/code&gt;  = t2. &lt;code&gt;id&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;​				&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;​			-- 2. 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置&lt;br&gt;
​			/*&lt;br&gt;
​				分析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;			1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept
			2. 条件： emp.job_id = job.id and emp.dept_id = dept.id
	*/
	
	SELECT 
		t1.`id`, -- 员工编号
		t1.`ename`, -- 员工姓名
		t1.`salary`,-- 工资
		t2.`jname`, -- 职务名称
		t2.`description`, -- 职务描述
		t3.`dname`, -- 部门名称
		t3.`loc` -- 部门位置
	FROM 
		emp t1, job t2,dept t3
	WHERE 
		t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;
	
	-- 3.查询员工姓名，工资，工资等级
	/*
		分析：
			1.员工姓名，工资 emp  工资等级 salarygrade
			2.条件 emp.salary &amp;gt;= salarygrade.losalary and emp.salary &amp;lt;= salarygrade.hisalary
				emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
	*/
	SELECT 
		t1.ename ,
		t1.`salary`,
		t2.*
	FROM emp t1, salarygrade t2
	WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​				&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;​			-- 4. 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级&lt;br&gt;
​			/*&lt;br&gt;
​				分析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;			1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade
			2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
				
	*/
	SELECT 
		t1.`ename`,
		t1.`salary`,
		t2.`jname`,
		t2.`description`,
		t3.`dname`,
		t3.`loc`,
		t4.`grade`
	FROM 
		emp t1,job t2,dept t3,salarygrade t4
	WHERE 
		t1.`job_id` = t2.`id` 
		AND t1.`dept_id` = t3.`id`
		AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​				&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;​			-- 5. 查询出部门编号、部门名称、部门位置、部门人数&lt;br&gt;
​			&lt;br&gt;
​			/*&lt;br&gt;
​				分析：&lt;br&gt;
​					1. 部门编号、部门名称、部门位置 dept 表。 部门人数 emp 表&lt;br&gt;
​					2. 使用分组查询。按照 emp.dept_id 完成分组，查询 count (id)&lt;br&gt;
​					3. 使用子查询将第 2 步的查询结果和 dept 表进行关联查询&lt;br&gt;
​					&lt;br&gt;
​			*/&lt;br&gt;
​			SELECT&lt;br&gt;
​				t1. &lt;code&gt;id&lt;/code&gt; ,t1. &lt;code&gt;dname&lt;/code&gt; ,t1. &lt;code&gt;loc&lt;/code&gt;  , t2.total&lt;br&gt;
​			FROM&lt;br&gt;
​				dept t1,&lt;br&gt;
​				(SELECT&lt;br&gt;
​					dept_id,COUNT(id) total&lt;br&gt;
​				FROM&lt;br&gt;
​					emp&lt;br&gt;
​				GROUP BY dept_id) t2&lt;br&gt;
​			WHERE t1. &lt;code&gt;id&lt;/code&gt;  = t2.dept_id;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​			-- 6. 查询所有员工的姓名及其直接上级的姓名，没有领导的员工也需要查询&lt;br&gt;
​			&lt;br&gt;
​			/*&lt;br&gt;
​				分析：&lt;br&gt;
​					1. 姓名 emp， 直接上级的姓名 emp&lt;/p&gt;
&lt;h2 id=&#34;事务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#事务&#34;&gt;#&lt;/a&gt; 事务&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;事务的基本介绍
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启事务： start transaction;&lt;/li&gt;
&lt;li&gt;回滚：rollback;&lt;/li&gt;
&lt;li&gt;提交：commit;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例子：&lt;br&gt;
CREATE TABLE account (&lt;br&gt;
id INT PRIMARY KEY AUTO_INCREMENT,&lt;br&gt;
NAME VARCHAR(10),&lt;br&gt;
balance DOUBLE&lt;br&gt;
);&lt;br&gt;
-- 添加数据&lt;br&gt;
 INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		SELECT * FROM account;&lt;br&gt;
​		UPDATE account SET balance = 1000;&lt;br&gt;
​		-- 张三给李四转账 500 元&lt;br&gt;
​		&lt;br&gt;
​		-- 0. 开启事务&lt;br&gt;
​		START TRANSACTION;&lt;br&gt;
​		-- 1. 张三账户 -500&lt;br&gt;
​		&lt;br&gt;
​		UPDATE account SET balance = balance - 500 WHERE NAME = &#39;zhangsan&#39;;&lt;br&gt;
​		-- 2. 李四账户 +500&lt;br&gt;
​		-- 出错了...&lt;br&gt;
​		UPDATE account SET balance = balance + 500 WHERE NAME = &#39;lisi&#39;;&lt;br&gt;
​		&lt;br&gt;
​		-- 发现执行没有问题，提交事务&lt;br&gt;
​		COMMIT;&lt;br&gt;
​		&lt;br&gt;
​		-- 发现出问题了，回滚事务&lt;br&gt;
​		ROLLBACK;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;MySQL 数据库中事务默认自动提交&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务提交的两种方式：
&lt;ul&gt;
&lt;li&gt;自动提交：
&lt;ul&gt;
&lt;li&gt;mysql 就是自动提交的&lt;/li&gt;
&lt;li&gt;一条 DML (增删改) 语句会自动提交一次事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;手动提交：
&lt;ul&gt;
&lt;li&gt;Oracle 数据库默认是手动提交事务&lt;/li&gt;
&lt;li&gt;需要先开启事务，再提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;修改事务的默认提交方式：
&lt;ul&gt;
&lt;li&gt;查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交&lt;/li&gt;
&lt;li&gt;修改默认提交方式： set @@autocommit = 0;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务的四大特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。&lt;/li&gt;
&lt;li&gt;持久性：当事务提交或回滚后，数据库会持久化的保存数据。&lt;/li&gt;
&lt;li&gt;隔离性：多个事务之间。相互独立。&lt;/li&gt;
&lt;li&gt;一致性：事务操作前后，数据总量不变&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务的隔离级别（了解）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存在问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;脏读：一个事务，读取到另一个事务中没有提交的数据&lt;/li&gt;
&lt;li&gt;不可重复读 (虚读)：在同一个事务中，两次读取到的数据不一样。&lt;/li&gt;
&lt;li&gt;幻读：一个事务操作 (DML) 数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隔离级别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;read uncommitted：读未提交
&lt;ul&gt;
&lt;li&gt;产生的问题：脏读、不可重复读、幻读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;read committed：读已提交 （Oracle）
&lt;ul&gt;
&lt;li&gt;产生的问题：不可重复读、幻读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;repeatable read：可重复读 （MySQL 默认）
&lt;ul&gt;
&lt;li&gt;产生的问题：幻读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;serializable：串行化
&lt;ul&gt;
&lt;li&gt;可以解决所有的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;注意：隔离级别从小到大安全性越来越高，但是效率越来越低&lt;/li&gt;
&lt;li&gt;数据库查询隔离级别：
&lt;ul&gt;
&lt;li&gt;select @@tx_isolation;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库设置隔离级别：
&lt;ul&gt;
&lt;li&gt;set global transaction isolation level  级别字符串；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;演示：&lt;br&gt;
set global transaction isolation level read uncommitted;&lt;br&gt;
start transaction;&lt;br&gt;
-- 转账操作&lt;br&gt;
 update account set balance = balance - 500 where id = 1;&lt;br&gt;
update account set balance = balance + 500 where id = 2;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dcl&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dcl&#34;&gt;#&lt;/a&gt; DCL：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQL 分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DDL：操作数据库和表&lt;/li&gt;
&lt;li&gt;DML：增删改表中数据&lt;/li&gt;
&lt;li&gt;DQL：查询表中数据&lt;/li&gt;
&lt;li&gt;DCL：管理用户，授权&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DBA：数据库管理员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCL：管理用户，授权&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理用户
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加用户：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法：CREATE USER &#39; 用户名 &#39;@&#39; 主机名 &#39; IDENTIFIED BY &#39; 密码 &#39;;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除用户：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法：DROP USER &#39; 用户名 &#39;@&#39; 主机名 &#39;;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改用户密码：&lt;/p&gt;
&lt;p&gt;UPDATE USER SET PASSWORD = PASSWORD (&#39; 新密码 &#39;) WHERE USER = &#39; 用户名 &#39;;&lt;br&gt;
UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SET PASSWORD FOR &#39; 用户名 &#39;@&#39; 主机名 &#39; = PASSWORD (&#39; 新密码 &#39;);&lt;br&gt;
SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql 中忘记了 root 用户的密码？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;cmd -- &amp;gt; net stop mysql 停止 mysql 服务&lt;br&gt;
 * 需要管理员运行该 cmd&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
 4. use mysql;
 5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;
 6. 关闭两个窗口
 7. 打开任务管理器，手动结束mysqld.exe 的进程
 8. 启动mysql服务
 9. 使用新密码登录。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询用户：&lt;br&gt;
-- 1. 切换到 mysql 数据库&lt;br&gt;
 USE myql;&lt;br&gt;
-- 2. 查询 user 表&lt;br&gt;
 SELECT * FROM USER;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通配符： % 表示可以在任意主机使用用户登录数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;权限管理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询权限：&lt;br&gt;
-- 查询权限&lt;br&gt;
 SHOW GRANTS FOR &#39; 用户名 &#39;@&#39; 主机名 &#39;;&lt;br&gt;
SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;授予权限：&lt;br&gt;
-- 授予权限&lt;br&gt;
 grant 权限列表 on 数据库名。表名 to &#39; 用户名 &#39;@&#39; 主机名 &#39;;&lt;br&gt;
-- 给张三用户授予所有权限，在任意数据库任意表上&lt;/p&gt;
&lt;p&gt;GRANT ALL ON &lt;em&gt;.&lt;/em&gt; TO &#39;zhangsan&#39;@&#39;localhost&#39;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;撤销权限：&lt;br&gt;
-- 撤销权限：&lt;br&gt;
revoke 权限列表 on 数据库名。表名 from &#39; 用户名 &#39;@&#39; 主机名 &#39;;&lt;br&gt;
REVOKE UPDATE ON db3. &lt;code&gt;account&lt;/code&gt;  FROM &#39;lisi&#39;@&#39;%&#39;;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/09/30/MySQL%E7%BA%A6%E6%9D%9F/</guid>
            <title>MySQL约束</title>
            <link>https://www.baocai-blog.cn/2020/09/30/MySQL%E7%BA%A6%E6%9D%9F/</link>
            <category>MySQL</category>
            <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h1 id=&#34;目录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#目录&#34;&gt;#&lt;/a&gt; 目录&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DQL: 查询语句&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;排序查询&lt;/li&gt;
&lt;li&gt;聚合函数&lt;/li&gt;
&lt;li&gt;分组查询&lt;/li&gt;
&lt;li&gt;分页查询&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多表之间的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库的备份和还原&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dql查询语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dql查询语句&#34;&gt;#&lt;/a&gt; DQL: 查询语句&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;排序查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法：order by 子句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order by 排序字段 1 排序方式 1 ，  排序字段 2 排序方式 2...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排序方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ASC：升序，默认的。&lt;/li&gt;
&lt;li&gt;DESC：降序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;聚合函数：将一列数据作为一个整体，进行纵向的计算。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;count：计算个数
&lt;ol&gt;
&lt;li&gt;一般选择非空的列：主键&lt;/li&gt;
&lt;li&gt;count(*)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;max：计算最大值&lt;/li&gt;
&lt;li&gt;min：计算最小值&lt;/li&gt;
&lt;li&gt;sum：计算和&lt;/li&gt;
&lt;li&gt;avg：计算平均值&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;注意：聚合函数的计算，排除 null 值。&lt;br&gt;
解决方案：&lt;br&gt;
1. 选择不包含非空的列进行计算&lt;br&gt;
 2. IFNULL 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分组查询:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;语法：group by 分组字段；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分组之后查询的字段：分组字段、聚合函数&lt;/li&gt;
&lt;li&gt;where 和 having 的区别？
&lt;ol&gt;
&lt;li&gt;where 在分组之前进行限定，如果不满足条件，则不参与分组。having 在分组之后进行限定，如果不满足结果，则不会被查询出来&lt;/li&gt;
&lt;li&gt;where 后不可以跟聚合函数，having 可以进行聚合函数的判断。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-- 按照性别分组。分别查询男、女同学的平均分&lt;/p&gt;
&lt;p&gt;SELECT sex , AVG(math) FROM student GROUP BY sex;&lt;/p&gt;
&lt;p&gt;-- 按照性别分组。分别查询男、女同学的平均分，人数&lt;/p&gt;
&lt;p&gt;SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;&lt;/p&gt;
&lt;p&gt;--  按照性别分组。分别查询男、女同学的平均分，人数 要求：分数低于 70 分的人，不参与分组&lt;br&gt;
 SELECT sex , AVG (math),COUNT (id) FROM student WHERE math &amp;gt; 70 GROUP BY sex;&lt;/p&gt;
&lt;p&gt;--  按照性别分组。分别查询男、女同学的平均分，人数 要求：分数低于 70 分的人，不参与分组，分组之后。人数要大于 2 个人&lt;br&gt;
 SELECT sex , AVG (math),COUNT (id) FROM student WHERE math &amp;gt; 70 GROUP BY sex HAVING COUNT (id) &amp;gt; 2;&lt;/p&gt;
&lt;p&gt;SELECT sex , AVG (math),COUNT (id) 人数 FROM student WHERE math &amp;gt; 70 GROUP BY sex HAVING 人数 &amp;gt; 2;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​			&lt;br&gt;
4. 分页查询&lt;br&gt;
 1. 语法：limit 开始的索引，每页查询的条数；&lt;br&gt;
2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数&lt;br&gt;
 -- 每页显示 3 条记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	SELECT * FROM student LIMIT 0,3; -- 第1页
	
	SELECT * FROM student LIMIT 3,3; -- 第2页
	
	SELECT * FROM student LIMIT 6,3; -- 第3页

3. limit 是一个MySQL&#34;方言&#34;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;约束&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#约束&#34;&gt;#&lt;/a&gt; 约束&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主键约束：primary key&lt;/li&gt;
&lt;li&gt;非空约束：not null&lt;/li&gt;
&lt;li&gt;唯一约束：unique&lt;/li&gt;
&lt;li&gt;外键约束：foreign key&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非空约束：not null，某一列的值不能为 null&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建表时添加约束&lt;br&gt;
 CREATE TABLE stu (&lt;br&gt;
id INT,&lt;br&gt;
NAME VARCHAR (20) NOT NULL -- name 为非空&lt;br&gt;
);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建表完后，添加非空约束&lt;br&gt;
 ALTER TABLE stu MODIFY NAME VARCHAR (20) NOT NULL;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除 name 的非空约束&lt;br&gt;
 ALTER TABLE stu MODIFY NAME VARCHAR (20);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;唯一约束：unique，某一列的值不能重复&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注意：
&lt;ul&gt;
&lt;li&gt;唯一约束可以有 NULL 值，但是只能有一条记录为 null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在创建表时，添加唯一约束&lt;br&gt;
 CREATE TABLE stu (&lt;br&gt;
id INT,&lt;br&gt;
phone_number VARCHAR (20) UNIQUE -- 手机号&lt;br&gt;
);&lt;/li&gt;
&lt;li&gt;删除唯一约束&lt;br&gt;
 ALTER TABLE stu DROP INDEX phone_number;&lt;/li&gt;
&lt;li&gt;在表创建完后，添加唯一约束&lt;br&gt;
 ALTER TABLE stu MODIFY phone_number VARCHAR (20) UNIQUE;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主键约束：primary key。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;含义：非空且唯一&lt;/li&gt;
&lt;li&gt;一张表只能有一个字段为主键&lt;/li&gt;
&lt;li&gt;主键就是表中记录的唯一标识&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在创建表时，添加主键约束&lt;br&gt;
 create table stu (&lt;br&gt;
id int primary key,-- 给 id 添加主键约束&lt;br&gt;
 name varchar (20)&lt;br&gt;
);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除主键&lt;br&gt;
 -- 错误 alter table stu modify id int ;&lt;br&gt;
ALTER TABLE stu DROP PRIMARY KEY;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建完表后，添加主键&lt;br&gt;
 ALTER TABLE stu MODIFY id INT PRIMARY KEY;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动增长：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在创建表时，添加主键约束，并且完成主键自增长&lt;br&gt;
 create table stu (&lt;br&gt;
id int primary key auto_increment,-- 给 id 添加主键约束&lt;br&gt;
 name varchar (20)&lt;br&gt;
);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​			&lt;br&gt;
​		3. 删除自动增长&lt;br&gt;
​		ALTER TABLE stu MODIFY id INT;&lt;br&gt;
​		4. 添加自动增长&lt;br&gt;
​		ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外键约束：foreign key, 让表于表产生关系，从而保证数据的正确性。
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在创建表时，可以添加外键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法：&lt;br&gt;
create table 表名 (&lt;br&gt;
....&lt;br&gt;
 外键列&lt;br&gt;
 constraint 外键名称 foreign key (外键列名称) references 主表名称 (主表列名称)&lt;br&gt;
);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除外键&lt;br&gt;
 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建表之后，添加外键&lt;br&gt;
 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​		&lt;br&gt;
​	4. 级联操作&lt;br&gt;
​		1. 添加级联操作&lt;br&gt;
​			语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称&lt;br&gt;
​					FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;&lt;br&gt;
​		2. 分类：&lt;br&gt;
​			1. 级联更新：ON UPDATE CASCADE&lt;br&gt;
​			2. 级联删除：ON DELETE CASCADE&lt;/p&gt;
&lt;h2 id=&#34;数据库的设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的设计&#34;&gt;#&lt;/a&gt; 数据库的设计&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多表之间的关系
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一对一 (了解)：
&lt;ul&gt;
&lt;li&gt;如：人和身份证&lt;/li&gt;
&lt;li&gt;分析：一个人只有一个身份证，一个身份证只能对应一个人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一对多 (多对一)：
&lt;ul&gt;
&lt;li&gt;如：部门和员工&lt;/li&gt;
&lt;li&gt;分析：一个部门有多个员工，一个员工只能对应一个部门&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多对多：
&lt;ul&gt;
&lt;li&gt;如：学生和课程&lt;/li&gt;
&lt;li&gt;分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现关系：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一对多 (多对一)：
&lt;ul&gt;
&lt;li&gt;如：部门和员工&lt;/li&gt;
&lt;li&gt;实现方式：在多的一方建立外键，指向一的一方的主键。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多对多：
&lt;ul&gt;
&lt;li&gt;如：学生和课程&lt;/li&gt;
&lt;li&gt;实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一对一 (了解)：
&lt;ul&gt;
&lt;li&gt;如：人和身份证&lt;/li&gt;
&lt;li&gt;实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例&lt;br&gt;
 -- 创建旅游线路分类表 tab_category&lt;br&gt;
-- cid 旅游线路分类主键，自动增长&lt;br&gt;
 -- cname 旅游线路分类名称非空，唯一，字符串 100&lt;br&gt;
CREATE TABLE tab_category (&lt;br&gt;
cid INT PRIMARY KEY AUTO_INCREMENT,&lt;br&gt;
cname VARCHAR(100) NOT NULL UNIQUE&lt;br&gt;
);&lt;/p&gt;
&lt;p&gt;-- 创建旅游线路表 tab_route&lt;br&gt;
/*&lt;br&gt;
rid 旅游线路主键，自动增长&lt;br&gt;
 rname 旅游线路名称非空，唯一，字符串 100&lt;br&gt;
price 价格&lt;br&gt;
 rdate 上架时间，日期类型&lt;br&gt;
 cid 外键，所属分类&lt;br&gt;
 */&lt;br&gt;
CREATE TABLE tab_route(&lt;br&gt;
rid INT PRIMARY KEY AUTO_INCREMENT,&lt;br&gt;
rname VARCHAR(100) NOT NULL UNIQUE,&lt;br&gt;
price DOUBLE,&lt;br&gt;
rdate DATE,&lt;br&gt;
cid INT,&lt;br&gt;
FOREIGN KEY (cid) REFERENCES tab_category(cid)&lt;br&gt;
);&lt;/p&gt;
&lt;p&gt;/* 创建用户表 tab_user&lt;br&gt;
uid 用户主键，自增长&lt;br&gt;
 username 用户名长度 100，唯一，非空&lt;br&gt;
 password 密码长度 30，非空&lt;br&gt;
 name 真实姓名长度 100&lt;br&gt;
birthday 生日&lt;br&gt;
 sex 性别，定长字符串 1&lt;br&gt;
telephone 手机号，字符串 11&lt;br&gt;
email 邮箱，字符串长度 100&lt;br&gt;
*/&lt;br&gt;
CREATE TABLE tab_user (&lt;br&gt;
uid INT PRIMARY KEY AUTO_INCREMENT,&lt;br&gt;
username VARCHAR(100) UNIQUE NOT NULL,&lt;br&gt;
PASSWORD VARCHAR(30) NOT NULL,&lt;br&gt;
NAME VARCHAR(100),&lt;br&gt;
birthday DATE,&lt;br&gt;
sex CHAR (1) DEFAULT &#39; 男 &#39;,&lt;br&gt;
telephone VARCHAR(11),&lt;br&gt;
email VARCHAR(100)&lt;br&gt;
);&lt;/p&gt;
&lt;p&gt;/*&lt;br&gt;
 创建收藏表 tab_favorite&lt;br&gt;
rid 旅游线路 id，外键&lt;br&gt;
 date 收藏时间&lt;br&gt;
 uid 用户 id，外键&lt;br&gt;
 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次&lt;br&gt;
 */&lt;br&gt;
CREATE TABLE tab_favorite (&lt;br&gt;
rid INT, -- 线路 id&lt;br&gt;
DATE DATETIME,&lt;br&gt;
uid INT, -- 用户 id&lt;br&gt;
-- 创建复合主键&lt;br&gt;
 PRIMARY KEY (rid,uid), -- 联合主键&lt;br&gt;
 FOREIGN KEY (rid) REFERENCES tab_route (rid),&lt;br&gt;
FOREIGN KEY(uid) REFERENCES tab_user(uid)&lt;br&gt;
);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h2 id=&#34;数据库设计的范式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库设计的范式&#34;&gt;#&lt;/a&gt; 数据库设计的范式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求&lt;/p&gt;
&lt;p&gt;设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。&lt;br&gt;
目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯 - 科德范式（BCNF）、第四范式 (4NF）和第五范式（5NF，又称完美范式）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一范式（1NF）：每一列都是不可分割的原子数据项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于码（在 1NF 基础上消除非主属性对主码的部分函数依赖）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;几个概念：
&lt;ol&gt;
&lt;li&gt;函数依赖：A--&amp;gt;B, 如果通过 A 属性 (属性组) 的值，可以确定唯一 B 属性的值。则称 B 依赖于 A&lt;br&gt;
 例如：学号 --&amp;gt; 姓名。  （学号，课程名称） --&amp;gt; 分数&lt;/li&gt;
&lt;li&gt;完全函数依赖：A--&amp;gt;B， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。&lt;br&gt;
例如：（学号，课程名称） --&amp;gt; 分数&lt;/li&gt;
&lt;li&gt;部分函数依赖：A--&amp;gt;B， 如果 A 是一个属性组，则 B 属性值得确定只需要依赖于 A 属性组中某一些值即可。&lt;br&gt;
例如：（学号，课程名称） -- &amp;gt; 姓名&lt;/li&gt;
&lt;li&gt;传递函数依赖：A--&amp;gt;B, B -- &amp;gt;C . 如果通过 A 属性 (属性组) 的值，可以确定唯一 B 属性的值，在通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A&lt;br&gt;
 例如：学号 --&amp;gt; 系名，系名 --&amp;gt; 系主任&lt;/li&gt;
&lt;li&gt;码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性 (属性组) 为该表的码&lt;br&gt;
例如：该表中码为：（学号，课程名称）
&lt;ul&gt;
&lt;li&gt;主属性：码属性组中的所有属性&lt;/li&gt;
&lt;li&gt;非主属性：除过码属性组的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三范式（3NF）：在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库的备份和还原&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据库的备份和还原&#34;&gt;#&lt;/a&gt; 数据库的备份和还原&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;命令行：
&lt;ul&gt;
&lt;li&gt;语法：
&lt;ul&gt;
&lt;li&gt;备份： mysqldump -u 用户名 -p 密码 数据库名称 &amp;gt; 保存的路径&lt;/li&gt;
&lt;li&gt;还原：
&lt;ol&gt;
&lt;li&gt;登录数据库&lt;/li&gt;
&lt;li&gt;创建数据库&lt;/li&gt;
&lt;li&gt;使用数据库&lt;/li&gt;
&lt;li&gt;执行文件。source 文件路径&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图形化工具：&lt;/li&gt;
&lt;/ol&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.baocai-blog.cn/2020/09/30/Servlet-HTTP-Request/</guid>
            <title>Servlet-HTTP-Request</title>
            <link>https://www.baocai-blog.cn/2020/09/30/Servlet-HTTP-Request/</link>
            <category>JavaWeb</category>
            <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h1 id=&#34;目录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#目录&#34;&gt;#&lt;/a&gt; 目录：&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Servlet&lt;/li&gt;
&lt;li&gt;HTTP 协议&lt;/li&gt;
&lt;li&gt;Request&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;servlet&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#servlet&#34;&gt;#&lt;/a&gt; Servlet：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Servlet3.0 注解配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Servlet 的体系结构	&lt;br&gt;
Servlet -- 接口&lt;br&gt;
 |&lt;br&gt;
GenericServlet -- 抽象类&lt;br&gt;
 |&lt;br&gt;
HttpServlet  -- 抽象类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GenericServlet：将 Servlet 接口中其他的方法做了默认空实现，只将 service () 方法作为抽象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将来定义 Servlet 类时，可以继承 GenericServlet，实现 service () 方法即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HttpServlet：对 http 协议的一种封装，简化操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义类继承 HttpServlet&lt;/li&gt;
&lt;li&gt;复写 doGet/doPost 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Servlet 相关配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;urlpartten:Servlet 访问路径
&lt;ol&gt;
&lt;li&gt;一个 Servlet 可以定义多个访问路径 ： @WebServlet ({&#34;/d4&#34;,&#34;/dd4&#34;,&#34;/ddd4&#34;})&lt;/li&gt;
&lt;li&gt;路径定义规则：
&lt;ol&gt;
&lt;li&gt;/xxx：路径匹配&lt;/li&gt;
&lt;li&gt;/xxx/xxx: 多层路径，目录结构&lt;/li&gt;
&lt;li&gt;*.do：扩展名匹配&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#http&#34;&gt;#&lt;/a&gt; HTTP：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念：Hyper Text Transfer Protocol 超文本传输协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传输协议：定义了，客户端和服务器端通信时，发送数据的格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于 TCP/IP 的高级协议&lt;/li&gt;
&lt;li&gt;默认端口号：80&lt;/li&gt;
&lt;li&gt;基于请求 / 响应模型的：一次请求对应一次响应&lt;/li&gt;
&lt;li&gt;无状态的：每次请求之间相互独立，不能交互数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;历史版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.0：每一次请求响应都会建立新的连接&lt;/li&gt;
&lt;li&gt;1.1：复用连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求消息数据格式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;请求行&lt;br&gt;
请求方式 请求 url 请求协议 / 版本&lt;br&gt;
 GET /login.html	HTTP/1.1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求方式：
&lt;ul&gt;
&lt;li&gt;HTTP 协议有 7 中请求方式，常用的有 2 种
&lt;ul&gt;
&lt;li&gt;GET：
&lt;ol&gt;
&lt;li&gt;请求参数在请求行中，在 url 后。&lt;/li&gt;
&lt;li&gt;请求的 url 长度有限制的&lt;/li&gt;
&lt;li&gt;不太安全&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;POST：
&lt;ol&gt;
&lt;li&gt;请求参数在请求体中&lt;/li&gt;
&lt;li&gt;请求的 url 长度没有限制的&lt;/li&gt;
&lt;li&gt;相对安全&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求头：客户端浏览器告诉服务器一些信息&lt;br&gt;
请求头名称：请求头值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见的请求头：
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以在服务器端获取该头的信息，解决浏览器的兼容性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Referer：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdC9sb2dpbi5odG1s&#34;&gt;http://localhost/login.html&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;告诉服务器，我 (当前请求) 从哪里来？
&lt;ul&gt;
&lt;li&gt;作用：
&lt;ol&gt;
&lt;li&gt;防盗链：&lt;/li&gt;
&lt;li&gt;统计工作：&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求空行&lt;br&gt;
空行，就是用于分割 POST 请求的请求头，和请求体的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求体 (正文)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装 POST 请求消息的请求参数的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字符串格式：&lt;br&gt;
POST /login.html	HTTP/1.1&lt;br&gt;
Host: localhost&lt;br&gt;
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0&lt;br&gt;
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,&lt;em&gt;/&lt;/em&gt;;q=0.8&lt;br&gt;
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&lt;br&gt;
Accept-Encoding: gzip, deflate&lt;br&gt;
Referer: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdC9sb2dpbi5odG1s&#34;&gt;http://localhost/login.html&lt;/span&gt;&lt;br&gt;
Connection: keep-alive&lt;br&gt;
Upgrade-Insecure-Requests: 1&lt;/p&gt;
&lt;p&gt;username=zhangsan&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应消息数据格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;request&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#request&#34;&gt;#&lt;/a&gt; Request：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;request 对象和 response 对象的原理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;request 和 response 对象是由服务器创建的。我们来使用它们&lt;/li&gt;
&lt;li&gt;request 对象是来获取请求消息，response 对象是来设置响应消息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;request 对象继承体系结构：	&lt;br&gt;
ServletRequest		--	接口&lt;br&gt;
 |	继承&lt;br&gt;
 HttpServletRequest	-- 接口&lt;br&gt;
 |	实现&lt;br&gt;
 org.apache.catalina.connector.RequestFacade 类 (tomcat)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;request 功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取请求消息数据
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取请求行数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET /day14/demo1?name=zhangsan HTTP/1.1&lt;/li&gt;
&lt;li&gt;方法：
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取请求方式 ：GET&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getMethod()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(*) 获取虚拟目录：/day14&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getContextPath()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取 Servlet 路径: /demo1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getServletPath()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取 get 方式请求参数：name=zhangsan&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getQueryString()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(*) 获取请求 URI：/day14/demo1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String getRequestURI():		/day14/demo1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StringBuffer getRequestURL()  :&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdC9kYXkxNC9kZW1vMQ==&#34;&gt;http://localhost/day14/demo1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URL: 统一资源定位符 ： &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdC9kYXkxNC9kZW1vMQ==&#34;&gt;http://localhost/day14/demo1&lt;/span&gt;	中华人民共和国&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URI：统一资源标识符 : /day14/demo1					共和国&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取协议及版本：HTTP/1.1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getProtocol()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取客户机的 IP 地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getRemoteAddr()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取请求头数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法：
&lt;ul&gt;
&lt;li&gt;(*) String getHeader (String name): 通过请求头的名称获取请求头的值&lt;/li&gt;
&lt;li&gt;Enumeration&amp;lt;String&amp;gt; getHeaderNames (): 获取所有的请求头名称&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取请求体数据:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求体：只有 POST 请求方式，才有请求体，在请求体中封装了 POST 请求的请求参数&lt;/li&gt;
&lt;li&gt;步骤：
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取流对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BufferedReader getReader ()：获取字符输入流，只能操作字符数据&lt;/li&gt;
&lt;li&gt;ServletInputStream getInputStream ()：获取字节输入流，可以操作所有类型数据
&lt;ul&gt;
&lt;li&gt;在文件上传知识点后讲解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再从流对象中拿数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​				&lt;br&gt;
​	2. 其他功能：&lt;br&gt;
​		1. 获取请求参数通用方式：不论 get 还是 post 请求方式都可以使用下列方法来获取请求参数&lt;br&gt;
​			1. String getParameter (String name): 根据参数名称获取参数值    username=zs&amp;amp;password=123&lt;br&gt;
​			2. String [] getParameterValues (String name): 根据参数名称获取参数值的数组  hobby=xx&amp;amp;hobby=game&lt;br&gt;
​			3. Enumeration&amp;lt;String&amp;gt; getParameterNames (): 获取所有请求的参数名称&lt;br&gt;
​			4. Map&amp;lt;String,String []&amp;gt; getParameterMap (): 获取所有参数的 map 集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		* 中文乱码问题：
			* get方式：tomcat 8 已经将get方式乱码问题解决了
			* post方式：会乱码
				* 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&#34;utf-8&#34;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​					&lt;br&gt;
​		2. 请求转发：一种在服务器内部的资源跳转方式&lt;br&gt;
​			1. 步骤：&lt;br&gt;
​				1. 通过 request 对象获取请求转发器对象：RequestDispatcher getRequestDispatcher (String path)&lt;br&gt;
​				2. 使用 RequestDispatcher 对象来进行转发：forward (ServletRequest request, ServletResponse response)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		2. 特点：
			1. 浏览器地址栏路径不发生变化
			2. 只能转发到当前服务器内部资源中。
			3. 转发是一次请求
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;案例用户登录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#案例用户登录&#34;&gt;#&lt;/a&gt; 案例：用户登录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户登录案例需求：&lt;br&gt;
1. 编写 login.html 登录页面&lt;br&gt;
 username &amp;amp; password 两个输入框&lt;br&gt;
 2. 使用 Druid 数据库连接池技术，操作 mysql，day14 数据库中 user 表&lt;br&gt;
 3. 使用 JdbcTemplate 技术封装 JDBC&lt;br&gt;
4. 登录成功跳转到 SuccessServlet 展示：登录成功！用户名，欢迎您&lt;br&gt;
 5. 登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建项目，导入 html 页面，配置文件，jar 包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建数据库环境&lt;br&gt;
 CREATE DATABASE day14;&lt;br&gt;
USE day14;&lt;br&gt;
CREATE TABLE USER(&lt;/p&gt;
&lt;p&gt;​	id INT PRIMARY KEY AUTO_INCREMENT,&lt;br&gt;
​	username VARCHAR(32) UNIQUE NOT NULL,&lt;br&gt;
​	PASSWORD VARCHAR(32) NOT NULL&lt;br&gt;
);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建包 cn.itcast.domain, 创建类 User&lt;br&gt;
package cn.itcast.domain;&lt;br&gt;
/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户的实体类&lt;br&gt;
 */&lt;br&gt;
public class User {&lt;/p&gt;
&lt;p&gt;private int id;&lt;br&gt;
private String username;&lt;br&gt;
private String password;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		    public int getId() {&lt;br&gt;
​		        return id;&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    public void setId(int id) {&lt;br&gt;
​		        &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3RoaXMuaWQ=&#34;&gt;this.id&lt;/span&gt; = id;&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    public String getUsername() {&lt;br&gt;
​		        return username;&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    public void setUsername(String username) {&lt;br&gt;
​		        this.username = username;&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    public String getPassword() {&lt;br&gt;
​		        return password;&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    public void setPassword(String password) {&lt;br&gt;
​		        this.password = password;&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    @Override&lt;br&gt;
​		    public String toString() {&lt;br&gt;
​		        return &#34;User{&#34; +&lt;br&gt;
​		                &#34;id=&#34; + id +&lt;br&gt;
​		                &#34;, username=&#39;&#34; + username + &#39;&#39;&#39; +&lt;br&gt;
​		                &#34;, password=&#39;&#34; + password + &#39;&#39;&#39; +&lt;br&gt;
​		                &#39;}&#39;;&lt;br&gt;
​		    }&lt;br&gt;
​		}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4. 创建包cn.itcast.util,编写工具类JDBCUtils
	package cn.itcast.util;

​	import com.alibaba.druid.pool.DruidDataSourceFactory;
​	
​	import javax.sql.DataSource;
​	import javax.xml.crypto.Data;
​	import java.io.IOException;
​	import java.io.InputStream;
​	import java.sql.Connection;
​	import java.sql.SQLException;
​	import java.util.Properties;
​	
​	/**
	 * JDBC工具类 使用Durid连接池
	 */
	public class JDBCUtils {
	
	​    private static DataSource ds ;
	
	​    static {
	
	​        try {
	​            //1.加载配置文件
	​            Properties pro = new Properties();
	​            //使用ClassLoader加载配置文件，获取字节输入流
	​            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&#34;druid.properties&#34;);
	​            pro.load(is);
	
	​            //2.初始化连接池对象
	​            ds = DruidDataSourceFactory.createDataSource(pro);
	
	​        } catch (IOException e) {
	​            e.printStackTrace();
	​        } catch (Exception e) {
	​            e.printStackTrace();
	​        }
	​    }
	
	​    /**
	     * 获取连接池对象
	          */
	        public static DataSource getDataSource(){
	        return ds;
	        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		    /**&lt;br&gt;
​		     * 获取连接 Connection 对象&lt;br&gt;
​		     &lt;em&gt;/&lt;br&gt;
​		    public static Connection getConnection() throws SQLException {&lt;br&gt;
​		        return  ds.getConnection();&lt;br&gt;
​		    }&lt;br&gt;
​		}&lt;br&gt;
​	5. 创建包 cn.itcast.dao, 创建类 UserDao, 提供 login 方法&lt;br&gt;
​		&lt;br&gt;
​		package cn.itcast.dao;&lt;br&gt;
​	&lt;br&gt;
​		import cn.itcast.domain.User;&lt;br&gt;
​		import cn.itcast.util.JDBCUtils;&lt;br&gt;
​		import org.springframework.dao.DataAccessException;&lt;br&gt;
​		import org.springframework.jdbc.core.BeanPropertyRowMapper;&lt;br&gt;
​		import org.springframework.jdbc.core.JdbcTemplate;&lt;br&gt;
​		&lt;br&gt;
​		/&lt;/em&gt;*&lt;br&gt;
​		 * 操作数据库中 User 表的类&lt;br&gt;
​		 */&lt;br&gt;
​		public class UserDao {&lt;br&gt;
​		&lt;br&gt;
// 声明 JDBCTemplate 对象共用&lt;br&gt;
 private JdbcTemplate template = new JdbcTemplate (JDBCUtils.getDataSource ());&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	    /**
	     * 登录方法
	     * @param loginUser 只有用户名和密码
	     * @return user包含用户全部数据,没有查询到，返回null
	     */
	    public User login(User loginUser){
	        try {
	            //1.编写sql
	            String sql = &#34;select * from user where username = ? and password = ?&#34;;
	            //2.调用query方法
	            User user = template.queryForObject(sql,
	                    new BeanPropertyRowMapper&amp;lt;User&amp;gt;(User.class),
	                    loginUser.getUsername(), loginUser.getPassword());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		            return user;&lt;br&gt;
​		        } catch (DataAccessException e) {&lt;br&gt;
​		            e.printStackTrace ();// 记录日志&lt;br&gt;
​		            return null;&lt;br&gt;
​		        }&lt;br&gt;
​		    }&lt;br&gt;
​		}&lt;br&gt;
​&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6. 编写cn.itcast.web.servlet.LoginServlet类
	package cn.itcast.web.servlet;

​	import cn.itcast.dao.UserDao;
​	import cn.itcast.domain.User;
​	
​	import javax.servlet.ServletException;
​	import javax.servlet.annotation.WebServlet;
​	import javax.servlet.http.HttpServlet;
​	import javax.servlet.http.HttpServletRequest;
​	import javax.servlet.http.HttpServletResponse;
​	import java.io.IOException;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		@WebServlet(&#34;/loginServlet&#34;)&lt;br&gt;
​		public class LoginServlet extends HttpServlet {&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		    @Override&lt;br&gt;
​		    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {&lt;br&gt;
​		        &lt;a href=&#34;//1.xn--d8yz4mshv84b&#34;&gt;//1. 设置编码&lt;/a&gt;&lt;br&gt;
​		        req.setCharacterEncoding (&#34;utf-8&#34;);&lt;br&gt;
​		        &lt;a href=&#34;//2.xn--8nrrb831grng2u5admk&#34;&gt;//2. 获取请求参数&lt;/a&gt;&lt;br&gt;
​		        String username = req.getParameter (&#34;username&#34;);&lt;br&gt;
​		        String password = req.getParameter(&#34;password&#34;);&lt;br&gt;
​		        &lt;a href=&#34;//3.xn--user-ou9gnbx382dmbg&#34;&gt;//3. 封装 user 对象&lt;/a&gt;&lt;br&gt;
​		        User loginUser = new User ();&lt;br&gt;
​		        loginUser.setUsername(username);&lt;br&gt;
​		        loginUser.setPassword(password);&lt;br&gt;
​		&lt;br&gt;
​		        &lt;a href=&#34;//4.xn--UserDaologin-g98y914e5q2aktew64i&#34;&gt;//4. 调用 UserDao 的 login 方法&lt;/a&gt;&lt;br&gt;
​		        UserDao dao = new UserDao ();&lt;br&gt;
​		        User user = dao.login(loginUser);&lt;br&gt;
​		&lt;br&gt;
​		        &lt;a href=&#34;//5.xn--user-zk9fu84h&#34;&gt;//5. 判断 user&lt;/a&gt;&lt;br&gt;
​		        if(user == null){&lt;br&gt;
​		            // 登录失败&lt;br&gt;
​		            req.getRequestDispatcher (&#34;/failServlet&#34;).forward (req,resp);&lt;br&gt;
​		        }else{&lt;br&gt;
​		            // 登录成功&lt;br&gt;
​		            // 存储数据&lt;br&gt;
​		            req.setAttribute (&#34;user&#34;,user);&lt;br&gt;
​		            // 转发&lt;br&gt;
​		            req.getRequestDispatcher (&#34;/successServlet&#34;).forward (req,resp);&lt;br&gt;
​		        }&lt;br&gt;
​		&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    @Override&lt;br&gt;
​		    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {&lt;br&gt;
​		        this.doGet(req,resp);&lt;br&gt;
​		    }&lt;br&gt;
​		}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7. 编写FailServlet和SuccessServlet类
	@WebServlet(&#34;/successServlet&#34;)
	public class SuccessServlet extends HttpServlet {
	    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	        //获取request域中共享的user对象
	        User user = (User) request.getAttribute(&#34;user&#34;);
	
	        if(user != null){
	            //给页面写一句话
	
	            //设置编码
	            response.setContentType(&#34;text/html;charset=utf-8&#34;);
	            //输出
	            response.getWriter().write(&#34;登录成功！&#34;+user.getUsername()+&#34;,欢迎您&#34;);
	        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		    }&lt;/p&gt;
&lt;p&gt;​		@WebServlet(&#34;/failServlet&#34;)&lt;br&gt;
​		public class FailServlet extends HttpServlet {&lt;br&gt;
​		    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {&lt;br&gt;
​		        // 给页面写一句话&lt;br&gt;
​		&lt;br&gt;
​		        // 设置编码&lt;br&gt;
​		        response.setContentType (&#34;text/html;charset=utf-8&#34;);&lt;br&gt;
​		        // 输出&lt;br&gt;
​		        response.getWriter ().write (&#34;登录失败，用户名或密码错误&#34;);&lt;br&gt;
​		&lt;br&gt;
​		    }&lt;br&gt;
​		&lt;br&gt;
​		    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {&lt;br&gt;
​		        this.doPost(request,response);&lt;br&gt;
​		    }&lt;br&gt;
​		}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8. login.html中form表单的action路径的写法
	* 虚拟目录+Servlet的资源路径

9. BeanUtils工具类，简化数据封装
	* 用于封装JavaBean的
	1. JavaBean：标准的Java类
		1. 要求：
			1. 类必须被public修饰
			2. 必须提供空参的构造器
			3. 成员变量必须使用private修饰
			4. 提供公共setter和getter方法
		2. 功能：封装数据

	2. 概念：
		成员变量：
		属性：setter和getter方法截取后的产物
			例如：getUsername() --&amp;gt; Username--&amp;gt; username

	3. 方法：
		1. setProperty()
		2. getProperty()
		3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中&lt;/code&gt;&lt;/pre&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
            const img = document.createElement(&#39;img&#39;);
            img.style = &#39;display:none !important;&#39;;
            img.src = el.dataset.src;
            img.addEventListener(&#39;error&#39;, () =&gt; {
              img.remove();
              el.style.color = &#39;inherit&#39;;
              el.style.backgroundImage = &#39;none&#39;;
              el.style.background = &#39;none&#39;;
            });
            img.addEventListener(&#39;load&#39;, () =&gt; {
              img.remove();
            });
            document.body.appendChild(img);
          });
      &lt;/script&gt; ]]></description>
        </item>
    </channel>
</rss>
