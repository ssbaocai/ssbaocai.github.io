{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"框架\" tag",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/SpringBoot/",
            "url": "https://www.baocai-blog.cn/2020/10/13/SpringBoot/",
            "title": "SpringBoot",
            "date_published": "2020-10-13T13:46:19.631Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"springboot\"><a class=\"anchor\" href=\"#springboot\">#</a> SpringBoot</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是springboot\"><a class=\"anchor\" href=\"#什么是springboot\">#</a> 什么是 SpringBoot</h3>\n<p>spring boot 为 spring 服务，用来简化新 spring 应用的初始搭建以及开发过程</p>\n<h3 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h3>\n<ol>\n<li>\n<p>减少开发，测试时间和努力。</p>\n</li>\n<li>\n<p>使用 JavaConfig 有助于避免使用 XML。</p>\n</li>\n<li>\n<p>避免大量的 Maven 导入和各种版本冲突。</p>\n</li>\n<li>\n<p>提供意见发展方法。</p>\n</li>\n<li>\n<p>通过提供默认值快速开始开发。</p>\n</li>\n<li>\n<p>没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish 或其他任何东西。</p>\n</li>\n<li>\n<p>需要更少的配置 因为没有 web.xml 文件。只需添加用 @ Configuration 注释的类，然后添加用 @Bean 注释的方法，Spring 将自动加载对象并像以前一样对其进行管理。您甚至可以将 @Autowired 添加到 bean 方法中，以使 Spring 自动装入需要的依赖关系中。</p>\n</li>\n<li>\n<p>基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active = {enviornment}。在加载主应用程序属性文件后，Spring 将在（application {environment} .properties）中加载后续的应用程序属性文件。</p>\n</li>\n</ol>\n<h2 id=\"常见问题\"><a class=\"anchor\" href=\"#常见问题\">#</a> 常见问题</h2>\n<h3 id=\"springboot核心配置文件\"><a class=\"anchor\" href=\"#springboot核心配置文件\">#</a> SpringBoot 核心配置文件</h3>\n<ul>\n<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li>\n<li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/MyBatis/",
            "url": "https://www.baocai-blog.cn/2020/10/13/MyBatis/",
            "title": "MyBatis",
            "date_published": "2020-10-13T13:17:48.784Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"mybatis\"><a class=\"anchor\" href=\"#mybatis\">#</a> MyBatis</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是mybatis\"><a class=\"anchor\" href=\"#什么是mybatis\">#</a> 什么是 MyBatis</h3>\n<p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</p>\n<h3 id=\"mybatis优点\"><a class=\"anchor\" href=\"#mybatis优点\">#</a> MyBatis 优点</h3>\n<ol>\n<li>基于 SQL 语句，灵活</li>\n<li>降低代码量</li>\n<li>与数据库兼容</li>\n<li>与 Spring 集成</li>\n</ol>\n<h2 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h2>\n<h3 id=\"mybatis缓存\"><a class=\"anchor\" href=\"#mybatis缓存\">#</a> MyBatis 缓存</h3>\n<p>MyBatis 的缓存分为一级缓存和二级存，一级缓存放在 session 里面，默认就有，二级缓 存放在它的命名空间里，默认是不打开的，使用二级缓存属性类需要实现 Serializable 序列化 接口 (可用来保存对象的状态), 可在它的映射文件中配置 &lt; cache/&gt;</p>\n<h3 id=\"mybatis分页\"><a class=\"anchor\" href=\"#mybatis分页\">#</a> MyBatis 分页</h3>\n<ul>\n<li>\n<p>分页方式：Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。</p>\n</li>\n<li>\n<p>分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦 截待执行的 sql，然后重写 sql</p>\n</li>\n</ul>\n<h3 id=\"和的区别是什么\"><a class=\"anchor\" href=\"#和的区别是什么\">#</a> #{} 和 ${} 的区别是什么？</h3>\n<ol>\n<li>\n<p>#{} 是预编译处理，${} 是字符串替换。</p>\n</li>\n<li>\n<p>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为？号，调用 PreparedStatement 的 set 方法 来赋值；</p>\n</li>\n<li>\n<p>Mybatis 在处理<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow></mrow><mtext>时，就是把</mtext></mrow><annotation encoding=\"application/x-tex\">{}时，就是把</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">就</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">把</span></span></span></span> {} 替换成变量的值。</p>\n</li>\n<li>\n<p>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性</p>\n</li>\n</ol>\n<h3 id=\"mybatis编程步骤\"><a class=\"anchor\" href=\"#mybatis编程步骤\">#</a> Mybatis 编程步骤</h3>\n<ol>\n<li>创建 SqlSessionFactory</li>\n<li>通过 SqlSessionFactory 创建 SqlSession</li>\n<li>通过 sqlsession 执行数据库操作</li>\n<li>调用 session.commit () 提交事务</li>\n<li>调用 session.close () 关闭会话</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/Spring/",
            "url": "https://www.baocai-blog.cn/2020/10/13/Spring/",
            "title": "Spring",
            "date_published": "2020-10-13T13:01:03.426Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"spring\"><a class=\"anchor\" href=\"#spring\">#</a> Spring</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是spring\"><a class=\"anchor\" href=\"#什么是spring\">#</a> 什么是 Spring</h3>\n<p>Spring 是个 java 企业级应用的开源开发框架。Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</p>\n<h2 id=\"aop\"><a class=\"anchor\" href=\"#aop\">#</a> AOP</h2>\n<h3 id=\"什么是aop\"><a class=\"anchor\" href=\"#什么是aop\">#</a> 什么是 AOP</h3>\n<p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>\n<h2 id=\"ioc\"><a class=\"anchor\" href=\"#ioc\">#</a> IOC</h2>\n<h3 id=\"什么是ioc\"><a class=\"anchor\" href=\"#什么是ioc\">#</a> 什么是 IOC</h3>\n<ul>\n<li>IOC 容器负责实例化、配置程序中的对象及建立对象间的依赖。\"控制反转\" 是指 new 实例工作交给 Spring 容器来做。</li>\n<li>所谓 IoC (控制反转)，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</li>\n</ul>\n<h3 id=\"ioc优点\"><a class=\"anchor\" href=\"#ioc优点\">#</a> IOC 优点</h3>\n<ol>\n<li>降低代码量</li>\n<li>易于测试</li>\n<li>轻松实现耦合</li>\n<li>支持饿汉式初始化和懒加载</li>\n</ol>\n<h2 id=\"依赖\"><a class=\"anchor\" href=\"#依赖\">#</a> 依赖</h2>\n<h3 id=\"什么是依赖注入\"><a class=\"anchor\" href=\"#什么是依赖注入\">#</a> 什么是依赖注入</h3>\n<p>spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。</p>\n<h3 id=\"依赖注入方式\"><a class=\"anchor\" href=\"#依赖注入方式\">#</a> 依赖注入方式</h3>\n<ul>\n<li>setter 属性注入</li>\n<li>构造方法注入</li>\n<li>接口注入</li>\n</ul>\n<h2 id=\"特性\"><a class=\"anchor\" href=\"#特性\">#</a> 特性</h2>\n<h3 id=\"spring优点\"><a class=\"anchor\" href=\"#spring优点\">#</a> Spring 优点</h3>\n<ol>\n<li>\n<p>方便解耦 ——Spring 提供的 IoC 容器实现了对象依赖关系的管理，避免了硬编码导致的耦合。</p>\n</li>\n<li>\n<p>支持 AOP——Spring 提供的 AOP 功能，方便进行面向切面编程。</p>\n</li>\n<li>\n<p>集成了多种优秀框架 ——Spring 提供了对各种优秀框架（如 Struts、Hibernate、Hessian、Quartz 等）的直接支持。</p>\n</li>\n<li>\n<p>降低对 API 依赖</p>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/SpringMVC/",
            "url": "https://www.baocai-blog.cn/2020/10/13/SpringMVC/",
            "title": "SpringMVC",
            "date_published": "2020-10-13T12:08:53.439Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"springmvc\"><a class=\"anchor\" href=\"#springmvc\">#</a> SpringMVC</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<h3 id=\"什么是springmvc\"><a class=\"anchor\" href=\"#什么是springmvc\">#</a> 什么是 SpringMVC</h3>\n<p>SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。 简化开发，减少出错。</p>\n<h2 id=\"特性\"><a class=\"anchor\" href=\"#特性\">#</a> 特性</h2>\n<h3 id=\"springmvc的优点\"><a class=\"anchor\" href=\"#springmvc的优点\">#</a> SpringMVC 的优点</h3>\n<ol>\n<li>\n<p>它是基于组件技术的。全部的应用对象，无论控制器和视图，还是业务对象之类的都是 java 组件。并且和 Spring 提供的其他基础结构紧密集成.</p>\n</li>\n<li>\n<p>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的)</p>\n</li>\n<li>\n<p>可以任意使用各种视图技术，而不仅仅局限于 JSP</p>\n</li>\n<li>\n<p>支持各种请求资源的映射策略</p>\n</li>\n<li>\n<p>它应是易于扩展的</p>\n</li>\n</ol>\n<h2 id=\"工作原理\"><a class=\"anchor\" href=\"#工作原理\">#</a> 工作原理</h2>\n<h3 id=\"springmvc的工作原理\"><a class=\"anchor\" href=\"#springmvc的工作原理\">#</a> SpringMVC 的工作原理</h3>\n<ol>\n<li>\n<p>客户端发送请求 DispatcherServlet</p>\n</li>\n<li>\n<p>DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller</p>\n</li>\n<li>\n<p>Controller 调用业务逻辑后，返回 ModelAndView</p>\n</li>\n<li>\n<p>DispatcherServlet 查询 ModelAndView，找到指定视图</p>\n</li>\n<li>\n<p>视图将结果返回到客户端</p>\n</li>\n</ol>\n<h3 id=\"springmvc常用注解\"><a class=\"anchor\" href=\"#springmvc常用注解\">#</a> SpringMVC 常用注解</h3>\n<ol>\n<li>\n<p>@requestMapping 用于请求 url 映射。</p>\n</li>\n<li>\n<p>@RequestBody 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。</p>\n</li>\n<li>\n<p>@ResponseBody 注解实现将 controller 方法返回对象转化为 json 响应给客户。</p>\n</li>\n</ol>\n<h2 id=\"常见问题\"><a class=\"anchor\" href=\"#常见问题\">#</a> 常见问题</h2>\n<h3 id=\"如何解决getpost乱码\"><a class=\"anchor\" href=\"#如何解决getpost乱码\">#</a> 如何解决 get/post 乱码</h3>\n<ul>\n<li>解决 post 请求乱码：我们可以在 web.xml 里边配置一个 CharacterEncodingFilter 过滤器。 设置为 utf-8，解决 get 请求的乱码：有两种方法。</li>\n<li>get 请求中文参数出现乱码解决方法有两个:</li>\n</ul>\n<ol>\n<li>\n<p>修改 tomcat 配置文件添加编码与工程编码一致。</p>\n</li>\n<li>\n<p>另 外 一 种 方 法 对 参 数 进 行 重 新 编 码 String userName = New String (Request.getParameter (“userName”).getBytes (“ISO8859-1”), “utf-8”);</p>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "框架"
            ]
        }
    ]
}