{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"设计模式\" tag",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "url": "https://www.baocai-blog.cn/2020/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "title": "设计模式",
            "date_published": "2020-10-04T06:58:46.830Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"熟悉的设计模式\"><a class=\"anchor\" href=\"#熟悉的设计模式\">#</a> 熟悉的设计模式？</h4>\n<ul>\n<li>单例模式：保证被创建一次，节省系统开销。</li>\n<li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li>\n<li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li>\n<li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li>\n<li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li>\n<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "设计模式"
            ]
        }
    ]
}