{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"java基础\" tag",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/13/JavaWeb/",
            "url": "https://www.baocai-blog.cn/2020/10/13/JavaWeb/",
            "title": "JavaWeb",
            "date_published": "2020-10-13T13:44:14.924Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"javaweb\"><a class=\"anchor\" href=\"#javaweb\">#</a> JavaWeb</h1>\n<h3 id=\"说下原生jdbc操作数据库流程\"><a class=\"anchor\" href=\"#说下原生jdbc操作数据库流程\">#</a> 说下原生 jdbc 操作数据库流程？</h3>\n<ul>\n<li>第一步：Class.forName () 加载数据库连接驱动；</li>\n<li>第二步：DriverManager.getConnection () 获取数据连接对象；</li>\n<li>第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;</li>\n<li>第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX ();</li>\n<li>第五步：关闭结果集、关闭会话、关闭连接。<br>\n详细代码请看（封装）：<span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjk1NDI2MTEvYXJ0aWNsZS9kZXRhaWxzLzUyNDI2MDA2\">http://blog.csdn.net/qq_29542611/article/details/52426006</span></li>\n</ul>\n<h3 id=\"session-和-cookie-有什么区别\"><a class=\"anchor\" href=\"#session-和-cookie-有什么区别\">#</a> session 和 cookie 有什么区别？</h3>\n<ul>\n<li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li>\n<li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li>\n<li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li>\n<li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li>\n</ul>\n<h3 id=\"简述-tcp-和-udp的区别\"><a class=\"anchor\" href=\"#简述-tcp-和-udp的区别\">#</a> 简述 tcp 和 udp 的区别？</h3>\n<p><strong>tcp</strong> 和 <strong>udp</strong> 是 OSI 模型中的运输层中的协议。</p>\n<p><strong>tcp</strong> 提供可靠的通信传输    <strong>udp</strong> 则常被用于让广播和细节控制交给应用的通信传输。</p>\n<p>两者的区别大致如下：</p>\n<ul>\n<li>tcp <strong>面向连接</strong>，udp <strong>面向非连接</strong>即发送数据前不需要建立链接；</li>\n<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>\n<li>tcp 面向字节流，udp 面向报文；</li>\n<li>tcp 数据传输慢，udp 数据传输快；</li>\n</ul>\n<h3 id=\"tcp三次握手\"><a class=\"anchor\" href=\"#tcp三次握手\">#</a> tcp 三次握手</h3>\n<p>第一次</p>\n<p>第一次握手：建立连接时，客户端  发送<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4=\"> syn</span> 包（seq=j）到  服务器，并进入 SYN_SENT 状态，等待  服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 [3]</p>\n<p>第二次</p>\n<p>第二次握手：服务器  收到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zeW4=\"> syn</span> 包，必须确认  客户端  的 SYN（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=\">ack</span>=j+1），同时自己也发送一个 SYN 包（seq=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。 [3]</p>\n<p>第三次</p>\n<p>第三次握手：客户端  收到  服务器  的 SYN+ACK 包，向  服务器  发送确认包 ACK (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9hY2s=\">ack</span>=k+1），此包发送完毕，客户端和服务器进入<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9FU1RBQkxJU0hFRA==\"> ESTABLISHED</span>（TCP 连接成功）状态，完成三次握手。</p>\n<h3 id=\"为什么要三次握手两次不行吗为什么\"><a class=\"anchor\" href=\"#为什么要三次握手两次不行吗为什么\">#</a> 为什么要三次握手，两次不行吗？为什么？</h3>\n<p>如果采用两次握手，那么只要<strong>服务器</strong>发出确认数据包就会建立连接，但由于<strong>客户端</strong>此时并未响应服务器端的请求，那此时<strong>服务器端</strong>就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。</p>\n<p>若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "Java基础"
            ]
        },
        {
            "id": "https://www.baocai-blog.cn/2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "url": "https://www.baocai-blog.cn/2020/10/10/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "title": "Java基础语法",
            "date_published": "2020-10-10T04:45:31.957Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"java基础语法\"><a class=\"anchor\" href=\"#java基础语法\">#</a> JAVA 基础语法</h1>\n<h2 id=\"基础语法\"><a class=\"anchor\" href=\"#基础语法\">#</a> 基础语法</h2>\n<h3 id=\"运算符\"><a class=\"anchor\" href=\"#运算符\">#</a> 运算符</h3>\n<p>算数运算符、关系运算符、赋值运算符、逻辑运算符、三目运算符</p>\n<h3 id=\"数据类型\"><a class=\"anchor\" href=\"#数据类型\">#</a> 数据类型</h3>\n<h4 id=\"基本数据类型\"><a class=\"anchor\" href=\"#基本数据类型\">#</a> 基本数据类型</h4>\n<ul>\n<li>byte、short、int、long</li>\n<li>float、double、char</li>\n<li>boolean</li>\n</ul>\n<h4 id=\"引用数据类型\"><a class=\"anchor\" href=\"#引用数据类型\">#</a> 引用数据类型</h4>\n<ul>\n<li>class</li>\n<li>interface</li>\n<li>数组</li>\n</ul>\n<h2 id=\"流程控制\"><a class=\"anchor\" href=\"#流程控制\">#</a> 流程控制</h2>\n<h3 id=\"if\"><a class=\"anchor\" href=\"#if\">#</a> if</h3>\n<p>if 条件结构是根据条件判断之后再做处理</p>\n<h3 id=\"switch\"><a class=\"anchor\" href=\"#switch\">#</a> switch</h3>\n<ul>\n<li>\n<p>switch (表达式){</p>\n<p>case 取值 1: 语句块 1;break;<br>\ncase 取值 n: 语句块 n;break; \t\t<br>\ndefault: 语句块 n+1;break;<br>\n}</p>\n</li>\n<li>\n<p>switch 语句有关规则 表达式的返回值必须是下述几种类型之一：int,byte,char,short,String；</p>\n</li>\n<li>\n<p>case 子句中的取值必须是常量，且所有 case 子句中的取值应是不同的；</p>\n</li>\n</ul>\n<h3 id=\"while\"><a class=\"anchor\" href=\"#while\">#</a> while</h3>\n<ul>\n<li>while 循环<br>\n符合条件，循环继续执行；否则，循环退出<br>\n特点：先判断，再执行</li>\n<li>do-while 循环<br>\n先执行一遍循环操作，符合条件，循环继续执行；否则，循环退出<br>\n特点：先执行，再判断</li>\n</ul>\n<h3 id=\"for\"><a class=\"anchor\" href=\"#for\">#</a> for</h3>\n<p>语法：<br>\nfor (初始化参数；判断条件；更新循环变量){<br>\n循环体；<br>\n}</p>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<h3 id=\"冒泡排序\"><a class=\"anchor\" href=\"#冒泡排序\">#</a> 冒泡排序</h3>\n<p>原理：</p>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的</li>\n</ul>\n<h3 id=\"二分查找\"><a class=\"anchor\" href=\"#二分查找\">#</a> 二分查找</h3>\n<p>二分查找也叫折半查找，是一种基本的查找算法，需要待查的表满足两个条件：</p>\n<ol>\n<li>\n<p>查找表必须使用顺序的存储结构</p>\n</li>\n<li>\n<p>查找表必须按关键字大小有序排列</p>\n</li>\n</ol>\n<p>算法的基本思想是：</p>\n<ul>\n<li>\n<p>将查找表中间位置数据元素的关键字与给定关键字比较，如果相等则查找成功；</p>\n</li>\n<li>\n<p>否则利用中间元素将表一分为二，如果中间关键字大于给定关键字，则在前一子表中进行折半查找，否则在后一子表中进行折半查找。</p>\n</li>\n<li>\n<p>重复以上过程直到找到满足条件的元素，则查找成功；或直到子表为空为止，此时查找不成功。</p>\n</li>\n</ul>\n<p>二分查找递归写法：</p>\n<pre><code>public int firstOccurrence (int [] nums,int target){\n    int low = 0,high = nums.length - 1;\n    while(low &lt;=  high){   \n        int mid = low + (high-low)/2;\n        if(nums[mid] == target){\n            return mid;\n        }\n        if(nums[mid] &lt; target){\n            low = mid+1;\n        }else {\n            high = mid-1;\n        }\n    }\n    return -1;\n}\n</code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "Java基础"
            ]
        }
    ]
}