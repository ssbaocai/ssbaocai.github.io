{
    "version": "https://jsonfeed.org/version/1",
    "title": "手撕包菜 • All posts by \"xml，json\" tag",
    "description": "",
    "home_page_url": "https://www.baocai-blog.cn",
    "items": [
        {
            "id": "https://www.baocai-blog.cn/2020/10/27/XML%E5%92%8CJSON/",
            "url": "https://www.baocai-blog.cn/2020/10/27/XML%E5%92%8CJSON/",
            "title": "XML和JSON",
            "date_published": "2020-10-27T13:06:54.827Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"xml和json\"><a class=\"anchor\" href=\"#xml和json\">#</a> XML 和 JSON</h1>\n<h2 id=\"xml\"><a class=\"anchor\" href=\"#xml\">#</a> XML</h2>\n<h3 id=\"声明\"><a class=\"anchor\" href=\"#声明\">#</a> 声明</h3>\n<p>&lt;?xml version=\"1.0\"encoding=\"UTF-8\"?&gt;</p>\n<h3 id=\"概念和作用\"><a class=\"anchor\" href=\"#概念和作用\">#</a> 概念和作用</h3>\n<p>可扩展标记语言（eXtensible Markup Language）。<br>\n特性:</p>\n<ol>\n<li>\n<p>xml 具有平台无关性，是一门独立的标记语言.</p>\n</li>\n<li>\n<p>xml 具有自我描述性</p>\n<p>.XML 文件是保存 XML 数据的一种方式</p>\n</li>\n</ol>\n<h3 id=\"标记\"><a class=\"anchor\" href=\"#标记\">#</a> 标记</h3>\n<p>标记名称: &nbsp;<br>\n自定义名称，必须遵循以下命名规则：</p>\n<ol>\n<li>\n<p>名称可以含字母、数字以及其他的字符</p>\n</li>\n<li>\n<p>名称不能以数字或者标点符号开始</p>\n</li>\n<li>\n<p>名称不能以字符 “xml”（或者 XML、Xml）开始</p>\n</li>\n<li>\n<p>名称不能包含空格，不能包含冒（:）</p>\n</li>\n<li>\n<p>名称区分大小写<br>\n例如:</p>\n<pre><code></code></pre>\n</li>\n</ol>\n<p>&lt;persons&gt;<br>\n&lt;person&gt;</p>\n<pre><code>      &lt;name&gt;李四&lt;/name&gt;\n\n      &lt;length&gt;180cm&lt;/length&gt; &nbsp; &nbsp; &nbsp; \n\n&lt;/person&gt; \n   &lt;person&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;           、\n\n       &lt;name&gt;李四&lt;/name&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\n       &lt;length&gt;200cm&lt;/length&gt; &nbsp; &nbsp; &nbsp;  \n\n    &lt;/person&gt; &nbsp; &nbsp; &nbsp; &nbsp;  \n</code></pre>\n<p>&lt;/persons&gt;</p>\n<pre><code>\n\n\n### 标记中添加属性\n\n标记中的属性, 在标记开始时 描述, 由属性名和属性值 组成. &nbsp; &nbsp; &nbsp;  \n格式: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n1. 在开始标记中, 描述属性. &nbsp; &nbsp; &nbsp; &nbsp; \n\n2. 可以包含0-n个属性, 每一个属性是一个键值对! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n\n3. 属性名不允许重复 , 键与值之间使用等号连接, 多个属性之间使用空格分割. \n\n4. 属性值 必须被引号引住.\n 案例: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n\n  ```\n   &lt;persons&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n           &lt;person id=\"10001\" groupid=\"1\"&gt; &nbsp; &nbsp;\n  \n    ​                 &lt;name&gt;李四&lt;/name&gt;\n  \n    ​                 &lt;age&gt;18&lt;/age&gt; \n  \n    ​         &lt;/person&gt;\n    ​         &lt;person id=\"10002\" groupid=\"1\"&gt; &nbsp; &nbsp; \n  \n    ​                &lt;name&gt;李四&lt;/name&gt; &nbsp; &nbsp;\n  \n    ​                &lt;age&gt;20&lt;/age&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n  \n    ​         &lt;/person&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n  \n    &lt;/persons&gt;\n  ```\n \n  \n\n\n### 注释\n\n格式: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n   注释开始: &nbsp; &lt;!- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n   注释结束: &nbsp; --&gt;\n\n## XML解析\n\n### SAX解析\n\n解析方式是事件驱动机制! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \n\nSAX解析器, 逐行读取XML文件解析 , 每当解析到一个标签的开始/结束/内容/属性时,触发事件.\n优点: \n\n1. 分析能够立即开始，而不是等待所有的数据被处理\n2. 逐行加载,节省内存.有助于解析大于系统内存的文档\n3. 有时不必解析整个文档,它可以在某个条件得到满足时停止解析.\n\n缺点: \n1. 单向解析，无法定位文档层次，无法同时访问同一文档的不同部分数据(因为逐 行解析, 当解析第n行是, 第n-1行已经被释放了, 无法在进行操作了). &nbsp; &nbsp; &nbsp; &nbsp; \n2. 无法得知事件发生时元素的层次, 只能自己维护节点的父/子关系. &nbsp; &nbsp; &nbsp; &nbsp; \n3. 只读解析方式, 无法修改XML文档的内容.\n\n### DOM解析\n\n是用与平台和语言无关的方式表示XML文档的官方W3C标准，分析该结构通常需要加载整个文档和内存中建立文档树模型.程序员可以通过操作文档树, 来完成数据的获取 修改 删除等.\n\n优点: \n1. 文档在内存中加载, 允许对数据和结构做出更改.\n2. 访问是双向的，可以在任何时候在树中双向解析数据。\n\n缺点:\n   文档全部加载在内存中 , 消耗资源大.\n\n\n### JDOM解析\n\n目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一 个Java特定模型，JDOM一直得到大力推广和促进。\nJDOM文档声明其目的是“使用20%（或更少）的精力解决80%（或更多）Java/XML问题” （根据学习曲线假定为20%）     优点: \n1. 使用具体类而不是接口，简化了DOM的API。\n2. 大量使用了Java集合类，方便了Java开发人员。\n\n缺点:\n1. 没有较好的灵活性。                \n2. 性能不是那么优异\n\n### DOM4J解析\n\n它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath 支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项， DOM4J是一个非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一 个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML。\n目前许多开源项目中大量采用DOM4J , 例如:Hibernate\n步骤:\n1.  引入jar文件 dom4j.jar &nbsp;  \n2.  创建一个指向XML文件的输入流 &nbsp; &nbsp; &nbsp; &nbsp; FileInputStream fis = new FileInputStream(\"xml文件的地址\"); \n3.  创建一个XML读取工具对象 &nbsp; &nbsp; &nbsp; &nbsp; SAXReader sr = new SAXReader(); &nbsp; \n4.  使用读取工具对象, 读取XML文档的输入流 , 并得到文档对象 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Document doc = sr.read(fis); &nbsp; &nbsp; \n5.   通过文档对象, 获取XML文档中的根元素对象   &nbsp;Element root = doc.getRootElement();\n\n## JSON\n\n### 概念\n\nJSON: JavaScript Object Notation \nJS对象简谱 , 是一种轻量级的数据交换格式.\n\n\n### 对象格式\n\n</code></pre>\n<p>js:</p>\n<p>​\tvar b = new Object();</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2IubmFtZQ==\">b.name</span> = \"金苹果\";</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2IuaW5mbw==\">b.info</span> = \"种苹果\";</p>\n<p>XML:</p>\n<p>​\t\t&lt;book&gt;</p>\n<p>​\t\t\t\t &lt;name&gt; 金苹果 &lt;/name&gt;</p>\n<p>​\t\t\t\t&lt;info&gt; 种苹果 &lt;/info&gt;</p>\n<p>​\t\t&lt;/book&gt;</p>\n<p  =\"\" name:金苹果, info:种苹果 =\"\">JSON: &nbsp;     </p>\n<pre><code>\n\n 一个对象, 由一个大括号表示. &nbsp; &nbsp; &nbsp;  \n\n括号中 描述对象的属性 .  通过键值对来描述对象的属性(可以理解为, 大括号中, 包含的是一个个的键值对.) &nbsp; &nbsp; &nbsp; \n\n 格式:            \n 1. 键与值之间使用冒号连接, 多个键值对之间使用逗号分隔.            \n 2. 键值对的键 应使用引号引住 (通常Java解析时, 键不使用引号会报错. 而JS能正确解 析.)            \n 3. 键值对的值, 可以是JS中的任意类型的数据\n\n\n### GSON\n\n- 将对象转换为JSON字符串\n转换JSON字符串的步骤: &nbsp; \n1. 引入JAR包 &nbsp; &nbsp;\n\n2. 在需要转换JSON字符串的位置编写如下代码即可: &nbsp; &nbsp; &nbsp; &nbsp;String json = new Gson().toJSON(要转换的对象);   \n   案例: &nbsp;  \n       Book b = BookDao.find();   \n       String json = new Gson().toJson(b); &nbsp; \n\n      &nbsp;System.out.println(json);\n- 将JSON字符串转换为对象\n1. &nbsp;引入JAR包 &nbsp; &nbsp;\n2. &nbsp;在需要转换Java对象的位置, 编写如下代码: &nbsp; &nbsp; &nbsp; 对象 = new Gson().fromJson(JSON字符串,对象类型.class);\n\n案例: &nbsp; &nbsp;\n\n​      String json = \"{\\\"id\\\":1,\\\"name\\\":\\\"金苹果\\\",\\\"author\\\":\\\"李伟杰 \\\",\\\"info\\\":\\\"嘿嘿嘿嘿嘿嘿\\\",\\\"price\\\":198.0}\"; &nbsp; &nbsp;\n\n​      Book book = new Gson().fromJson(json, Book.class); &nbsp; &nbsp;\n\n​      System.out.println(book);\n\n\n### FastJson\n\n- 将对象转换为JSON字符串\n转换JSON字符串的步骤: &nbsp; &nbsp;\n1. 引入JAR包 &nbsp; &nbsp;\n\n2. &nbsp;在需要转换JSON字符串的位置编写如下代码即可: &nbsp; &nbsp; &nbsp; &nbsp;\nString json=JSON.toJSONString(要转换的对象); &nbsp; &nbsp; &nbsp; &nbsp; \n\n   案例: &nbsp;  \n   \n    Book b = BookDao.find(); &nbsp; &nbsp;\n\n​        String json=JSON.toJSONString(b); &nbsp; &nbsp;\n\n​        System.out.println(json);\n\n- 将JSON字符串转换为对象\n1. &nbsp;引入JAR包 &nbsp; \n2. &nbsp;在需要转换Java对象的位置, 编写如下代码: &nbsp; &nbsp; &nbsp;     类型 对象名=JSON.parseObject(JSON字符串, 类型.class);                或 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List&lt;类型&gt; list=JSON.parseArray(JSON字符串,类型.class); \n\n   案例: &nbsp; &nbsp;\n\n​         String json = \"{\\\"id\\\":1,\\\"name\\\":\\\"金苹果\\\",\\\"author\\\":\\\"李伟杰 \\\",\\\"info\\\":\\\"嘿嘿嘿嘿嘿嘿\\\",\\\"price\\\":198.0}\"; &nbsp; &nbsp;\n\n​         Book book = JSON.parseObject(json, Book.class); &nbsp; &nbsp;System.out.println(book);</code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>",
            "tags": [
                "XML，JSON"
            ]
        }
    ]
}